


define('src/debug',[],function () {
	var log, time, timeEnd;

	if (typeof(console) === "undefined" && typeof(window) !== "undefined") {
		log = function () {};
		time = function () {};
		timeEnd = function () {};
	} else {
		log = function (message) { console.log(message); };
		time = function (message) { console.time(message); };
		timeEnd = function (message) { console.timeEnd(message); };
	}

	var assertEqual = function (actual, expected, place) {
		if (actual !== expected) {
			try {
				throw new Error("Assert fail: " + actual + " !== " + expected);
			} catch (err) {
				// put stack trace message in JSON - hack to access from window.onerror
				err.message = err.stack;
				throw err;
			}
		}
	};

	var assert = function (assertion, place) {
		var err;
		if (!assertion) {
			try {
				throw new Error("Assert fail");
			} catch (err) {
				// put stack trace message in JSON - hack to access from window.onerror
				err.message = err.stack;
				throw err;
			}
		}
	};

	return {
		assert : assert,
		assertEqual : assertEqual,
		log : log
	};
});



define('src/CslNode',['src/debug'], function (debug) {
	var CSLEDIT_CslNode = function (nameOrNode, attributes, children, cslId) {
	debug.assert(this instanceof CSLEDIT_CslNode);

		if (nameOrNode.hasOwnProperty("name")) {
			this.copy(nameOrNode);
			return;
		}

		this.name = nameOrNode;
		this.attributes = attributes || [];
		this.children = children || [];
		if (typeof cslId === "undefined") {
			this.cslId = -1;
		} else {
			this.cslId = cslId;
		}
	};

	// performs a shallow copy of source
	CSLEDIT_CslNode.prototype.copy = function (source) {
		this.name = source.name;
		this.attributes = source.attributes;
		this.children = source.children;
		this.textValue = source.textValue;
		this.cslId = source.cslId;
	};

	CSLEDIT_CslNode.prototype.setAttr = function (attr, value) {
		var index;

		index = this._indexOfAttr(attr);

		if (index === -1) {
			this.attributes.push({key: attr, value: value, enabled: true});
		} else {
			this.attributes[index].value = value;
			this.attributes[index].enabled = true;
		}
	};

	CSLEDIT_CslNode.prototype.setAttrEnabled = function (attr, enabled, defaultValue) {
		var index;

		defaultValue = defaultValue || "";

		index = this._indexOfAttr(attr);
		if (index === -1) {
			if (enabled) {
				this.attributes.push({
					key: attr,
					value: defaultValue, /* TODO: get default value */
					enabled: true
				});
				return;
			} else {
				// a non-existant attribute is equivalent to a disabled one
				return;
			}
		}
		this.attributes[index].enabled = enabled;
	};

	CSLEDIT_CslNode.prototype.hasAttr = function (attr) {
		var index = this._indexOfAttr(attr);
		return index !== -1 && this.attributes[index].enabled;
	};

	CSLEDIT_CslNode.prototype.getAttr = function (attr) {
		var index;

		index = this._indexOfAttr(attr);

		if (index === -1 ||
				(this.attributes[index].hasOwnProperty('enabled') && !this.attributes[index].enabled)) {
			return "";
		} else {
			return this.attributes[index].value;
		}
	};

	// private methods

	// returns -1 if can't find
	CSLEDIT_CslNode.prototype._indexOfAttr = function (attrName) {
		var index = -1;
		$.each(this.attributes, function (i, attr) {
			if (attr.key === attrName) {
				index = i;
				return false;
			}
		});
		return index;
	};

	return CSLEDIT_CslNode;
});



define('src/uiConfig',['src/CslNode', 'src/debug'], function (CSLEDIT_CslNode, debug) {
	var CSLEDIT_uiConfig = {};

	// if creating an empty node, populate with these attributes
	CSLEDIT_uiConfig.defaultAttributes = {
		"text" : {
			"value" : ""
		},
		"if" : {
			"type" : "article",
			"match" : "any"
		},
		"else-if" : {
			"type" : "article",
			"match" : "any"
		},
		"date" : {
			"form" : "text",
			"date-parts" : "year-month-day",
			"variable" : "issued"
		},
		"date-part" : {
			"name" : "year"
		},
		"key" : {
			"variable" : "author"
		}
	};

	CSLEDIT_uiConfig.attributeGroups = {
		"Text formatting" : [
			"fontFormattingControls",
			"display",
			"text-case"
		],
		"Affixes" : [
			"prefix",
			"suffix",
			"delimiter"
		]
	};

	// for displaying the example metadata in Search by Example page
	CSLEDIT_uiConfig.fieldOrder = [
		"type",
		"title",
		"author",
		"editor",
		"translator",
		"issued",
		"container-title",
		"volume",
		"issue",
		"chapter",
		"page",
		"publisher"
	];

	// add classes to the <input> or <select> elements for various attributes
	CSLEDIT_uiConfig.attributeClasses = {
		"delimiter" : "short",
		"display" : "exampleClass1 exampleClass2"
	};

	// for jstree
	CSLEDIT_uiConfig.nodeIcons = {
		"default" : "external/famfamfam-icons/bullet_black.png",
		"text" : "external/famfamfam-icons/style.png",
		"macro" : "external/famfamfam-icons/brick.png",
		"info" : "external/famfamfam-icons/information.png",
		"choose" : "external/fugue-icons/question-white.png",
		"date" : "external/famfamfam-icons/date.png",
		"style" : "external/famfamfam-icons/cog.png",
		"citation" : "external/famfamfam-icons/page_white_edit.png",
		"bibliography" : "external/famfamfam-icons/text_list_numbers.png",
		"sort" : "external/fugue-icons/sort-alphabet.png",
		"number" : "external/fugue-icons/edit-number.png",
		"layout" : "external/famfamfam-icons/page_white_stack.png",
		"group" : "external/famfamfam-icons/page_white_stack.png"
	};

	CSLEDIT_uiConfig.capitaliseFirstLetter = function (string) {
		return string.charAt(0).toUpperCase() + string.slice(1);
	};

	CSLEDIT_uiConfig.displayNameFromNode = function (node) {
		if (node.name in CSLEDIT_uiConfig.displayNames) {
			return CSLEDIT_uiConfig.displayNames[node.name](node);
		}

		// fall back to using the node name
		return CSLEDIT_uiConfig.capitaliseFirstLetter(node.name);
	};

	// generates display names for 'if' and 'else-if' tree view nodes
	//   e.g. If article OR book
	CSLEDIT_uiConfig.conditionalDisplayName = function (node) {
		var displayName = "",
			elideLimit = 30,
			match,
			terms = [],
			join = "";

		match = CSLEDIT_schema.attributes("choose/if").match.defaultValue;
		if (match === "") {
			match = "all"; // becuase it's not specified in MLZ schema, TODO: ask Frank
		}

		$.each(node.attributes, function (i, attribute) {
			if (attribute.enabled) {
				if (attribute.key === "match") {
					match = attribute.value;
				} else {
					$.each(attribute.value.split(" "), function (i, val) {
						terms.push(val);
					});
				}
			}
		});

		if (node.name === "if") {
			displayName = "If ";
		} else {
			displayName = "Else-If ";
		}

		if (match === "any") {
			displayName += terms.join(" OR ");
		} else if (match === "all") {
			displayName += terms.join(" AND ");
		} else if (match === "none") {
			displayName += "NOT (" + terms.join(" OR ") + ")";
		} else {
		debug.assert(false);
		}

		if (displayName.length > elideLimit) {
			displayName = displayName.substr(0, elideLimit - 3) + "...";
		}

		return displayName;
	};

	CSLEDIT_uiConfig.displayNames = {
		"macro" : function (node) {
			return "Macro: " + new CSLEDIT_CslNode(node).getAttr("name");
		},
		"text" : function (node) {
			var cslNode = new CSLEDIT_CslNode(node),
				macro = cslNode.getAttr("macro"),
				term = cslNode.getAttr("term"),
				value = cslNode.getAttr("value"),
				variable = cslNode.getAttr("variable");

			if (macro !== "") {
				return macro + " (macro)";
			} else if (term !== "") {
				return term + " (term)";
			} else if (value !== "") {
				return value + " (value)";
			} else if (variable !== "") {
				return variable + " (variable)";
			}
			return "Text";
		},
		"label" : function (node) {
			var variable = new CSLEDIT_CslNode(node).getAttr("variable"),
				displayName = "Label";

			if (variable !== "") {
				displayName = variable + " (label)";
			}
			return displayName;
		},
		"number" : function (node) {
			var variable = new CSLEDIT_CslNode(node).getAttr("variable");

			if (variable !== "") {
				return variable;
			}
			return "Number";
		},
		"if" : CSLEDIT_uiConfig.conditionalDisplayName,
		"else-if" : CSLEDIT_uiConfig.conditionalDisplayName,
		"citation" : function () {
			return "Inline Citations";
		},
		"bibliography" : function () {
			return "Bibliography";
		},
		"choose" : function () {
			return "Conditional";
		},
		"style" : function () {
			return "Global Formatting Options";
		},
		"key" : function (node) {
			var variable = new CSLEDIT_CslNode(node).getAttr("variable"),
				macro = new CSLEDIT_CslNode(node).getAttr("macro");

			if (macro !== "") {
				return "Sort by " + macro;
			} else if (variable !== "") {
				return "Sort by " + variable;
			}

			return "Sort key";
		}
	};
	return CSLEDIT_uiConfig;
});



/* Iterates through a tree in depth first order
 *
 * Each node of the tree must contain a children array containing it's child nodes
 * 
 * Can retrieve the parent node of each child in the tree
 */
define('src/Iterator',['src/debug'], function (debug) {
	var CSLEDIT_Iterator = function (rootNode) {
		debug.assert(this instanceof CSLEDIT_Iterator);

		this.rootNode = rootNode;
		this.nodeStack = [];
		this.finished = false;
		this.nextNode = null;
	};

	CSLEDIT_Iterator.prototype.next = function () {
		var topNode,
			nextNode,
			currentNode;

		nextNode = this.nextNode;
		this.nextNode = null;

		// used to implement hasNext
		if (nextNode !== null) {
			return nextNode;
		}

		if (this.finished) {
			return null;
		}

		if (this.nodeStack.length === 0) {
			// start
			this.nodeStack.push({ node : this.rootNode, childIndex : -1 });
			return this.nodeStack[0].node;
		}

		topNode = this.nodeStack[this.nodeStack.length - 1];
		topNode.childIndex++;

		if (topNode.childIndex < topNode.node.children.length) {
			nextNode = topNode.node.children[topNode.childIndex];
			this.nodeStack.push({ node : nextNode, childIndex : -1 });
			return nextNode;
		} else {
			this.nodeStack.pop();
			if (this.nodeStack.length === 0) {
				this.finished = true;
			}
			return this.next();
		}
	};

	CSLEDIT_Iterator.prototype.hasNext = function () {
		if (this.nextNode !== null) {
			return true;
		} else {
			if (this.finished) {
				return false;
			} else {
				this.nextNode = this.next();
				return this.nextNode !== null;
			}
		}
	};

	CSLEDIT_Iterator.prototype.parent = function () {
		if (this.nodeStack.length > 1) {
			return this.nodeStack[this.nodeStack.length - 2].node;
		} else {
			return null;
		}
	};

	CSLEDIT_Iterator.prototype.stack = function () {
		var stack = [];

		$.each(this.nodeStack, function(i, node) {
			stack.push(node.node);
		});
		
		return stack;
	};

	return CSLEDIT_Iterator;
});



define('src/cslParser',['src/debug'], function (debug) {
	// Private functions:
	var jsonNodeFromXml = function (node, nodeIndex) {
		var children = [],
			index,
			jsonData,
			childNode,
			textValue,
			TEXT_NODE,
			thisNodeIndex = nodeIndex.index;

		TEXT_NODE = 3;
		
		for (index = 0; index < node.childNodes.length; index++) {
			childNode = node.childNodes[index];

			if (childNode.localName !== null) {
				nodeIndex.index++;
				children.push(jsonNodeFromXml(node.childNodes[index], nodeIndex));
			} else {
				if (childNode.nodeType === TEXT_NODE && typeof childNode.data !== "undefined" && 
						childNode.data.trim() !== "") {
					textValue = childNode.data;
				}
			}
		}

	debug.assert(typeof textValue === "undefined" || children.length === 0, "textValue = " + textValue + " children.length = " + children.length);

		var attributesString = "";
		var attributesStringList = [];
		var attributesList = [];
		var thisNodeData;
		
		if (node.attributes !== null && node.attributes.length > 0) {
			for (index = 0; index < node.attributes.length; index++) {
				attributesList.push(
					{
						key : node.attributes.item(index).localName,
						value : node.attributes.item(index).nodeValue,
						enabled : true
					});
				attributesStringList.push(
					node.attributes.item(index).localName + '="' +
					node.attributes.item(index).nodeValue + '"');
			}
			attributesString = ": " + attributesStringList.join(", ");
		}

		thisNodeData = {
				name : node.localName,
				attributes : attributesList,
				cslId : thisNodeIndex,
				children : children
			};

		if (typeof textValue !== "undefined") {
			thisNodeData.textValue = textValue;
		}

		return thisNodeData;
	};

	var htmlEscape = function (text) {
		var escaped = text;

		escaped = escaped.replace(/&/g, "&amp;");
		escaped = escaped.replace(/</g, "&lt;");
		escaped = escaped.replace(/>/g, "&gt;");
		escaped = escaped.replace(/"/g, "&quot;");

		return escaped;
	};

	var generateIndent = function (indentAmount) {
		var index,
			result = "";
		for (index = 0; index < indentAmount; index++) {
			result += "  ";
		}
		return result;
	};

	var xmlNodeFromJson = function (jsonData, indent, fullClosingTags) {
		var attributesString = "",
			xmlString,
			index,
			innerString;

		if (jsonData.attributes.length > 0) {
			for (index = 0; index < jsonData.attributes.length; index++) {
				if (jsonData.attributes[index].enabled) {
					// TODO: the key probably shouldn't have characters needing escaping anyway,
					//       should not allow to input them in the first place
					attributesString += " " + 
						htmlEscape(jsonData.attributes[index].key) + '="' + 
						htmlEscape(jsonData.attributes[index].value) + '"';
				}
			}
		}
		xmlString = generateIndent(indent);

		if (typeof jsonData.textValue !== "undefined") {
			xmlString += "<" + jsonData.name + attributesString + ">";
			xmlString += htmlEscape(jsonData.textValue) + "</" + htmlEscape(jsonData.name) + ">\n";
		} else {
			xmlString += "<" + jsonData.name + attributesString;
			innerString = "";
			if (typeof jsonData.children !== "undefined" && jsonData.children.length > 0) {
				for (index = 0; index < jsonData.children.length; index++) {
					innerString += xmlNodeFromJson(jsonData.children[index], indent + 1, fullClosingTags);
				}
			}
			if (innerString !== "") {
				xmlString += ">\n" + innerString + generateIndent(indent) + "</" + htmlEscape(jsonData.name) + ">\n";
			} else if (fullClosingTags) {
				xmlString += "></" + jsonData.name + ">\n";
			} else {
				xmlString += "/>\n";
			}
		}

		return xmlString;
	};
	
	var updateCslIds = function (jsonData, cslId) {
		var childIndex;

		jsonData.metadata["cslId"] = cslId.index;
		cslId.index++;
		if (jsonData.children) {
			for (childIndex = 0; childIndex < jsonData.children.length; childIndex++)
			{
				updateCslIds(jsonData.children[childIndex], cslId);
			}
		}
	};

	// public:
	return {
		isCslValid : function (xmlData) {
			var parser = new DOMParser();
			var xmlDoc = parser.parseFromString(xmlData, "application/xml");

			var styleNode = xmlDoc.childNodes[0];
			return styleNode.localName === "style";
		},

		// nodeIndex.index is the depth-first traversal position of CSL node
		// it must start at 0, and it will be returned with nodeIndex.index = number of nodes - 1
		cslDataFromCslCode : function (xmlData) {
			var parser = new DOMParser(),
				xmlDoc = parser.parseFromString(xmlData, "application/xml"),
				errors;
			errors = xmlDoc.getElementsByTagName('parsererror');
		debug.assertEqual(errors.length, 0, "xml parser error");

			var styleNode = xmlDoc.childNodes[0];
		debug.assertEqual(styleNode.localName, "style", "Invalid style - no style node");

			var jsonData = jsonNodeFromXml(styleNode, { index: 0 });
		
			return jsonData;
		},

		cslCodeFromCslData : function (jsonData, comment /* optional */, fullClosingTags /* optional */) {
			var cslXml = '<?xml version="1.0" encoding="utf-8"?>\n',
				lines,
				lineIndex;
			
			cslXml += xmlNodeFromJson(jsonData, 0, fullClosingTags);

			if (typeof(comment) === "string") {
				lines = cslXml.split("\n");

				// comment needs to go on line no. 3, after the style node
				lines.splice(2, 0, "<!-- " + comment + " -->");

				cslXml = lines.join("\n");
			}
			
			return cslXml;
		},

		updateCslIds : updateCslIds
	};
});



define('src/storage',['src/debug'], function (debug) {
	var CSLEDIT_Storage = function (useLocalStorageIfAvailable) {
		// Use localStorage for persistance if available, otherwise use a simple
		// session based dictionary
		var simpleStorage = {},
			simpleStorageAPI,
			localStorageAPI,
			finalAPI,
			outOfSyncCallback;

		var outOfSync = function () {
			debug.log("CSLEDIT_storage out of sync with local storage");
			if (typeof(outOfSyncCallback) === "function") {
				outOfSyncCallback();
			}
		};

		simpleStorageAPI = {
			getItem : function (key) {
				if (simpleStorage.hasOwnProperty(key)) {
					return simpleStorage[key];
				} else {
					return null;
				}
			},
			setItem : function (key, value) {
				simpleStorage[key] = value;
			},
			removeItem : function (key) {
				delete simpleStorage[key];
			},
			clear : function () {
				simpleStorage = {};
			}
		};

		localStorageAPI = {
			getItem : function (key) {
				return localStorage.getItem(key);
			},
			setItem : function (key, value) {
				localStorage.setItem(key, value);
			},
			removeItem : function (key) {
				localStorage.removeItem(key);
			},
			clear : function () {
				localStorage.clear();
			}
		};

		if (typeof(localStorage) === "undefined" || localStorage === null ||
				useLocalStorageIfAvailable !== true) {
			debug.log("Not using localStorage");
			finalAPI = simpleStorageAPI;
		} else {
			// use local storage, with simple storage to verify that nothing has changed
			finalAPI = {
				getItem : function (key) {
					var simpleValue,
						localValue;
					
					simpleValue = simpleStorageAPI.getItem(key);
					localValue = localStorageAPI.getItem(key);

					if (simpleValue !== null && simpleValue !== localValue) {
						outOfSync();
					}

					return localValue;
				},
				setItem : function (key, value) {
					simpleStorageAPI.setItem(key, value);
					localStorageAPI.setItem(key, value);
				},
				removeItem : function (key) {
					simpleStorageAPI.removeItem(key);
					localStorageAPI.removeItem(key);
				},
				clear : function () {
					simpleStorageAPI.clear();
					localStorageAPI.clear();
				},
				recreateLocalStorage : function (key) {
					localStorageAPI.clear();
					$.each(simpleStorage, function (key, value) {
						localStorageAPI.setItem(key, value);
					});
				}
			};
		}
		
		finalAPI.getItemJson = function (key) {
			var data = finalAPI.getItem(key);
			if (data === null) {
				return null;
			} else {
				return JSON.parse(data);
			}
		};

		finalAPI.onDataInconsistency = function (callback) {
			outOfSyncCallback = callback;
		};

		return finalAPI;
	};

	var CSLEDIT_storage = new CSLEDIT_Storage(true);

	return CSLEDIT_storage;
});



define('src/exampleData',[],function () {
	var CSLEDIT_exampleData = {};

	CSLEDIT_exampleData.topStyles = [
		'http://www.zotero.org/styles/apa',
		'http://www.zotero.org/styles/ieee',
		'http://www.zotero.org/styles/harvard1',
		'http://www.zotero.org/styles/nature',
		'http://www.zotero.org/styles/american-medical-association', /* manually updated from styles/ama */
		'http://www.zotero.org/styles/chicago-author-date',
		'http://www.zotero.org/styles/apsa',
		'http://www.zotero.org/styles/vancouver',
		'http://www.zotero.org/styles/asa',
		'http://www.zotero.org/styles/mla',
		'http://www.zotero.org/styles/mhra',
		'http://www.zotero.org/styles/chicago-fullnote-bibliography',
		'http://www.zotero.org/styles/associacao-brasileira-de-normas-tecnicas', /* manually updated from styles/abnt */
		'http://www.zotero.org/styles/chicago-note-bibliography',
		'http://www.zotero.org/styles/national-library-of-medicine', /* manually updated from styles/nlm */
		'http://www.zotero.org/styles/american-chemical-society',
		'http://www.zotero.org/styles/cell',
		'http://www.zotero.org/styles/science',
		'http://www.zotero.org/styles/elsevier-with-titles',
		'http://www.zotero.org/styles/ecology',
		'http://www.zotero.org/styles/elsevier-harvard',
		'http://www.zotero.org/styles/royal-society-of-chemistry',
		'http://www.zotero.org/styles/journal-of-the-american-chemical-society',
		'http://www.zotero.org/styles/pnas'
	];

	CSLEDIT_exampleData.citationsItems = [
		{
			"citationId": "CITATION-1",
			"citationItems": [{id:"ITEM-1"}],
			"properties": {
				"noteIndex": 0
			},
			"schema": "https://github.com/citation-style-language/schema/raw/master/csl-citation.json"
		},
		{
			"citationId": "CITATION-2",
			"citationItems": [{id:"ITEM-12"}],
			"properties": {
				"noteIndex": 0
			},
			"schema": "https://github.com/citation-style-language/schema/raw/master/csl-citation.json"
		}
	];

	CSLEDIT_exampleData.additionalOptions = [
		{
			"description" : "Normal citation",
			"options" : {}
		},
		{
			"description" : "Locator: Pages 244-255",
			"options" : {
				"locator" : "244-252",
				"label" : "page"
			}
		},
		{
			"description" : "Locator: Chapter 5",
			"options" : {
				"locator" : "5",
				"label" : "chapter"
			}
		},
		{
			"description" : "Author only",
			"options" : {
				"author-only" : true
			}
		},
		{
			"description" : "Suppress author",
			"options" : {
				"suppress-author" : true
			}
		}
	];

	CSLEDIT_exampleData.getJsonDocuments = function () {
		var jsonDocuments = {};

		$.each(CSLEDIT_exampleData.jsonDocumentList, function (i, jsonDocument) {
			var itemString = "ITEM-" + (i + 1);
			jsonDocument.id = itemString;
			jsonDocuments[itemString] = jsonDocument;
		});

		return jsonDocuments;
	};

	CSLEDIT_exampleData.jsonDocumentList = [
		{
			"ISBN": "0813931029",
			"abstract": "Traditional narratives imply that art in early America was severely limited in scope. By contrast, these essays collectively argue that visual arts played a critical role in shaping an early American understanding of the body politic. American artists in the late colonial and early national periods enlisted the arts to explore and exploit their visions of the relationship of the American colonies to the mother country and, later, to give material shape to the ideals of modern republican nationhood. Taking a uniquely broad view of both politics and art, Shaping the Body Politic ranges in topic from national politics to the politics of national identity, and from presidential portraits to the architectures of the ordinary. The book covers subject matter from the 1760s to the 1820s, ranging from Patience Wright's embodiment of late colonial political tension to Thomas Jefferson's designs for the entry hall at Monticello as a museum. Paul Staiti, Maurie McInnis, and Roger Stein offer new readings of canonical presidential images and spaces: Jean-Antoine Houdon's George Washington, Gilbert Stuart's the Lansdowne portrait of Washington, and Thomas Jefferson's Monticello. In essays that engage print and painting, portraiture and landscape, Wendy Bellion, David Steinberg, and John Crowley explore the formation of national identity. The volume's concluding essays, by Susan Rather and Bernard Herman, examine the politics of the everyday. The accompanying eighty-five illustrations and color plates demonstrate the broad range of politically resonant visual material in early America. ContributorsWendy Bellion, University of Delaware * John E. Crowley, Dalhousie University * Bernard L. Herman, University of North Carolina, Chapel Hill * Maurie D. McInnis, University of Virginia * Louis P. Nelson, University of Virginia * Susan Rather, University of Texas, Austin * Paul Staiti, Mount Holyoke College * Roger B. Stein, emeritus, University of Virginia * David Steinberg, Independent Scholar Thomas Jefferson Foundation Distinguished Lecture Series",
			"author": [{
				"family": "McInnis",
				"given": "Maurie D."
			}, {
				"family": "Nelson",
				"given": "Louis P."
			}],
			"issued": {
				"date-parts": [
					["2011"]
				]
			},
			"page": "313",
			"publisher": "University of Virginia Press",
			"title": "Shaping the Body Politic: Art and Political Formation in Early America",
			"type": "book"
		},
		{
			"ISBN": "0881929115",
			"abstract": "The latest techniques for planting roofs and walls to enhance our buildings and benefit the environment. The green roof industry is booming and the technology changing fast as professionals respond to the unique challenges of each new planting. In this comprehensively updated, fully revised edition of their authoritative reference, Nigel Dunnett and Nol Kingsbury reveal the very latest techniques, materials, and plants, and showcase some spectacular new case studies for the non-professional. Green roofs and walls reduce pollution and runoff, help insulate and reduce the maintenance needs of buildings, contribute to biodiversity, and provide habitats for wildlife. In addition to all this, they are attractive to look at and enhance the quality of life of residents. In Planting Green Roofs and Living Walls, Revised and Updated Edition, the authors describe and illustrate the practical techniques required to design, implement, and maintain a green roof or wall to the highest standards. This informative, up-to-the-minute reference will encourage gardeners everywhere to consider the enormous benefits to be gained from planting on their roofs and walls.",
			"author": [{
				"family": "Dunnett",
				"given": "Nigel"
			}, {
				"family": "Kingsbury",
				"given": "No\u00ebl"
			}],
			"issued": {
				"date-parts": [
					["2008"]
				]
			},
			"page": "328",
			"publisher": "Timber Press",
			"title": "Planting green roofs and living walls",
			"type": "book"
		},
		{
			"author": [{
				"family": "Foderaro",
				"given": "Lisa W."
			}],
			"container-title": "New York Times",
			"issued": {
				"date-parts": [
					["2012", "4", "6"]
				]
			},
			"note": "<m:note>the developer bright farms says that, at up to 100,000 square feet, the greenhouse in sunset park will be the nation\u00e2\u0080\u0099s largest.</m:note>",
			"page": "A20",
			"publisher-place": "New York",
			"title": "Rooftop Greenhouse Will Boost City Farming - NYTimes.com",
			"type": "article-newspaper"
		},
		{
			"DOI": "10.1088/1748-0221/7/03/P03012",
			"abstract": "This paper presents a complete description of Virgo, the French-Italian gravitational wave detector.\n The detector, built at Cascina, near Pisa (Italy), is a very large Michelson interferometer, with 3\n km-long arms. In this paper, following a presentation of the physics requirements, leading to the\n specifications for the construction of the detector, a detailed description of all its different\n elements is given. These include civil engineering infrastructures, a huge ultra-high vacuum (UHV)\n chamber (about 6000 cubic metres), all of the optical components, including high quality mirrors and\n their seismic isolating suspensions, all of the electronics required to control the interferometer\n and for signal detection. The expected performances of these different elements are given, leading\n to an overall sensitivity curve as a function of the incoming gravitational wave frequency. This\n description represents the detector as built and used in the first data-taking runs. Improvements in\n different parts have been and continue to be performed, leading to better sensitivities. These will\n be detailed in a forthcoming paper.",
			"author": [{
				"family": "Accadia",
				"given": "T"
			}, {
				"family": "Acernese",
				"given": "F"
			}, {
				"family": "Alshourbagy",
				"given": "M"
			}, {
				"family": "Amico",
				"given": "P"
			}, {
				"family": "Antonucci",
				"given": "F"
			}, {
				"family": "Aoudia",
				"given": "S"
			}, {
				"family": "Arnaud",
				"given": "N"
			}, {
				"family": "Arnault",
				"given": "C"
			}, {
				"family": "Arun",
				"given": "K G"
			}, {
				"family": "Astone",
				"given": "P"
			}, {
				"family": "Avino",
				"given": "S"
			}, {
				"family": "Babusci",
				"given": "D"
			}, {
				"family": "Ballardin",
				"given": "G"
			}, {
				"family": "Barone",
				"given": "F"
			}, {
				"family": "Barrand",
				"given": "G"
			}, {
				"family": "Barsotti",
				"given": "L"
			}, {
				"family": "Barsuglia",
				"given": "M"
			}, {
				"family": "Basti",
				"given": "A"
			}, {
				"family": "Bauer",
				"given": "Th S"
			}, {
				"family": "Beauville",
				"given": "F"
			}, {
				"family": "Bebronne",
				"given": "M"
			}, {
				"family": "Bejger",
				"given": "M"
			}, {
				"family": "Beker",
				"given": "M G"
			}, {
				"family": "Bellachia",
				"given": "F"
			}, {
				"family": "Belletoile",
				"given": "A"
			}, {
				"family": "Beney",
				"given": "J L"
			}, {
				"family": "Bernardini",
				"given": "M"
			}, {
				"family": "Bigotta",
				"given": "S"
			}, {
				"family": "Bilhaut",
				"given": "R"
			}, {
				"family": "Birindelli",
				"given": "S"
			}, {
				"family": "Bitossi",
				"given": "M"
			}, {
				"family": "Bizouard",
				"given": "M A"
			}, {
				"family": "Blom",
				"given": "M"
			}, {
				"family": "Boccara",
				"given": "C"
			}, {
				"family": "Boget",
				"given": "D"
			}, {
				"family": "Bondu",
				"given": "F"
			}, {
				"family": "Bonelli",
				"given": "L"
			}, {
				"family": "Bonnand",
				"given": "R"
			}, {
				"family": "Boschi",
				"given": "V"
			}, {
				"family": "Bosi",
				"given": "L"
			}, {
				"family": "Bouedo",
				"given": "T"
			}, {
				"family": "Bouhou",
				"given": "B"
			}, {
				"family": "Bozzi",
				"given": "A"
			}, {
				"family": "Bracci",
				"given": "L"
			}, {
				"family": "Braccini",
				"given": "S"
			}, {
				"family": "Bradaschia",
				"given": "C"
			}, {
				"family": "Branchesi",
				"given": "M"
			}, {
				"family": "Briant",
				"given": "T"
			}, {
				"family": "Brillet",
				"given": "A"
			}, {
				"family": "Brisson",
				"given": "V"
			}, {
				"family": "Brocco",
				"given": "L"
			}, {
				"family": "Bulik",
				"given": "T"
			}, {
				"family": "Bulten",
				"given": "H J"
			}, {
				"family": "Buskulic",
				"given": "D"
			}, {
				"family": "Buy",
				"given": "C"
			}, {
				"family": "Cagnoli",
				"given": "G"
			}, {
				"family": "Calamai",
				"given": "G"
			}, {
				"family": "Calloni",
				"given": "E"
			}, {
				"family": "Campagna",
				"given": "E"
			}, {
				"family": "Canuel",
				"given": "B"
			}, {
				"family": "Carbognani",
				"given": "F"
			}, {
				"family": "Carbone",
				"given": "L"
			}, {
				"family": "Cavalier",
				"given": "F"
			}, {
				"family": "Cavalieri",
				"given": "R"
			}, {
				"family": "Cecchi",
				"given": "R"
			}, {
				"family": "Cella",
				"given": "G"
			}, {
				"family": "Cesarini",
				"given": "E"
			}, {
				"family": "Chassande-Mottin",
				"given": "E"
			}, {
				"family": "Chatterji",
				"given": "S"
			}, {
				"family": "Chiche",
				"given": "R"
			}, {
				"family": "Chincarini",
				"given": "A"
			}, {
				"family": "Chiummo",
				"given": "A"
			}, {
				"family": "Christensen",
				"given": "N"
			}, {
				"family": "Clapson",
				"given": "A C"
			}, {
				"family": "Cleva",
				"given": "F"
			}, {
				"family": "Coccia",
				"given": "E"
			}, {
				"family": "Cohadon",
				"given": "P -F"
			}, {
				"family": "Colacino",
				"given": "C N"
			}, {
				"family": "Colas",
				"given": "J"
			}, {
				"family": "Colla",
				"given": "A"
			}, {
				"family": "Colombini",
				"given": "M"
			}, {
				"family": "Conforto",
				"given": "G"
			}, {
				"family": "Corsi",
				"given": "A"
			}, {
				"family": "Cortese",
				"given": "S"
			}, {
				"family": "Cottone",
				"given": "F"
			}, {
				"family": "Coulon",
				"given": "J -P"
			}, {
				"family": "Cuoco",
				"given": "E"
			}, {
				"family": "D'Antonio",
				"given": "S"
			}, {
				"family": "Daguin",
				"given": "G"
			}, {
				"family": "Dari",
				"given": "A"
			}, {
				"family": "Dattilo",
				"given": "V"
			}, {
				"family": "David",
				"given": "P Y"
			}, {
				"family": "Davier",
				"given": "M"
			}, {
				"family": "Day",
				"given": "R"
			}, {
				"family": "Debreczeni",
				"given": "G"
			}, {
				"family": "Carolis",
				"given": "G De"
			}, {
				"family": "Dehamme",
				"given": "M"
			}, {
				"family": "Fabbro",
				"given": "R Del"
			}, {
				"family": "Pozzo",
				"given": "W Del"
			}, {
				"family": "Prete",
				"given": "M del"
			}, {
				"family": "Derome",
				"given": "L"
			}, {
				"family": "Rosa",
				"given": "R De"
			}, {
				"family": "DeSalvo",
				"given": "R"
			}, {
				"family": "Dialinas",
				"given": "M"
			}, {
				"family": "Fiore",
				"given": "L Di"
			}, {
				"family": "Lieto",
				"given": "A Di"
			}, {
				"family": "Emilio",
				"given": "M Di Paolo"
			}, {
				"family": "Virgilio",
				"given": "A Di"
			}, {
				"family": "Dietz",
				"given": "A"
			}, {
				"family": "Doets",
				"given": "M"
			}, {
				"family": "Dominici",
				"given": "P"
			}, {
				"family": "Dominjon",
				"given": "A"
			}, {
				"family": "Drago",
				"given": "M"
			}, {
				"family": "Drezen",
				"given": "C"
			}, {
				"family": "Dujardin",
				"given": "B"
			}, {
				"family": "Dulach",
				"given": "B"
			}, {
				"family": "Eder",
				"given": "C"
			}, {
				"family": "Eleuteri",
				"given": "A"
			}, {
				"family": "Enard",
				"given": "D"
			}, {
				"family": "Evans",
				"given": "M"
			}, {
				"family": "Fabbroni",
				"given": "L"
			}, {
				"family": "Fafone",
				"given": "V"
			}, {
				"family": "Fang",
				"given": "H"
			}, {
				"family": "Ferrante",
				"given": "I"
			}, {
				"family": "Fidecaro",
				"given": "F"
			}, {
				"family": "Fiori",
				"given": "I"
			}, {
				"family": "Flaminio",
				"given": "R"
			}, {
				"family": "Forest",
				"given": "D"
			}, {
				"family": "Forte",
				"given": "L A"
			}, {
				"family": "Fournier",
				"given": "J -D"
			}, {
				"family": "Fournier",
				"given": "L"
			}, {
				"family": "Franc",
				"given": "J"
			}, {
				"family": "Francois",
				"given": "O"
			}, {
				"family": "Frasca",
				"given": "S"
			}, {
				"family": "Frasconi",
				"given": "F"
			}, {
				"family": "Freise",
				"given": "A"
			}, {
				"family": "Gaddi",
				"given": "A"
			}, {
				"family": "Galimberti",
				"given": "M"
			}, {
				"family": "Gammaitoni",
				"given": "L"
			}, {
				"family": "Ganau",
				"given": "P"
			}, {
				"family": "Garnier",
				"given": "C"
			}, {
				"family": "Garufi",
				"given": "F"
			}, {
				"family": "G\u00e1sp\u00e1r",
				"given": "M E"
			}, {
				"family": "Gemme",
				"given": "G"
			}, {
				"family": "Genin",
				"given": "E"
			}, {
				"family": "Gennai",
				"given": "A"
			}, {
				"family": "Gennaro",
				"given": "G"
			}, {
				"family": "Giacobone",
				"given": "L"
			}, {
				"family": "Giazotto",
				"given": "A"
			}, {
				"family": "Giordano",
				"given": "G"
			}, {
				"family": "Giordano",
				"given": "L"
			}, {
				"family": "Girard",
				"given": "C"
			}, {
				"family": "Gouaty",
				"given": "R"
			}, {
				"family": "Grado",
				"given": "A"
			}, {
				"family": "Granata",
				"given": "M"
			}, {
				"family": "Granata",
				"given": "V"
			}, {
				"family": "Grave",
				"given": "X"
			}, {
				"family": "Greverie",
				"given": "C"
			}, {
				"family": "Groenstege",
				"given": "H"
			}, {
				"family": "Guidi",
				"given": "G M"
			}, {
				"family": "Hamdani",
				"given": "S"
			}, {
				"family": "Hayau",
				"given": "J -F"
			}, {
				"family": "Hebri",
				"given": "S"
			}, {
				"family": "Heidmann",
				"given": "A"
			}, {
				"family": "Heitmann",
				"given": "H"
			}, {
				"family": "Hello",
				"given": "P"
			}, {
				"family": "Hemming",
				"given": "G"
			}, {
				"family": "Hennes",
				"given": "E"
			}, {
				"family": "Hermel",
				"given": "R"
			}, {
				"family": "Heusse",
				"given": "P"
			}, {
				"family": "Holloway",
				"given": "L"
			}, {
				"family": "Huet",
				"given": "D"
			}, {
				"family": "Iannarelli",
				"given": "M"
			}, {
				"family": "Jaranowski",
				"given": "P"
			}, {
				"family": "Jehanno",
				"given": "D"
			}, {
				"family": "Journet",
				"given": "L"
			}, {
				"family": "Karkar",
				"given": "S"
			}, {
				"family": "Ketel",
				"given": "T"
			}, {
				"family": "Voet",
				"given": "H"
			}, {
				"family": "Kovalik",
				"given": "J"
			}, {
				"family": "Kowalska",
				"given": "I"
			}, {
				"family": "Kreckelbergh",
				"given": "S"
			}, {
				"family": "Krolak",
				"given": "A"
			}, {
				"family": "Lacotte",
				"given": "J C"
			}, {
				"family": "Lagrange",
				"given": "B"
			}, {
				"family": "Penna",
				"given": "P La"
			}, {
				"family": "Laval",
				"given": "M"
			}, {
				"family": "Marec",
				"given": "J C Le"
			}, {
				"family": "Leroy",
				"given": "N"
			}, {
				"family": "Letendre",
				"given": "N"
			}, {
				"family": "Li",
				"given": "T G F"
			}, {
				"family": "Lieunard",
				"given": "B"
			}, {
				"family": "Liguori",
				"given": "N"
			}, {
				"family": "Lodygensky",
				"given": "O"
			}, {
				"family": "Lopez",
				"given": "B"
			}, {
				"family": "Lorenzini",
				"given": "M"
			}, {
				"family": "Loriette",
				"given": "V"
			}, {
				"family": "Losurdo",
				"given": "G"
			}, {
				"family": "Loupias",
				"given": "M"
			}, {
				"family": "Mackowski",
				"given": "J M"
			}, {
				"family": "Maiani",
				"given": "T"
			}, {
				"family": "Majorana",
				"given": "E"
			}, {
				"family": "Magazz\u00f9",
				"given": "C"
			}, {
				"family": "Maksimovic",
				"given": "I"
			}, {
				"family": "Malvezzi",
				"given": "V"
			}, {
				"family": "Man",
				"given": "N"
			}, {
				"family": "Mancini",
				"given": "S"
			}, {
				"family": "Mansoux",
				"given": "B"
			}, {
				"family": "Mantovani",
				"given": "M"
			}, {
				"family": "Marchesoni",
				"given": "F"
			}, {
				"family": "Marion",
				"given": "F"
			}, {
				"family": "Marin",
				"given": "P"
			}, {
				"family": "Marque",
				"given": "J"
			}, {
				"family": "Martelli",
				"given": "F"
			}, {
				"family": "Masserot",
				"given": "A"
			}, {
				"family": "Massonnet",
				"given": "L"
			}, {
				"family": "Matone",
				"given": "G"
			}, {
				"family": "Matone",
				"given": "L"
			}, {
				"family": "Mazzoni",
				"given": "M"
			}, {
				"family": "Menzinger",
				"given": "F"
			}, {
				"family": "Michel",
				"given": "C"
			}, {
				"family": "Milano",
				"given": "L"
			}, {
				"family": "Minenkov",
				"given": "Y"
			}, {
				"family": "Mitra",
				"given": "S"
			}, {
				"family": "Mohan",
				"given": "M"
			}, {
				"family": "Montorio",
				"given": "J -L"
			}, {
				"family": "Morand",
				"given": "R"
			}, {
				"family": "Moreau",
				"given": "F"
			}, {
				"family": "Moreau",
				"given": "J"
			}, {
				"family": "Morgado",
				"given": "N"
			}, {
				"family": "Morgia",
				"given": "A"
			}, {
				"family": "Mosca",
				"given": "S"
			}, {
				"family": "Moscatelli",
				"given": "V"
			}, {
				"family": "Mours",
				"given": "B"
			}, {
				"family": "Mugnier",
				"given": "P"
			}, {
				"family": "Mul",
				"given": "F -A"
			}, {
				"family": "Naticchioni",
				"given": "L"
			}, {
				"family": "Neri",
				"given": "I"
			}, {
				"family": "Nocera",
				"given": "F"
			}, {
				"family": "Pacaud",
				"given": "E"
			}, {
				"family": "Pagliaroli",
				"given": "G"
			}, {
				"family": "Pai",
				"given": "A"
			}, {
				"family": "Palladino",
				"given": "L"
			}, {
				"family": "Palomba",
				"given": "C"
			}, {
				"family": "Paoletti",
				"given": "F"
			}, {
				"family": "Paoletti",
				"given": "R"
			}, {
				"family": "Paoli",
				"given": "A"
			}, {
				"family": "Pardi",
				"given": "S"
			}, {
				"family": "Parguez",
				"given": "G"
			}, {
				"family": "Parisi",
				"given": "M"
			}, {
				"family": "Pasqualetti",
				"given": "A"
			}, {
				"family": "Passaquieti",
				"given": "R"
			}, {
				"family": "Passuello",
				"given": "D"
			}, {
				"family": "Perciballi",
				"given": "M"
			}, {
				"family": "Perniola",
				"given": "B"
			}, {
				"family": "Persichetti",
				"given": "G"
			}, {
				"family": "Petit",
				"given": "S"
			}, {
				"family": "Pichot",
				"given": "M"
			}, {
				"family": "Piergiovanni",
				"given": "F"
			}, {
				"family": "Pietka",
				"given": "M"
			}, {
				"family": "Pignard",
				"given": "R"
			}, {
				"family": "Pinard",
				"given": "L"
			}, {
				"family": "Poggiani",
				"given": "R"
			}, {
				"family": "Popolizio",
				"given": "P"
			}, {
				"family": "Pradier",
				"given": "T"
			}, {
				"family": "Prato",
				"given": "M"
			}, {
				"family": "Prodi",
				"given": "G A"
			}, {
				"family": "Punturo",
				"given": "M"
			}, {
				"family": "Puppo",
				"given": "P"
			}, {
				"family": "Qipiani",
				"given": "K"
			}, {
				"family": "Rabaste",
				"given": "O"
			}, {
				"family": "Rabeling",
				"given": "D S"
			}, {
				"family": "R\u00e1cz",
				"given": "I"
			}, {
				"family": "Raffaelli",
				"given": "F"
			}, {
				"family": "Rapagnani",
				"given": "P"
			}, {
				"family": "Rapisarda",
				"given": "S"
			}, {
				"family": "Re",
				"given": "V"
			}, {
				"family": "Reboux",
				"given": "A"
			}, {
				"family": "Regimbau",
				"given": "T"
			}, {
				"family": "Reita",
				"given": "V"
			}, {
				"family": "Remilleux",
				"given": "A"
			}, {
				"family": "Ricci",
				"given": "F"
			}, {
				"family": "Ricciardi",
				"given": "I"
			}, {
				"family": "Richard",
				"given": "F"
			}, {
				"family": "Ripepe",
				"given": "M"
			}, {
				"family": "Robinet",
				"given": "F"
			}, {
				"family": "Rocchi",
				"given": "A"
			}, {
				"family": "Rolland",
				"given": "L"
			}, {
				"family": "Romano",
				"given": "R"
			}, {
				"family": "Rosi\u0144ska",
				"given": "D"
			}, {
				"family": "Roudier",
				"given": "P"
			}, {
				"family": "Ruggi",
				"given": "P"
			}, {
				"family": "Russo",
				"given": "G"
			}, {
				"family": "Salconi",
				"given": "L"
			}, {
				"family": "Sannibale",
				"given": "V"
			}, {
				"family": "Sassolas",
				"given": "B"
			}, {
				"family": "Sentenac",
				"given": "D"
			}, {
				"family": "Solimeno",
				"given": "S"
			}, {
				"family": "Sottile",
				"given": "R"
			}, {
				"family": "Sperandio",
				"given": "L"
			}, {
				"family": "Stanga",
				"given": "R"
			}, {
				"family": "Sturani",
				"given": "R"
			}, {
				"family": "Swinkels",
				"given": "B"
			}, {
				"family": "Tacca",
				"given": "M"
			}, {
				"family": "Taddei",
				"given": "R"
			}, {
				"family": "Taffarello",
				"given": "L"
			}, {
				"family": "Tarallo",
				"given": "M"
			}, {
				"family": "Tissot",
				"given": "S"
			}, {
				"family": "Toncelli",
				"given": "A"
			}, {
				"family": "Tonelli",
				"given": "M"
			}, {
				"family": "Torre",
				"given": "O"
			}, {
				"family": "Tournefier",
				"given": "E"
			}, {
				"family": "Travasso",
				"given": "F"
			}, {
				"family": "Tremola",
				"given": "C"
			}, {
				"family": "Turri",
				"given": "E"
			}, {
				"family": "Vajente",
				"given": "G"
			}, {
				"family": "Brand",
				"given": "J F J van den"
			}, {
				"family": "Broeck",
				"given": "C Van Den"
			}, {
				"family": "Putten",
				"given": "S van der"
			}, {
				"family": "Vasuth",
				"given": "M"
			}, {
				"family": "Vavoulidis",
				"given": "M"
			}, {
				"family": "Vedovato",
				"given": "G"
			}, {
				"family": "Verkindt",
				"given": "D"
			}, {
				"family": "Vetrano",
				"given": "F"
			}, {
				"family": "V\u00e9ziant",
				"given": "O"
			}, {
				"family": "Vicer\u00e9",
				"given": "A"
			}, {
				"family": "Vinet",
				"given": "J -Y"
			}, {
				"family": "Vilalte",
				"given": "S"
			}, {
				"family": "Vitale",
				"given": "S"
			}, {
				"family": "Vocca",
				"given": "H"
			}, {
				"family": "Ward",
				"given": "R L"
			}, {
				"family": "Was",
				"given": "M"
			}, {
				"family": "Yamamoto",
				"given": "K"
			}, {
				"family": "Yvert",
				"given": "M"
			}, {
				"family": "Zendri",
				"given": "J -P"
			}, {
				"family": "Zhang",
				"given": "Z"
			}],
			"container-title": "Journal of Instrumentation",
			"issue": "03",
			"issued": {
				"date-parts": [
					["2012", "3", "29"]
				]
			},
			"page": "P03012-P03012",
			"title": "Virgo: a laser interferometer to detect gravitational waves",
			"type": "article-journal",
			"volume": "7"
		},
		{
			"author": [{
				"family": "Borges",
				"given": "Jorge Luis"
			}],
			"editor": [{
				"family": "Weinberger",
				"given": "Eliot"
			}],
			"issued": {
				"date-parts": [
					["1999"]
				]
			},
			"page": "559",
			"publisher": "Viking",
			"publisher-place": "New York",
			"title": "Selected non-fictions",
			"translator": [{
				"family": "Allen",
				"given": "Esther"
			}, {
				"family": "Levine",
				"given": "Suzanne Jill"
			}, {
				"family": "Weinberger",
				"given": "Eliot"
			}],
			"type": "book"
		},
		{
			"ISBN": "9781451648539",
			"author": [{
				"family": "Isaacson",
				"given": "Walter"
			}],
			"issued": {
				"date-parts": [
					["2011", "10", "24"]
				]
			},
			"page": "656",
			"publisher": "Simon & Schuster",
			"title": "Steve Jobs",
			"type": "book"
		},
		{
			"author": [{
				"family": "Van Dan Elzen",
				"given": "Hans"
			}],
			"issued": {
				"date-parts": [
					["2011"]
				]
			},
			"number": "WO2011US30214",
			"title": "Yo-yo having a modifiable string gap",
			"type": "patent"
		},
		{
			"DOI": "10.1088/0143-0807/27/4/007",
			"URL": "http://bavard.fourmilab.ch/etexts/einstein/specrel/specrel.pdf",
			"abstract": "General description of special relativity",
			"author": [{
				"family": "Einstein",
				"given": "Albert"
			}],
			"chapter-number": "3",
			"container-title": "Annalen der Physik",
			"editor": [],
			"issue": "4",
			"issued": {
				"date-parts": [
					["1905"]
				]
			},
			"page": "1-26",
			"publisher": "Dover Publications",
			"title": "On the electrodynamics of moving bodies",
			"translator": [],
			"type": "article-journal",
			"volume": "17"
		},
		{
			"DOI": "10.1038/171737a0",
			"URL": "http://www.ncbi.nlm.nih.gov/pubmed/13054692",
			"abstract": "We wish to suggest a structure for the salt of deoxyribose nucleic acid (D.N.A.). This structure has novel features which are of considerable biological interest.",
			"author": [{
				"family": "Watson",
				"given": "J D"
			}, {
				"family": "Crick",
				"given": "F H"
			}],
			"container-title": "Nature",
			"editor": [],
			"issue": "4356",
			"issued": {
				"date-parts": [
					["1953"]
				]
			},
			"page": "737-738",
			"publisher": "Am Med Assoc",
			"title": "Molecular structure of nucleic acids; a structure for deoxyribose nucleic acid",
			"translator": [],
			"type": "article-journal",
			"volume": "171"
		},
		{
			"type": "report",
			"title": "Country Clustering in Comparative Political Economy",
			"publisher": "Max-Planck Institute for the Study of Societies",
			"publisher-place": "Cologne",
			"page": "32",
			"genre": "MPIfG Discussion Paper 09-5",
			"event-place": "Cologne",
			"author": [
				{
					"family": "Ahlquist",
					"given": "John S."
				},
				{
					"family": "Breunig",
					"given": "Christian"
				}
			],
			"issued": {
				"date-parts": [
					[
						2009
					]
				]
			}
		},
		{
			"type": "chapter",
			"title": "Firms and the Welfare State: When, Why, and How Does Social Policy Matter to Employers?",
			"container-title": "Varieties of Capitalism. The Institutional Foundations of Comparative Advantage",
			"publisher": "Oxford University Press",
			"publisher-place": "New York",
			"page": "184-213",
			"event-place": "New York",
			"note": "undefined\nbring the firms back into the center of analysis\" p. 4 \"two institutions can be said to be complementary if the presence (or efficiency) of one increases the returns from (or efficiency) of the other.\" p. 17\nDate of Input: 29.01.2006\nDate Modified: 08.06.2006\nPriority: Normal",
			"author": [
				{
					"family": "Mares",
					"given": "Isabela"
				}
			],
			"editor": [
				{
					"family": "Hall",
					"given": "Peter A"
				},
				{
					"family": "Soskice",
					"given": "David"
				}
			],
			"issued": {
				"date-parts": [
					[
						2001
					]
				]
			}
		},
		{
			"type": "article-journal",
			"title": "The Varieties of Capitalism and Hybrid Success",
			"container-title": "Comparative Political Studies",
			"page": "307-332",
			"volume": "40",
			"issue": "3",
			"abstract": "The varieties of capitalism literature maintains that advanced capitalist countries whose institutions best fit either the liberal or coordinated market economy types will perform better than countries whose institutions are mixed. This is because hybrids are less likely to yield functionally beneficial institutional complementarities. The authors challenge this assertion. Denmark has performed as well as many purer cases during the 1990s. And Denmark has recently developed a more hybrid form than is generally recognized by (a) increasing the exposure of actors to market forces and (b) decentralizing collective learning and decision making. The institutional complementarities associated with such hybridization have contributed to its success; however, these complementarities are based on institutional heterogeneity rather than homogeneity. This is demonstrated by analyses of three cases: Danish labor markets, vocational training, and industrial policy. The implication of the authors� argument is that the varieties of capitalism theory is logically flawed.",
			"URL": "http://cps.sagepub.com.turing.library.northwestern.edu/content/40/3/307.abstract",
			"DOI": "10.1177/0010414006286542",
			"author": [
				{
					"family": "Campbell",
					"given": "John L."
				},
				{
					"family": "Pedersen",
					"given": "Ove K."
				}
			],
			"issued": {
				"date-parts": [
					[
						"2007",
						3,
						1
					]
				]
			},
			"accessed": {
				"date-parts": [
					[
						2010,
						7,
						26
					]
				]
			}
		},
		{
			"type": "book",
			"title": "Beyond varieties of capitalism: conflict, contradiction, and complementarities in the European economy",
			"publisher": "Oxford University Press",
			"publisher-place": "Oxford and New York",
			"event-place": "Oxford and New York",
			"ISBN": "9780199206483",
			"shortTitle": "Beyond varieties of capitalism",
			"editor": [
				{
					"family": "Hanck\u00e9",
					"given": "Bob"
				},
				{
					"family": "Rhodes",
					"given": "Martin"
				},
				{
					"family": "Thatcher",
					"given": "Mark"
				}
			],
			"issued": {
				"date-parts": [
					[
						2007
					]
				]
			}
		}
	]

	return CSLEDIT_exampleData;
});

// a requirejs plugin that just returns a URL using the correct baseUrl

define('src/getUrl',{
    load: function (name, req, load, config) {
        load(req.toUrl(name));
    }
});




define('src/options',['jquery', 'src/exampleData', 'src/getUrl'], function (jq, CSLEDIT_exampleData, getUrlPlugin) {
	var userOptions = {};
	var defaultOptions = {
			loadCSLName : "Load CSL",
			loadCSLFunc : function () {
				alert("load CSL function not implemented");
			},
			saveCSLName : "Save CSL",
			saveCSLFunc : function (cslCode) {			
				window.location.href =
					"data:application/xml;charset=utf-8," +
					encodeURIComponent(cslCode);
			},
			editStyleName : "Edit Style",
			editStyleFunc : function (url) {
				alert("Edit style not avaiable.\n\n" +
					"For implementers: You need to add an editStyle_func to the options.");
			},
			exampleReferences : CSLEDIT_exampleData.jsonDocumentList,
			exampleCitations : [[0], [10], []]
		};

	// TODO: doesn't really belong here, move to other module
	var getUrl = function (resourcePath) {
		var url;
		require(['src/getUrl!' + resourcePath], function (newUrl) {
			url = newUrl;
		});
		return url;
	};

	// create the default options which are a function of user options
	var createExtraDefaults = function () {
		defaultOptions.cslSchema_mainURL = getUrl("external/csl-schema/csl.rng");
		defaultOptions.cslSchema_childURLs = [];
		$.each([
				"external/csl-schema/csl-categories.rng",
				"external/csl-schema/csl-terms.rng",
				"external/csl-schema/csl-types.rng",
				"external/csl-schema/csl-variables.rng"
			], function (i, path) {
				defaultOptions.cslSchema_childURLs.push(getUrl(path));
			}
		);
	};

	var get = function (key) {
		if (userOptions.hasOwnProperty(key)) {
			return userOptions[key];
		} else {
			return defaultOptions[key];
		}
	};

	createExtraDefaults();

	return {
		getUrl : getUrl,
		get : get,
		setUserOptions : function (_userOptions) {
			userOptions = _userOptions;
			createExtraDefaults();
		}
	};
});




/* Uses CSLEDIT_storage to store current csl data object
 *
 * Supports the following actions:
 * - New style
 * - Load from CSL XML
 * - Add node
 * - Delete node
 * - Amend node
 * - Move node
 */

define('src/cslData',[	'src/uiConfig', // TODO: remove this dependency
			'src/CslNode',
			'src/Iterator',
			'src/cslParser',
			'src/storage',
			'src/options',
			'src/debug'
		],
		function (
			CSLEDIT_uiConfig,
			CSLEDIT_CslNode,
			CSLEDIT_Iterator,
			CSLEDIT_cslParser,
			CSLEDIT_storage,
			CSLEDIT_options,
			debug
		) {
	var CSLEDIT_Data = function (CSL_DATA, _requiredNodes /*optional*/, updateTime /*optional*/) {
		var viewControllers = [],
			callbacksEnabled = true,
			requiredNodes = _requiredNodes || [],
			
			// TODO: decide better place to put styleInfoOrder.
			//       Maybe add this general functionality to the schema for
			//       other nodes too and place the hard-coded list(s) in schemaOptions.
			//
			//       Currently only used when converting to/from CSL code, not as a
			//       constraint while using the editor, due to difficulty of
			//       implementation.
			styleInfoOrder = [
				"title",
				"id",
				'link rel="self"',
				'link rel="template"',
				'link rel="documentation"',
				"author",
				"contributor",
				"category citation-format",
				"category field",
				"issn",
				"summary",
				"updated",
				"rights"
			];

		var get = function () {
			return CSLEDIT_storage.getItemJson(CSL_DATA);
		};

		var set = function (cslData) {
			var updatedNode,
				iter,
				index,
				node;

			if (updateTime) {
				// update 'style/info/updated'
				updatedNode = getNodesFromPath('style/info/updated', cslData)[0];
				if (typeof(updatedNode) === "undefined") {
					debug.log("no style/info/updated node: resetting CSL code");
					setCslCode(CSLEDIT_cslParser.cslCodeFromCslData(cslData));
					updatedNode = getNodesFromPath('style/info/updated')[0];
				}
				
				// write timestamp to updated node
				iter = new CSLEDIT_Iterator(cslData);
				index = 0;
				while (iter.hasNext()) {
					node = iter.next();
					if (index === updatedNode.cslId) {	
						node.textValue = (new Date()).toISOString().replace(/\.[0-9]{3}Z$/, "+00:00");
						break;
					}
					index++;
				}
			}

			CSLEDIT_storage.setItem(CSL_DATA, JSON.stringify(cslData));
			return cslData;
		};

		var nodeMatch = function (nodeData, nodeString) {
			var nodeInfo = nodeString.split(" "),
				nodeName = nodeInfo[0],
				attribute,
				attributeName,
				attributeValue,
				cslNode = new CSLEDIT_CslNode(nodeData);

			if (nodeInfo.length > 1) {
				attribute = nodeInfo[1].split("=");
				attributeName = attribute[0];
				if (attribute.length > 1) {
					attributeValue = attribute[1].replace(/"/g, "");
				}
			}

			if (nodeName !== nodeData.name) {
				return false;
			}
			
			if (typeof(attributeName) !== "undefined" && !cslNode.hasAttr(attributeName)) {
				return false;
			}

			if (typeof(attributeValue) !== "undefined" &&
					cslNode.getAttr(attributeName) !== attributeValue) {
				return false;
			}

			return true;
		};

		var reorderStyleInfoNode = function (cslData /*optional*/) {
			var styleInfoNode;

			cslData = cslData || get();

			// re-order the style/info child nodes:
			$.each(getNodesFromPath('style/info', cslData), function (i, infoNode) {
				var iterator,
					cslId = infoNode.cslId;

				styleInfoNode = infoNode;

				// re-order
				infoNode.children.sort(function (a, b) {
					var orderA = styleInfoOrder.length,
						orderB = styleInfoOrder.length;

					$.each(styleInfoOrder, function (i, nodeString) {
						if (nodeMatch(a, nodeString)) {
							orderA = i;
						}
						if (nodeMatch(b, nodeString)) {
							orderB = i;
						}
					});

					return orderA - orderB;
				});

				// set cslIds
				iterator = new CSLEDIT_Iterator(infoNode);
				while (iterator.hasNext()) {
					iterator.next().cslId = cslId;
					cslId++;
				}

				return false;
			});

			return styleInfoNode;
		};

		var setCslCode = function (cslCode) {
			var cslData,
				error;
			
			//try {
				cslData = CSLEDIT_cslParser.cslDataFromCslCode(cslCode);
			//} catch (err) {
			//	return { error: "Error parsing CSL Code" };
			//}

			// check if this is a dependent style:
			$.each(getNodesFromPath('style/info/link', cslData), function (i, node) {
				var linkNode = new CSLEDIT_CslNode(node);
				if (linkNode.getAttr("rel") === "independent-parent") {
					error = "Editing of dependent styles not yet supported.\n\n" + 
						"Please find and edit this master style instead:\n\n" +
						linkNode.getAttr("href");
				}
			});

			// check it contains required nodes
			if (typeof error === "undefined") {
				$.each(requiredNodes, function (i, requiredNode) {
					if (getNodesFromPath(requiredNode, cslData).length === 0) {
						error = "CSL code is missing essential node: " + requiredNode;
						return false;
					}
				});
			}

			reorderStyleInfoNode(cslData);

			if (error) {
				return { error: error };
			}

			if (updateTime) {
				// add a style/info/updated node if not present
				// (this will be written to on every edit, create here
				//  to avoid doing on every change which would complicate
				//  undo/redo code in CSLEDIT_controller)
				updateTime = false;
				set(cslData);
				if (getNodesFromPath('style/info/updated').length === 0) {
					debug.log("creating required updated node");
					addNode(getNodesFromPath('style/info')[0].cslId, "last",
							new CSLEDIT_CslNode("updated", [], [], -1), true);
				}
				cslData = get();
				updateTime = true;
			}

			set(cslData);

			emit("newStyle", []);
			return {};
		};

		var getCslCode = function (comment /* optional */) {
			var cslData = get();
			reorderStyleInfoNode(cslData);
			return CSLEDIT_cslParser.cslCodeFromCslData(cslData, comment);
		};

		var spliceNode = function (id, position, nodesToDelete, newNode) {
			var iter,
				cslData,
				index,
				node,
				nodesBefore;

			cslData = get();

			nodesBefore = numNodes(cslData);

			// Find the id of the node to add
			iter = new CSLEDIT_Iterator(cslData);

			index = 0;
			while (iter.hasNext()) {
				node = iter.next();
				
				if (index === id) {
				debug.assertEqual(node.cslId, index);
				debug.assert(position + nodesToDelete <= node.children.length);

					if (typeof newNode === "undefined") {
						node.children.splice(position, nodesToDelete);
					} else {
						node.children.splice(position, nodesToDelete, newNode);
					}
				}
				index++;
			}

			// correct the cslId numbering
			iter = new CSLEDIT_Iterator(cslData);
			index = 0;
			while (iter.hasNext()) {
				node = iter.next();
				node.cslId = index;
				index++;
			}

			set(cslData);

			return index - nodesBefore; // difference in number of nodes
		};

		var getNodeAndParent = function (id) {
			var iter = new CSLEDIT_Iterator(get()),
				node;

			while (iter.hasNext()) {
				node = iter.next();

				if (node.cslId === id) {
					return {
						node : node,
						parent : iter.parent()
					};
				}
			}

			// not found
			return { node : null, parent : null };
		};

		var getNodeStack = function (id) {
			var iter = new CSLEDIT_Iterator(get()),
				nodeStack,
				node;

			while (iter.hasNext()) {
				node = iter.next();

				if (node.cslId === id) {
					return iter.stack();
				}
			}
		};

		var getNodePath = function (id) {
			var nodeNames = [];
			$.each(getNodeStack(id), function (i, node) {
				nodeNames.push(node.name);
			});
			return nodeNames.join('/');
		};

		var getNode = function (id, cslData /* optional */) {
			if (typeof cslData !== "undefined") {
				return getNodeAndParent(id, cslData).node;
			} else {
				return getNodeAndParent(id).node;
			}
		};

		// Returns all matching nodes or
		// null if it couldn't find a match
		var getNodesFromPath = function (path, cslData /* optional */) {
			var splitPath = path.split("/"),
				rootNode,
				result = [];

			if (typeof cslData === "undefined") {
				cslData = get();
			}

			rootNode = splitPath.splice(0, 1);

			if (rootNode[0] === "") {
				return result;
			}

			getNodesFromPath_inner(splitPath, cslData, result);
			return result;
		};

		var getNodesFromPath_inner = function (path, nodeData, result) {
			var index,
				rootNode,
				regExp;

			if (path.length === 0) {
				result.push(nodeData);
				return;
			}

			rootNode = path.splice(0, 1);
		debug.assertEqual(rootNode.length, 1);

			// convert '*' wildcard to regexp equivalent
			regExp = new RegExp("^" + rootNode[0].replace("*", ".*") + "$");

			for (index = 0; index < nodeData.children.length; index++) {
				if (regExp.test(nodeData.children[index].name)) {
					getNodesFromPath_inner(path, nodeData.children[index], result);
				}
			}
		};

		var getFirstCslId = function (cslData, nodeName) {
			var index,
				result;

			if (cslData.name === nodeName) {
				return cslData.cslId;
			} else {
				for (index = 0; index < cslData.children.length; index++) {
					result = getFirstCslId(cslData.children[index], nodeName);
					if (result > -1) {
						return result;
					}
				}
			}
			// couldn't find it
			return -1;
		};
		
		// Load new style without reloading page
		var loadStyleFromURL = function (newURL, callback) {
			$.get(newURL, {}, function (cslCode) {
				var result;
				cslCode = cslCode.replace(/<!--.*?-->/g, "");
				result = setCslCode(cslCode);
				if (result.hasOwnProperty('error')) {
					alert(result.error);
					return;
				}
				if (typeof callback !== "undefined") {
					callback();
				}
			}, "text");
		};

		// from https://gist.github.com/1771618
		var getUrlVar = function (key) {
			var result = new RegExp(key + "=([^&]*)", "i").exec(window.location.search); 
			return result && unescape(result[1]) || "";
		};

		var numNodes = function (tree) {
			var iter = new CSLEDIT_Iterator(tree),
				index = 0;

			while (iter.hasNext()) {
				iter.next();
				index++;
			}

			return index;
		};

		var emit = function (event, args) {
			$.each(viewControllers, function (index, controller) {
				controller.styleChanged(event, args);
			});
		};
		
		var indexOfChild = function (childNode, parentNode) {
			var index;
			for (index = 0; index < parentNode.children.length; index++) {
				if (childNode.cslId === parentNode.children[index].cslId) {
					return index;
				}
			}
			return -1;
		};
		
		// if 'id' is a macro instance, returns the corresponding macro definition
		// if not, returns 'id' 
		var macroDefinitionIdFromInstanceId = function (id) {
			var node = new CSLEDIT_CslNode(getNode(id)),
				macroName,
				macroNodes,
				macroNode;

			macroName = node.getAttr("macro");
			if (node.name === "text" && macroName !== "") {
				macroNodes = getNodesFromPath("style/macro");

				$.each(macroNodes, function (i, macroNode) {
					var thisMacroNode = new CSLEDIT_CslNode(macroNode);
					if (thisMacroNode.getAttr("name") === macroName) {
						id = thisMacroNode.cslId;
						return false;
					}
				});
			}
			return id;
		};

		var addNode = function (id, position, newNode, suppressViewUpdate /*optional*/) {
			var nodeInfo,
				positionIndex,
				nodesAdded,
				defaultAttributes;
			
			newNode.cslId = -1;
			newNode.children = newNode.children || [];
			newNode.attributes = newNode.attributes || [];

			defaultAttributes = CSLEDIT_uiConfig.defaultAttributes[newNode.name];

			// populate with default attributes
			if (newNode.attributes.length === 0 && typeof defaultAttributes !== "undefined") {
				$.each(defaultAttributes, function (attribute, value) {
					newNode.attributes.push({key: attribute, value: value, enabled: true});
				});
			}

			if (typeof position === "number") {
				// change parent id from macro instances to macro definitions
				id = macroDefinitionIdFromInstanceId(id);

				nodesAdded = spliceNode(id, position, 0, newNode);
				if (!suppressViewUpdate) {
					emit("addNode", [id, position, newNode, nodesAdded]);
				}
			} else {
				switch (position) {
				case "first":
					// change parent id from macro instances to macro definitions
					id = macroDefinitionIdFromInstanceId(id);

					return addNode(id, 0, newNode);
				case "inside":
				case "last":
					// change parent id from macro instances to macro definitions
					id = macroDefinitionIdFromInstanceId(id);
					
					return addNode(id, getNode(id).children.length, newNode);
				case "before":
				case "after":
				debug.assert(id !== 0);
					nodeInfo = getNodeAndParent(id);
					positionIndex = indexOfChild(nodeInfo.node, nodeInfo.parent);
					if (position === "after") {
						positionIndex++;
					}
					return addNode(nodeInfo.parent.cslId, positionIndex, newNode);
				case "default":
				debug.assert(false, "position: " + position + " not recognised");
				}
			}
			return newNode.cslId;
		};

		var deleteNode = function (id) {
			var iter = new CSLEDIT_Iterator(get()),
				index,
				node,
				parentNode,
				nodesDeleted;

		debug.assert(id !== 0); // can't delete the style node

			index = 0;
			while (iter.hasNext()) {
				node = iter.next();

				if (index === id) {
					parentNode = iter.parent();
					break;
				}
				index++;
			}

		debug.assert(typeof parentNode !== "undefined");
			nodesDeleted = -spliceNode(parentNode.cslId, indexOfChild(node, parentNode), 1);
		debug.assertEqual(node.cslId, id);
			
			emit("deleteNode", [id, nodesDeleted]);
			
			return node;
		};

		var amendNode = function (id, amendedNode) {
			// replace everything of the original node except the children and the cslId
			var cslData = get(),
				iter,
				node,
				index,
				result,
				oldNode;
			
			iter = new CSLEDIT_Iterator(cslData);
			index = 0;

			while (iter.hasNext()) {
				node = iter.next();
				if (index === id) {
				debug.assertEqual(node.cslId, id);
					
					oldNode = new CSLEDIT_CslNode(node.name, node.attributes, [], node.cslId);
					oldNode.textValue = node.textValue;

					node.name = amendedNode.name;
					node.attributes = amendedNode.attributes;
					node.textValue = amendedNode.textValue;

					break;
				}
				index++;
			}
		debug.assert(typeof node !== "undefined");
			set(cslData);
			emit("amendNode", [id, node]);
			emit("formatCitations");
			// return inverse command
			return {
				command : "amendNode",
				args : [id, oldNode]
			};
		};

		return {
			setCslCode : setCslCode,
			getCslCode : getCslCode,
			get : get,
			addNode : function (id, position, newNode) {
				var newCslId = addNode(id, position, newNode),
					inverse;
				emit("formatCitations");

				// return the inverse command for undo functionality
				return {
					command : "deleteNode",
					args : [ newCslId ]
				};
			},
			deleteNode : function (id) {
				var deletedNode,
					nodeAndParent = getNodeAndParent(id),
					parentNode,
					position,
					nodePath = getNodePath(id),
					error;

				// can't delete required nodes
				$.each(requiredNodes, function (i, requiredNodePath) {
					if (nodePath === requiredNodePath) {
						error = "Cannot delete required node: " + nodePath;
						return false;
					}
				});

				if (error) {
					return { error : error };
				}

				parentNode = nodeAndParent.parent.cslId;
				position = indexOfChild(nodeAndParent.node, nodeAndParent.parent);

				deletedNode = deleteNode(id);

				emit("formatCitations");

				// return the inverse command for undo functionality
				return {
					command : "addNode",
					args : [ parentNode, position, deletedNode ]
				};
			},
			amendNode : amendNode,
			moveNode : function (fromId, toId, position) {
				var deletedNode, fromNode,
					inverseFromCslId,
					inverseToNodeAndParent = getNodeAndParent(fromId),
					inverseToCslId,
					inverseToPosition;

				callbacksEnabled = false;

				inverseToCslId = inverseToNodeAndParent.parent.cslId;
				inverseToPosition = indexOfChild(inverseToNodeAndParent.node, inverseToNodeAndParent.parent);

				deletedNode = deleteNode(fromId);

				debug.log("deletedNode = " + deletedNode.cslId);
				if (toId > fromId) {
					toId -= numNodes(deletedNode);
				}

				inverseFromCslId = addNode(toId, position, deletedNode);
				if (inverseToCslId > inverseFromCslId) {
					inverseToCslId += numNodes(deletedNode);
				}

				callbacksEnabled = true;

				emit("formatCitations");
				// return inverse command
				return {
					command : "moveNode",
					args : [inverseFromCslId, inverseToCslId, inverseToPosition]
				};
			},
			getNode : getNode,
			getNodeAndParent : getNodeAndParent,
			getNodeStack : getNodeStack,
			getNodePath : getNodePath,
			getFirstCslId : getFirstCslId,

			loadStyleFromURL : loadStyleFromURL,

			initPageStyle : function (callback) {
				var cslData, styleURL, result;
				cslData = get(); 
				
				styleURL = getUrlVar("styleURL");
				debug.log("url from url: " + styleURL);

				// try loading style specified in options
				if (typeof CSLEDIT_options.get("initialCslCode") !== "undefined") {
					result = setCslCode(CSLEDIT_options.get("initialCslCode"));
					if (result.hasOwnProperty('error')) {
						alert(result.error);
					} else {
						callback();
						return;
					}
				}
				
				if (styleURL !== "" && typeof styleURL !== 'undefined') {
					styleURL = "../getFromOtherWebsite.php?url=" + encodeURIComponent(styleURL);
					
					loadStyleFromURL(styleURL, callback);
				} else if (cslData !== null && cslData !== "") {
					callback();
				} else {
					styleURL = CSLEDIT_options.getUrl("external/csl-styles/apa.csl");
					loadStyleFromURL(styleURL, callback);
				}
			},
			numNodes : numNodes,
			numCslNodes : function () { return numNodes(get()); },
			clearViewControllers : function () {
				viewControllers = [];
			},
			addViewController : function (_viewController) {
				viewControllers.push(_viewController);
			},
			getNodesFromPath : getNodesFromPath,
			indexOfChild : indexOfChild,
			macroDefinitionIdFromInstanceId : macroDefinitionIdFromInstanceId
		};
	};

	// global instance, this is overwritten for unit tests
	var CSLEDIT_data = new CSLEDIT_Data("CSLEDIT_cslData", [
			"style",
			"style/info",
			"style/info/title",
			"style/info/id",
			"style/citation",
			"style/citation/layout",
			"style/bibliography",
			"style/bibliography/layout"
		], true);
	
	return CSLEDIT_data;
});



// Sends commands to the data module, and maintains the command history used by
// the undo function
//
// ** Any action which affects the data should go through the controller **
// 
define('src/controller',['src/cslData', 'src/debug'], function (CSLEDIT_data, debug) {
	var commands = [
			"addNode",
			"deleteNode",
			"moveNode",
			"amendNode",
			"setCslCode"
		],
		commandHistory = [],
		undoCommandHistory = [],
		cslData;

	var setCslData = function (_cslData) {
		$.each(commands, function (index, command) {
			debug.assertEqual(typeof _cslData[command], "function", "cslData must contain: " + command);
		});
		
		cslData = _cslData;
	};

	// These can be called like regular commands, but can't be subscribed to.
	// They use the regular commands to perform more complicated tasks.
	var macros = {
		addPath : function ( path ) {
			var splitPath = path.split("/"),
				index,
				currentPath = "",
				nodes,
				parentCslId;

			for (index = 0; index < splitPath.length; index++) {
				if (index > 0) {
					currentPath += "/";
				}
				currentPath += splitPath[index];
				nodes = CSLEDIT_data.getNodesFromPath(currentPath)
				if (nodes.length === 0) {
					if (index === 0) {
						// add root node
						_exec("addNode", [0, "before", {name: splitPath[index]}], commandHistory);
						parentCslId = 0;
					} else {
						_exec("addNode",
							[parentCslId, "first", {name: splitPath[index]}], commandHistory);
						parentCslId++;
					}
				} else {
					parentCslId = nodes[0].cslId;
				}
			}
		}
	};

	var undo = function () {
		var command = commandHistory.pop();

		_exec(command.inverse.command, command.inverse.args, undoCommandHistory);
	};

	var redo = function () {
		var command = undoCommandHistory.pop();

		_exec(command.inverse.command, command.inverse.args, commandHistory);
	};

	var exec = function (command, args) {
		undoCommandHistory.length = 0;
		if (command in macros) {
			macros[command].apply(null, args);
		} else {
			debug.assert(commands.indexOf(command) !== -1, "command doesn't exist");
			_exec(command, args, commandHistory);
		}
	};

	var _exec = function(command, args, history) {
		var inverseCommand;

		debug.log("executing command " + command + "(" + JSON.stringify(args) + ")");
		inverseCommand = cslData[command].apply(null, args);
		
		if (typeof inverseCommand !== "undefined" && inverseCommand.hasOwnProperty("error")) {
			alert(inverseCommand.error);
			return;
		}

		if (command === "setCslCode") {
			// no undo available for this yet, wipe command history
			history.length = 0;
		} else {
			history.push({command:command, args:args, inverse:inverseCommand});
		}
	};

	return {
		setCslData : setCslData,
		exec : exec,
		commandHistory : commandHistory,
		undoCommandHistory : undoCommandHistory,
		undo : undo,
		redo : redo,
		clearHistory : function () {
			commandHistory.length = 0;
		}
	};
});



// Watches a CSL node represented by nodePath and calls onChange whenever it changes
//
// It's OK if no node exists at nodePath
// It's not OK if > 1 node exists at nodePath

define('src/NodeWatcher',['src/debug'], function (debug) {
	var CSLEDIT_NodeWatcher = function (nodePath, cslData, onChange) {
		var that = this;
		
		this.nodeData = null;

		this.nodePath = nodePath;
		this.cslData = cslData;
		this.onChange = onChange;

		this.updateNodeData();
		this.nodeUpdated();
	};

	CSLEDIT_NodeWatcher.prototype.nodeUpdated = function () {
		this.onChange(this.nodeData);
	};

	CSLEDIT_NodeWatcher.prototype.getSelectedNodePath = function () {
		var splitNodePath = this.nodePath.split("/"),
			nodePath = [],
			cslIdPath = [],
			nodes;

		while (splitNodePath.length > 0) {
			nodePath.push(splitNodePath.splice(0, 1));
			nodes = this.cslData.getNodesFromPath(nodePath.join("/"));
			debug.assertEqual(nodes.length, 1);
			cslIdPath.push(nodes[0].cslId);
		}

		return cslIdPath;
	};

	CSLEDIT_NodeWatcher.prototype.updateNodeData = function () {
		var nodes;

		this.nodeData = null;
		
		if (typeof(this.nodePath) === "undefined") {
			return;
		}

		nodes = this.cslData.getNodesFromPath(this.nodePath);

		if (nodes.length > 0) {
			this.nodeData = nodes[0];
		}
	};

	CSLEDIT_NodeWatcher.prototype.addNode = function (id, position, node, numAdded) {
		if (this.nodeData !== null) {
			if (node.cslId <= this.nodeData.cslId) {
				// shift the nodeData forward
				this.nodeData.cslId += numAdded;
				this.nodeUpdated();
			}
		} else {
			this.updateNodeData();
			this.nodeUpdated();
		}
	};

	CSLEDIT_NodeWatcher.prototype.deleteNode = function (id, numDeleted) {
		if (this.nodeData === null) {
			return;
		}

		if (this.nodeData.cslId >= id && this.nodeData.cslId < id + numDeleted) {
			// this node has been deleted
			this.updateNodeData();
			this.nodeUpdated();
			return;
		}

		if (this.nodeData.cslId >= id + numDeleted) {
			this.nodeData.cslId -= numDeleted;
			this.nodeUpdated();
		}
	};

	CSLEDIT_NodeWatcher.prototype.amendNode = function (id, amendedNode) {
		if (this.nodeData === null) {
			return;
		}

		if (id === this.nodeData.cslId) {
			this.nodeData = amendedNode;
			this.nodeUpdated();
		}
	};

	return CSLEDIT_NodeWatcher;
});



// Uses a NodeWatcher to monitor the style/info/title node for changes
// and updates the titlebar

define('src/Titlebar',['src/NodeWatcher', 'src/cslData', 'src/debug'], function (CSLEDIT_NodeWatcher, CSLEDIT_data, debug) {
	var CSLEDIT_Titlebar = function (element) {
		var that = this;

		this.element = element;
		this.element.html('<h3><span cslid="-1"/></h3>').css({cursor: "default"});

		this.nodeWatcher = new CSLEDIT_NodeWatcher("style/info/title", CSLEDIT_data, function (nodeData) {
			that.updateTitle(nodeData);
		});
		
		this.addNode = function (id, position, nodeData, numNodes) {
			that.nodeWatcher.addNode(id, position, nodeData, numNodes);
		};
		this.deleteNode = function (id, numNodes) {
			that.nodeWatcher.deleteNode(id, numNodes);
		};
		this.amendNode = function (id, nodeData) {
			that.nodeWatcher.amendNode(id, nodeData);
		};
	};

	CSLEDIT_Titlebar.prototype.updateTitle = function (nodeData) {
		var title;
		if (nodeData === null) {
			title = "No title";
		} else {
			title = nodeData.textValue;
		}
		this.element.find('span[cslid]').html(title).attr('cslid', nodeData.cslId);

		debug.log("updated title to " + this.element.html());
	};

	return CSLEDIT_Titlebar;
});

/*
 * jsTree 1.0-rc3
 * http://jstree.com/
 *
 * Copyright (c) 2010 Ivan Bozhanov (vakata.com)
 *
 * Licensed same as jquery - under the terms of either the MIT License or the GPL Version 2 License
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 *
 * $Date: 2011-02-09 01:17:14 +0200 (ср, 09 февр 2011) $
 * $Revision: 236 $
 */

/*jslint browser: true, onevar: true, undef: true, bitwise: true, strict: true */
/*global window : false, clearInterval: false, clearTimeout: false, document: false, setInterval: false, setTimeout: false, jQuery: false, navigator: false, XSLTProcessor: false, DOMParser: false, XMLSerializer: false*/



// top wrapper to prevent multiple inclusion (is this OK?)
(function () { if(jQuery && jQuery.jstree) { return; }
	var is_ie6 = false, is_ie7 = false, is_ff2 = false;

/* 
 * jsTree core
 */
(function ($) {
	// Common functions not related to jsTree 
	// decided to move them to a `vakata` "namespace"
	$.vakata = {};
	// CSS related functions
	$.vakata.css = {
		get_css : function(rule_name, delete_flag, sheet) {
			rule_name = rule_name.toLowerCase();
			var css_rules = sheet.cssRules || sheet.rules,
				j = 0;
			do {
				if(css_rules.length && j > css_rules.length + 5) { return false; }
				if(css_rules[j].selectorText && css_rules[j].selectorText.toLowerCase() == rule_name) {
					if(delete_flag === true) {
						if(sheet.removeRule) { sheet.removeRule(j); }
						if(sheet.deleteRule) { sheet.deleteRule(j); }
						return true;
					}
					else { return css_rules[j]; }
				}
			}
			while (css_rules[++j]);
			return false;
		},
		add_css : function(rule_name, sheet) {
			if($.jstree.css.get_css(rule_name, false, sheet)) { return false; }
			if(sheet.insertRule) { sheet.insertRule(rule_name + ' { }', 0); } else { sheet.addRule(rule_name, null, 0); }
			return $.vakata.css.get_css(rule_name);
		},
		remove_css : function(rule_name, sheet) { 
			return $.vakata.css.get_css(rule_name, true, sheet); 
		},
		add_sheet : function(opts) {
			var tmp = false, is_new = true;
			if(opts.str) {
				if(opts.title) { tmp = $("style[id='" + opts.title + "-stylesheet']")[0]; }
				if(tmp) { is_new = false; }
				else {
					tmp = document.createElement("style");
					tmp.setAttribute('type',"text/css");
					if(opts.title) { tmp.setAttribute("id", opts.title + "-stylesheet"); }
				}
				if(tmp.styleSheet) {
					if(is_new) { 
						document.getElementsByTagName("head")[0].appendChild(tmp); 
						tmp.styleSheet.cssText = opts.str; 
					}
					else {
						tmp.styleSheet.cssText = tmp.styleSheet.cssText + " " + opts.str; 
					}
				}
				else {
					tmp.appendChild(document.createTextNode(opts.str));
					document.getElementsByTagName("head")[0].appendChild(tmp);
				}
				return tmp.sheet || tmp.styleSheet;
			}
			if(opts.url) {
				if(document.createStyleSheet) {
					try { tmp = document.createStyleSheet(opts.url); } catch (e) { }
				}
				else {
					tmp			= document.createElement('link');
					tmp.rel		= 'stylesheet';
					tmp.type	= 'text/css';
					tmp.media	= "all";
					tmp.href	= opts.url;
					document.getElementsByTagName("head")[0].appendChild(tmp);
					return tmp.styleSheet;
				}
			}
		}
	};

	// private variables 
	var instances = [],			// instance array (used by $.jstree.reference/create/focused)
		focused_instance = -1,	// the index in the instance array of the currently focused instance
		plugins = {},			// list of included plugins
		prepared_move = {};		// for the move_node function

	// jQuery plugin wrapper (thanks to jquery UI widget function)
	$.fn.jstree = function (settings) {
		var isMethodCall = (typeof settings == 'string'), // is this a method call like $().jstree("open_node")
			args = Array.prototype.slice.call(arguments, 1), 
			returnValue = this;

		// if a method call execute the method on all selected instances
		if(isMethodCall) {
			if(settings.substring(0, 1) == '_') { return returnValue; }
			this.each(function() {
				var instance = instances[$.data(this, "jstree_instance_id")],
					methodValue = (instance && $.isFunction(instance[settings])) ? instance[settings].apply(instance, args) : instance;
					if(typeof methodValue !== "undefined" && (settings.indexOf("is_") === 0 || (methodValue !== true && methodValue !== false))) { returnValue = methodValue; return false; }
			});
		}
		else {
			this.each(function() {
				// extend settings and allow for multiple hashes and $.data
				var instance_id = $.data(this, "jstree_instance_id"),
					a = [],
					b = settings ? $.extend({}, true, settings) : {},
					c = $(this), 
					s = false, 
					t = [];
				a = a.concat(args);
				if(c.data("jstree")) { a.push(c.data("jstree")); }
				b = a.length ? $.extend.apply(null, [true, b].concat(a)) : b;

				// if an instance already exists, destroy it first
				if(typeof instance_id !== "undefined" && instances[instance_id]) { instances[instance_id].destroy(); }
				// push a new empty object to the instances array
				instance_id = parseInt(instances.push({}),10) - 1;
				// store the jstree instance id to the container element
				$.data(this, "jstree_instance_id", instance_id);
				// clean up all plugins
				b.plugins = $.isArray(b.plugins) ? b.plugins : $.jstree.defaults.plugins.slice();
				b.plugins.unshift("core");
				// only unique plugins
				b.plugins = b.plugins.sort().join(",,").replace(/(,|^)([^,]+)(,,\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",");

				// extend defaults with passed data
				s = $.extend(true, {}, $.jstree.defaults, b);
				s.plugins = b.plugins;
				$.each(plugins, function (i, val) { 
					if($.inArray(i, s.plugins) === -1) { s[i] = null; delete s[i]; } 
					else { t.push(i); }
				});
				s.plugins = t;

				// push the new object to the instances array (at the same time set the default classes to the container) and init
				instances[instance_id] = new $.jstree._instance(instance_id, $(this).addClass("jstree jstree-" + instance_id), s); 
				// init all activated plugins for this instance
				$.each(instances[instance_id]._get_settings().plugins, function (i, val) { instances[instance_id].data[val] = {}; });
				$.each(instances[instance_id]._get_settings().plugins, function (i, val) { if(plugins[val]) { plugins[val].__init.apply(instances[instance_id]); } });
				// initialize the instance
				setTimeout(function() { if(instances[instance_id]) { instances[instance_id].init(); } }, 0);
			});
		}
		// return the jquery selection (or if it was a method call that returned a value - the returned value)
		return returnValue;
	};
	// object to store exposed functions and objects
	$.jstree = {
		defaults : {
			plugins : []
		},
		_focused : function () { return instances[focused_instance] || null; },
		_reference : function (needle) { 
			// get by instance id
			if(instances[needle]) { return instances[needle]; }
			// get by DOM (if still no luck - return null
			var o = $(needle); 
			if(!o.length && typeof needle === "string") { o = $("#" + needle); }
			if(!o.length) { return null; }
			return instances[o.closest(".jstree").data("jstree_instance_id")] || null; 
		},
		_instance : function (index, container, settings) { 
			// for plugins to store data in
			this.data = { core : {} };
			this.get_settings	= function () { return $.extend(true, {}, settings); };
			this._get_settings	= function () { return settings; };
			this.get_index		= function () { return index; };
			this.get_container	= function () { return container; };
			this.get_container_ul = function () { return container.children("ul:eq(0)"); };
			this._set_settings	= function (s) { 
				settings = $.extend(true, {}, settings, s);
			};
		},
		_fn : { },
		plugin : function (pname, pdata) {
			pdata = $.extend({}, {
				__init		: $.noop, 
				__destroy	: $.noop,
				_fn			: {},
				defaults	: false
			}, pdata);
			plugins[pname] = pdata;

			$.jstree.defaults[pname] = pdata.defaults;
			$.each(pdata._fn, function (i, val) {
				val.plugin		= pname;
				val.old			= $.jstree._fn[i];
				$.jstree._fn[i] = function () {
					var rslt,
						func = val,
						args = Array.prototype.slice.call(arguments),
						evnt = new $.Event("before.jstree"),
						rlbk = false;

					if(this.data.core.locked === true && i !== "unlock" && i !== "is_locked") { return; }

					// Check if function belongs to the included plugins of this instance
					do {
						if(func && func.plugin && $.inArray(func.plugin, this._get_settings().plugins) !== -1) { break; }
						func = func.old;
					} while(func);
					if(!func) { return; }

					// context and function to trigger events, then finally call the function
					if(i.indexOf("_") === 0) {
						rslt = func.apply(this, args);
					}
					else {
						rslt = this.get_container().triggerHandler(evnt, { "func" : i, "inst" : this, "args" : args, "plugin" : func.plugin });
						if(rslt === false) { return; }
						if(typeof rslt !== "undefined") { args = rslt; }

						rslt = func.apply(
							$.extend({}, this, { 
								__callback : function (data) { 
									this.get_container().triggerHandler( i + '.jstree', { "inst" : this, "args" : args, "rslt" : data, "rlbk" : rlbk });
								},
								__rollback : function () { 
									rlbk = this.get_rollback();
									return rlbk;
								},
								__call_old : function (replace_arguments) {
									return func.old.apply(this, (replace_arguments ? Array.prototype.slice.call(arguments, 1) : args ) );
								}
							}), args);
					}

					// return the result
					return rslt;
				};
				$.jstree._fn[i].old = val.old;
				$.jstree._fn[i].plugin = pname;
			});
		},
		rollback : function (rb) {
			if(rb) {
				if(!$.isArray(rb)) { rb = [ rb ]; }
				$.each(rb, function (i, val) {
					instances[val.i].set_rollback(val.h, val.d);
				});
			}
		}
	};
	// set the prototype for all instances
	$.jstree._fn = $.jstree._instance.prototype = {};

	// load the css when DOM is ready
	$(function() {
		// code is copied from jQuery ($.browser is deprecated + there is a bug in IE)
		var u = navigator.userAgent.toLowerCase(),
			v = (u.match( /.+?(?:rv|it|ra|ie)[\/: ]([\d.]+)/ ) || [0,'0'])[1],
			css_string = '' + 
				'.jstree ul, .jstree li { display:block; margin:0 0 0 0; padding:0 0 0 0; list-style-type:none; } ' + 
				'.jstree li { display:block; min-height:18px; line-height:18px; white-space:nowrap; margin-left:18px; min-width:18px; } ' + 
				'.jstree-rtl li { margin-left:0; margin-right:18px; } ' + 
				'.jstree > ul > li { margin-left:0px; } ' + 
				'.jstree-rtl > ul > li { margin-right:0px; } ' + 
				'.jstree ins { display:inline-block; text-decoration:none; width:18px; height:18px; margin:0 0 0 0; padding:0; } ' + 
				'.jstree a { display:inline-block; line-height:16px; height:16px; color:black; white-space:nowrap; text-decoration:none; padding:1px 2px; margin:0; } ' + 
				'.jstree a:focus { outline: none; } ' + 
				'.jstree a > ins { height:16px; width:16px; } ' + 
				'.jstree a > .jstree-icon { margin-right:3px; } ' + 
				'.jstree-rtl a > .jstree-icon { margin-left:3px; margin-right:0; } ' + 
				'li.jstree-open > ul { display:block; } ' + 
				'li.jstree-closed > ul { display:none; } ';
		// Correct IE 6 (does not support the > CSS selector)
		if(/msie/.test(u) && parseInt(v, 10) == 6) { 
			is_ie6 = true;

			// fix image flicker and lack of caching
			try {
				document.execCommand("BackgroundImageCache", false, true);
			} catch (err) { }

			css_string += '' + 
				'.jstree li { height:18px; margin-left:0; margin-right:0; } ' + 
				'.jstree li li { margin-left:18px; } ' + 
				'.jstree-rtl li li { margin-left:0px; margin-right:18px; } ' + 
				'li.jstree-open ul { display:block; } ' + 
				'li.jstree-closed ul { display:none !important; } ' + 
				'.jstree li a { display:inline; border-width:0 !important; padding:0px 2px !important; } ' + 
				'.jstree li a ins { height:16px; width:16px; margin-right:3px; } ' + 
				'.jstree-rtl li a ins { margin-right:0px; margin-left:3px; } ';
		}
		// Correct IE 7 (shifts anchor nodes onhover)
		if(/msie/.test(u) && parseInt(v, 10) == 7) { 
			is_ie7 = true;
			css_string += '.jstree li a { border-width:0 !important; padding:0px 2px !important; } ';
		}
		// correct ff2 lack of display:inline-block
		if(!/compatible/.test(u) && /mozilla/.test(u) && parseFloat(v, 10) < 1.9) {
			is_ff2 = true;
			css_string += '' + 
				'.jstree ins { display:-moz-inline-box; } ' + 
				'.jstree li { line-height:12px; } ' + // WHY??
				'.jstree a { display:-moz-inline-box; } ' + 
				'.jstree .jstree-no-icons .jstree-checkbox { display:-moz-inline-stack !important; } ';
				/* this shouldn't be here as it is theme specific */
		}
		// the default stylesheet
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});

	// core functions (open, close, create, update, delete)
	$.jstree.plugin("core", {
		__init : function () {
			this.data.core.locked = false;
			this.data.core.to_open = this.get_settings().core.initially_open;
			this.data.core.to_load = this.get_settings().core.initially_load;
		},
		defaults : { 
			html_titles	: false,
			animation	: 500,
			initially_open : [],
			initially_load : [],
			open_parents : true,
			notify_plugins : true,
			rtl			: false,
			load_open	: false,
			strings		: {
				loading		: "Loading ...",
				new_node	: "New node",
				multiple_selection : "Multiple selection"
			}
		},
		_fn : { 
			init	: function () { 
				this.set_focus(); 
				if(this._get_settings().core.rtl) {
					this.get_container().addClass("jstree-rtl").css("direction", "rtl");
				}
				this.get_container().html("<ul><li class='jstree-last jstree-leaf'><ins>&#160;</ins><a class='jstree-loading' href='#'><ins class='jstree-icon'>&#160;</ins>" + this._get_string("loading") + "</a></li></ul>");
				this.data.core.li_height = this.get_container_ul().find("li.jstree-closed, li.jstree-leaf").eq(0).height() || 18;

				this.get_container()
					.delegate("li > ins", "click.jstree", $.proxy(function (event) {
							var trgt = $(event.target);
							// if(trgt.is("ins") && event.pageY - trgt.offset().top < this.data.core.li_height) { this.toggle_node(trgt); }
							this.toggle_node(trgt);
						}, this))
					.bind("mousedown.jstree", $.proxy(function () { 
							this.set_focus(); // This used to be setTimeout(set_focus,0) - why?
						}, this))
					.bind("dblclick.jstree", function (event) { 
						var sel;
						if(document.selection && document.selection.empty) { document.selection.empty(); }
						else {
							if(window.getSelection) {
								sel = window.getSelection();
								try { 
									sel.removeAllRanges();
									sel.collapse();
								} catch (err) { }
							}
						}
					});
				if(this._get_settings().core.notify_plugins) {
					this.get_container()
						.bind("load_node.jstree", $.proxy(function (e, data) { 
								var o = this._get_node(data.rslt.obj),
									t = this;
								if(o === -1) { o = this.get_container_ul(); }
								if(!o.length) { return; }
								o.find("li").each(function () {
									var th = $(this);
									if(th.data("jstree")) {
										$.each(th.data("jstree"), function (plugin, values) {
											if(t.data[plugin] && $.isFunction(t["_" + plugin + "_notify"])) {
												t["_" + plugin + "_notify"].call(t, th, values);
											}
										});
									}
								});
							}, this));
				}
				if(this._get_settings().core.load_open) {
					this.get_container()
						.bind("load_node.jstree", $.proxy(function (e, data) { 
								var o = this._get_node(data.rslt.obj),
									t = this;
								if(o === -1) { o = this.get_container_ul(); }
								if(!o.length) { return; }
								o.find("li.jstree-open:not(:has(ul))").each(function () {
									t.load_node(this, $.noop, $.noop);
								});
							}, this));
				}
				this.__callback();
				this.load_node(-1, function () { this.loaded(); this.reload_nodes(); });
			},
			destroy	: function () { 
				var i,
					n = this.get_index(),
					s = this._get_settings(),
					_this = this;

				$.each(s.plugins, function (i, val) {
					try { plugins[val].__destroy.apply(_this); } catch(err) { }
				});
				this.__callback();
				// set focus to another instance if this one is focused
				if(this.is_focused()) { 
					for(i in instances) { 
						if(instances.hasOwnProperty(i) && i != n) { 
							instances[i].set_focus(); 
							break; 
						} 
					}
				}
				// if no other instance found
				if(n === focused_instance) { focused_instance = -1; }
				// remove all traces of jstree in the DOM (only the ones set using jstree*) and cleans all events
				this.get_container()
					.unbind(".jstree")
					.undelegate(".jstree")
					.removeData("jstree_instance_id")
					.find("[class^='jstree']")
						.andSelf()
						.attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig,''); });
				$(document)
					.unbind(".jstree-" + n)
					.undelegate(".jstree-" + n);
				// remove the actual data
				instances[n] = null;
				delete instances[n];
			},

			_core_notify : function (n, data) {
				if(data.opened) {
					this.open_node(n, false, true);
				}
			},

			lock : function () {
				this.data.core.locked = true;
				this.get_container().children("ul").addClass("jstree-locked").css("opacity","0.7");
				this.__callback({});
			},
			unlock : function () {
				this.data.core.locked = false;
				this.get_container().children("ul").removeClass("jstree-locked").css("opacity","1");
				this.__callback({});
			},
			is_locked : function () { return this.data.core.locked; },
			save_opened : function () {
				var _this = this;
				this.data.core.to_open = [];
				this.get_container_ul().find("li.jstree-open").each(function () { 
					if(this.id) { _this.data.core.to_open.push("#" + this.id.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:")); }
				});
				this.__callback(_this.data.core.to_open);
			},
			save_loaded : function () { },
			reload_nodes : function (is_callback) {
				var _this = this,
					done = true,
					current = [],
					remaining = [];
				if(!is_callback) { 
					this.data.core.reopen = false; 
					this.data.core.refreshing = true; 
					this.data.core.to_open = $.map($.makeArray(this.data.core.to_open), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"); });
					this.data.core.to_load = $.map($.makeArray(this.data.core.to_load), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"); });
					if(this.data.core.to_open.length) {
						this.data.core.to_load = this.data.core.to_load.concat(this.data.core.to_open);
					}
				}
				if(this.data.core.to_load.length) {
					$.each(this.data.core.to_load, function (i, val) {
						if(val == "#") { return true; }
						if($(val).length) { current.push(val); }
						else { remaining.push(val); }
					});
					if(current.length) {
						this.data.core.to_load = remaining;
						$.each(current, function (i, val) { 
							if(!_this._is_loaded(val)) {
								_this.load_node(val, function () { _this.reload_nodes(true); }, function () { _this.reload_nodes(true); });
								done = false;
							}
						});
					}
				}
				if(this.data.core.to_open.length) {
					$.each(this.data.core.to_open, function (i, val) {
						_this.open_node(val, false, true); 
					});
				}
				if(done) { 
					// TODO: find a more elegant approach to syncronizing returning requests
					if(this.data.core.reopen) { clearTimeout(this.data.core.reopen); }
					this.data.core.reopen = setTimeout(function () { _this.__callback({}, _this); }, 50);
					this.data.core.refreshing = false;
					this.reopen();
				}
			},
			reopen : function () {
				var _this = this;
				if(this.data.core.to_open.length) {
					$.each(this.data.core.to_open, function (i, val) {
						_this.open_node(val, false, true); 
					});
				}
				this.__callback({});
			},
			refresh : function (obj) {
				var _this = this;
				this.save_opened();
				if(!obj) { obj = -1; }
				obj = this._get_node(obj);
				if(!obj) { obj = -1; }
				if(obj !== -1) { obj.children("UL").remove(); }
				else { this.get_container_ul().empty(); }
				this.load_node(obj, function () { _this.__callback({ "obj" : obj}); _this.reload_nodes(); });
			},
			// Dummy function to fire after the first load (so that there is a jstree.loaded event)
			loaded	: function () { 
				this.__callback(); 
			},
			// deal with focus
			set_focus	: function () { 
				if(this.is_focused()) { return; }
				var f = $.jstree._focused();
				if(f) { f.unset_focus(); }

				this.get_container().addClass("jstree-focused"); 
				focused_instance = this.get_index(); 
				this.__callback();
			},
			is_focused	: function () { 
				return focused_instance == this.get_index(); 
			},
			unset_focus	: function () {
				if(this.is_focused()) {
					this.get_container().removeClass("jstree-focused"); 
					focused_instance = -1; 
				}
				this.__callback();
			},

			// traverse
			_get_node		: function (obj) { 
				var $obj = $(obj, this.get_container()); 
				if($obj.is(".jstree") || obj == -1) { return -1; } 
				$obj = $obj.closest("li", this.get_container()); 
				return $obj.length ? $obj : false; 
			},
			_get_next		: function (obj, strict) {
				obj = this._get_node(obj);
				if(obj === -1) { return this.get_container().find("> ul > li:first-child"); }
				if(!obj.length) { return false; }
				if(strict) { return (obj.nextAll("li").size() > 0) ? obj.nextAll("li:eq(0)") : false; }

				if(obj.hasClass("jstree-open")) { return obj.find("li:eq(0)"); }
				else if(obj.nextAll("li").size() > 0) { return obj.nextAll("li:eq(0)"); }
				else { return obj.parentsUntil(".jstree","li").next("li").eq(0); }
			},
			_get_prev		: function (obj, strict) {
				obj = this._get_node(obj);
				if(obj === -1) { return this.get_container().find("> ul > li:last-child"); }
				if(!obj.length) { return false; }
				if(strict) { return (obj.prevAll("li").length > 0) ? obj.prevAll("li:eq(0)") : false; }

				if(obj.prev("li").length) {
					obj = obj.prev("li").eq(0);
					while(obj.hasClass("jstree-open")) { obj = obj.children("ul:eq(0)").children("li:last"); }
					return obj;
				}
				else { var o = obj.parentsUntil(".jstree","li:eq(0)"); return o.length ? o : false; }
			},
			_get_parent		: function (obj) {
				obj = this._get_node(obj);
				if(obj == -1 || !obj.length) { return false; }
				var o = obj.parentsUntil(".jstree", "li:eq(0)");
				return o.length ? o : -1;
			},
			_get_children	: function (obj) {
				obj = this._get_node(obj);
				if(obj === -1) { return this.get_container().children("ul:eq(0)").children("li"); }
				if(!obj.length) { return false; }
				return obj.children("ul:eq(0)").children("li");
			},
			get_path		: function (obj, id_mode) {
				var p = [],
					_this = this;
				obj = this._get_node(obj);
				if(obj === -1 || !obj || !obj.length) { return false; }
				obj.parentsUntil(".jstree", "li").each(function () {
					p.push( id_mode ? this.id : _this.get_text(this) );
				});
				p.reverse();
				p.push( id_mode ? obj.attr("id") : this.get_text(obj) );
				return p;
			},

			// string functions
			_get_string : function (key) {
				return this._get_settings().core.strings[key] || key;
			},

			is_open		: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-open"); },
			is_closed	: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-closed"); },
			is_leaf		: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-leaf"); },
			correct_state	: function (obj) {
				obj = this._get_node(obj);
				if(!obj || obj === -1) { return false; }
				obj.removeClass("jstree-closed jstree-open").addClass("jstree-leaf").children("ul").remove();
				this.__callback({ "obj" : obj });
			},
			// open/close
			open_node	: function (obj, callback, skip_animation) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				if(!obj.hasClass("jstree-closed")) { if(callback) { callback.call(); } return false; }
				var s = skip_animation || is_ie6 ? 0 : this._get_settings().core.animation,
					t = this;
				if(!this._is_loaded(obj)) {
					obj.children("a").addClass("jstree-loading");
					this.load_node(obj, function () { t.open_node(obj, callback, skip_animation); }, callback);
				}
				else {
					if(this._get_settings().core.open_parents) {
						obj.parentsUntil(".jstree",".jstree-closed").each(function () {
							t.open_node(this, false, true);
						});
					}
					if(s) { obj.children("ul").css("display","none"); }
					obj.removeClass("jstree-closed").addClass("jstree-open").children("a").removeClass("jstree-loading");
					if(s) { obj.children("ul").stop(true, true).slideDown(s, function () { this.style.display = ""; t.after_open(obj); }); }
					else { t.after_open(obj); }
					this.__callback({ "obj" : obj });
					if(callback) { callback.call(); }
				}
			},
			after_open	: function (obj) { this.__callback({ "obj" : obj }); },
			close_node	: function (obj, skip_animation) {
				obj = this._get_node(obj);
				var s = skip_animation || is_ie6 ? 0 : this._get_settings().core.animation,
					t = this;
				if(!obj.length || !obj.hasClass("jstree-open")) { return false; }
				if(s) { obj.children("ul").attr("style","display:block !important"); }
				obj.removeClass("jstree-open").addClass("jstree-closed");
				if(s) { obj.children("ul").stop(true, true).slideUp(s, function () { this.style.display = ""; t.after_close(obj); }); }
				else { t.after_close(obj); }
				this.__callback({ "obj" : obj });
			},
			after_close	: function (obj) { this.__callback({ "obj" : obj }); },
			toggle_node	: function (obj) {
				obj = this._get_node(obj);
				if(obj.hasClass("jstree-closed")) { return this.open_node(obj); }
				if(obj.hasClass("jstree-open")) { return this.close_node(obj); }
			},
			open_all	: function (obj, do_animation, original_obj) {
				obj = obj ? this._get_node(obj) : -1;
				if(!obj || obj === -1) { obj = this.get_container_ul(); }
				if(original_obj) { 
					obj = obj.find("li.jstree-closed");
				}
				else {
					original_obj = obj;
					if(obj.is(".jstree-closed")) { obj = obj.find("li.jstree-closed").andSelf(); }
					else { obj = obj.find("li.jstree-closed"); }
				}
				var _this = this;
				obj.each(function () { 
					var __this = this; 
					if(!_this._is_loaded(this)) { _this.open_node(this, function() { _this.open_all(__this, do_animation, original_obj); }, !do_animation); }
					else { _this.open_node(this, false, !do_animation); }
				});
				// so that callback is fired AFTER all nodes are open
				if(original_obj.find('li.jstree-closed').length === 0) { this.__callback({ "obj" : original_obj }); }
			},
			close_all	: function (obj, do_animation) {
				var _this = this;
				obj = obj ? this._get_node(obj) : this.get_container();
				if(!obj || obj === -1) { obj = this.get_container_ul(); }
				obj.find("li.jstree-open").andSelf().each(function () { _this.close_node(this, !do_animation); });
				this.__callback({ "obj" : obj });
			},
			clean_node	: function (obj) {
				obj = obj && obj != -1 ? $(obj) : this.get_container_ul();
				obj = obj.is("li") ? obj.find("li").andSelf() : obj.find("li");
				obj.removeClass("jstree-last")
					.filter("li:last-child").addClass("jstree-last").end()
					.filter(":has(li)")
						.not(".jstree-open").removeClass("jstree-leaf").addClass("jstree-closed");
				obj.not(".jstree-open, .jstree-closed").addClass("jstree-leaf").children("ul").remove();
				this.__callback({ "obj" : obj });
			},
			// rollback
			get_rollback : function () { 
				this.__callback();
				return { i : this.get_index(), h : this.get_container().children("ul").clone(true), d : this.data }; 
			},
			set_rollback : function (html, data) {
				this.get_container().empty().append(html);
				this.data = data;
				this.__callback();
			},
			// Dummy functions to be overwritten by any datastore plugin included
			load_node	: function (obj, s_call, e_call) { this.__callback({ "obj" : obj }); },
			_is_loaded	: function (obj) { return true; },

			// Basic operations: create
			create_node	: function (obj, position, js, callback, is_loaded) {
				obj = this._get_node(obj);
				position = typeof position === "undefined" ? "last" : position;
				var d = $("<li />"),
					s = this._get_settings().core,
					tmp;

				if(obj !== -1 && !obj.length) { return false; }
				if(!is_loaded && !this._is_loaded(obj)) { this.load_node(obj, function () { this.create_node(obj, position, js, callback, true); }); return false; }

				this.__rollback();

				if(typeof js === "string") { js = { "data" : js }; }
				if(!js) { js = {}; }
				if(js.attr) { d.attr(js.attr); }
				if(js.metadata) { d.data(js.metadata); }
				if(js.state) { d.addClass("jstree-" + js.state); }
				if(!js.data) { js.data = this._get_string("new_node"); }
				if(!$.isArray(js.data)) { tmp = js.data; js.data = []; js.data.push(tmp); }
				$.each(js.data, function (i, m) {
					tmp = $("<a />");
					if($.isFunction(m)) { m = m.call(this, js); }
					if(typeof m == "string") { tmp.attr('href','#')[ s.html_titles ? "html" : "text" ](m); }
					else {
						if(!m.attr) { m.attr = {}; }
						if(!m.attr.href) { m.attr.href = '#'; }
						tmp.attr(m.attr)[ s.html_titles ? "html" : "text" ](m.title);
						if(m.language) { tmp.addClass(m.language); }
					}
					tmp.prepend("<ins class='jstree-icon'>&#160;</ins>");
					if(!m.icon && js.icon) { m.icon = js.icon; }
					if(m.icon) { 
						if(m.icon.indexOf("/") === -1) { tmp.children("ins").addClass(m.icon); }
						else { tmp.children("ins").css("background","url('" + m.icon + "') center center no-repeat"); }
					}
					d.append(tmp);
				});
				d.prepend("<ins class='jstree-icon'>&#160;</ins>");
				if(obj === -1) {
					obj = this.get_container();
					if(position === "before") { position = "first"; }
					if(position === "after") { position = "last"; }
				}
				switch(position) {
					case "before": obj.before(d); tmp = this._get_parent(obj); break;
					case "after" : obj.after(d);  tmp = this._get_parent(obj); break;
					case "inside":
					case "first" :
						if(!obj.children("ul").length) { obj.append("<ul />"); }
						obj.children("ul").prepend(d);
						tmp = obj;
						break;
					case "last":
						if(!obj.children("ul").length) { obj.append("<ul />"); }
						obj.children("ul").append(d);
						tmp = obj;
						break;
					default:
						if(!obj.children("ul").length) { obj.append("<ul />"); }
						if(!position) { position = 0; }
						tmp = obj.children("ul").children("li").eq(position);
						if(tmp.length) { tmp.before(d); }
						else { obj.children("ul").append(d); }
						tmp = obj;
						break;
				}
				if(tmp === -1 || tmp.get(0) === this.get_container().get(0)) { tmp = -1; }
				this.clean_node(tmp);
				this.__callback({ "obj" : d, "parent" : tmp });
				if(callback) { callback.call(this, d); }
				return d;
			},
			// Basic operations: rename (deal with text)
			get_text	: function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				var s = this._get_settings().core.html_titles;
				obj = obj.children("a:eq(0)");
				if(s) {
					obj = obj.clone();
					obj.children("INS").remove();
					return obj.html();
				}
				else {
					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
					return obj.nodeValue;
				}
			},
			set_text	: function (obj, val) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				obj = obj.children("a:eq(0)");
				if(this._get_settings().core.html_titles) {
					var tmp = obj.children("INS").clone();
					obj.html(val).prepend(tmp);
					this.__callback({ "obj" : obj, "name" : val });
					return true;
				}
				else {
					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
					this.__callback({ "obj" : obj, "name" : val });
					return (obj.nodeValue = val);
				}
			},
			rename_node : function (obj, val) {
				obj = this._get_node(obj);
				this.__rollback();
				if(obj && obj.length && this.set_text.apply(this, Array.prototype.slice.call(arguments))) { this.__callback({ "obj" : obj, "name" : val }); }
			},
			// Basic operations: deleting nodes
			delete_node : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				this.__rollback();
				var p = this._get_parent(obj), prev = $([]), t = this;
				obj.each(function () {
					prev = prev.add(t._get_prev(this));
				});
				obj = obj.detach();
				if(p !== -1 && p.find("> ul > li").length === 0) {
					p.removeClass("jstree-open jstree-closed").addClass("jstree-leaf");
				}
				this.clean_node(p);
				this.__callback({ "obj" : obj, "prev" : prev, "parent" : p });
				return obj;
			},
			prepare_move : function (o, r, pos, cb, is_cb) {
				var p = {};

				p.ot = $.jstree._reference(o) || this;
				p.o = p.ot._get_node(o);
				p.r = r === - 1 ? -1 : this._get_node(r);
				p.p = (typeof pos === "undefined" || pos === false) ? "last" : pos; // TODO: move to a setting
				if(!is_cb && prepared_move.o && prepared_move.o[0] === p.o[0] && prepared_move.r[0] === p.r[0] && prepared_move.p === p.p) {
					this.__callback(prepared_move);
					if(cb) { cb.call(this, prepared_move); }
					return;
				}
				p.ot = $.jstree._reference(p.o) || this;
				p.rt = $.jstree._reference(p.r) || this; // r === -1 ? p.ot : $.jstree._reference(p.r) || this
				if(p.r === -1 || !p.r) {
					p.cr = -1;
					switch(p.p) {
						case "first":
						case "before":
						case "inside":
							p.cp = 0; 
							break;
						case "after":
						case "last":
							p.cp = p.rt.get_container().find(" > ul > li").length; 
							break;
						default:
							p.cp = p.p;
							break;
					}
				}
				else {
					if(!/^(before|after)$/.test(p.p) && !this._is_loaded(p.r)) {
						return this.load_node(p.r, function () { this.prepare_move(o, r, pos, cb, true); });
					}
					switch(p.p) {
						case "before":
							p.cp = p.r.index();
							p.cr = p.rt._get_parent(p.r);
							break;
						case "after":
							p.cp = p.r.index() + 1;
							p.cr = p.rt._get_parent(p.r);
							break;
						case "inside":
						case "first":
							p.cp = 0;
							p.cr = p.r;
							break;
						case "last":
							p.cp = p.r.find(" > ul > li").length; 
							p.cr = p.r;
							break;
						default: 
							p.cp = p.p;
							p.cr = p.r;
							break;
					}
				}
				p.np = p.cr == -1 ? p.rt.get_container() : p.cr;
				p.op = p.ot._get_parent(p.o);
				p.cop = p.o.index();
				if(p.op === -1) { p.op = p.ot ? p.ot.get_container() : this.get_container(); }
				if(!/^(before|after)$/.test(p.p) && p.op && p.np && p.op[0] === p.np[0] && p.o.index() < p.cp) { p.cp++; }
				//if(p.p === "before" && p.op && p.np && p.op[0] === p.np[0] && p.o.index() < p.cp) { p.cp--; }
				p.or = p.np.find(" > ul > li:nth-child(" + (p.cp + 1) + ")");
				prepared_move = p;
				this.__callback(prepared_move);
				if(cb) { cb.call(this, prepared_move); }
			},
			check_move : function () {
				var obj = prepared_move, ret = true, r = obj.r === -1 ? this.get_container() : obj.r;
				if(!obj || !obj.o || obj.or[0] === obj.o[0]) { return false; }
				if(!obj.cy) {
					if(obj.op && obj.np && obj.op[0] === obj.np[0] && obj.cp - 1 === obj.o.index()) { return false; }
					obj.o.each(function () { 
						if(r.parentsUntil(".jstree", "li").andSelf().index(this) !== -1) { ret = false; return false; }
					});
				}
				return ret;
			},
			move_node : function (obj, ref, position, is_copy, is_prepared, skip_check) {
				if(!is_prepared) { 
					return this.prepare_move(obj, ref, position, function (p) {
						this.move_node(p, false, false, is_copy, true, skip_check);
					});
				}
				if(is_copy) { 
					prepared_move.cy = true;
				}
				if(!skip_check && !this.check_move()) { return false; }

				this.__rollback();
				var o = false;
				if(is_copy) {
					o = obj.o.clone(true);
					o.find("*[id]").andSelf().each(function () {
						if(this.id) { this.id = "copy_" + this.id; }
					});
				}
				else { o = obj.o; }

				if(obj.or.length) { obj.or.before(o); }
				else { 
					if(!obj.np.children("ul").length) { $("<ul />").appendTo(obj.np); }
					obj.np.children("ul:eq(0)").append(o); 
				}

				try { 
					obj.ot.clean_node(obj.op);
					obj.rt.clean_node(obj.np);
					if(!obj.op.find("> ul > li").length) {
						obj.op.removeClass("jstree-open jstree-closed").addClass("jstree-leaf").children("ul").remove();
					}
				} catch (e) { }

				if(is_copy) { 
					prepared_move.cy = true;
					prepared_move.oc = o; 
				}
				this.__callback(prepared_move);
				return prepared_move;
			},
			_get_move : function () { return prepared_move; }
		}
	});
})(jQuery);
//*/

/* 
 * jsTree ui plugin
 * This plugins handles selecting/deselecting/hovering/dehovering nodes
 */
(function ($) {
	var scrollbar_width, e1, e2;
	$(function() {
		if (/msie/.test(navigator.userAgent.toLowerCase())) {
			e1 = $('<textarea cols="10" rows="2"></textarea>').css({ position: 'absolute', top: -1000, left: 0 }).appendTo('body');
			e2 = $('<textarea cols="10" rows="2" style="overflow: hidden;"></textarea>').css({ position: 'absolute', top: -1000, left: 0 }).appendTo('body');
			scrollbar_width = e1.width() - e2.width();
			e1.add(e2).remove();
		} 
		else {
			e1 = $('<div />').css({ width: 100, height: 100, overflow: 'auto', position: 'absolute', top: -1000, left: 0 })
					.prependTo('body').append('<div />').find('div').css({ width: '100%', height: 200 });
			scrollbar_width = 100 - e1.width();
			e1.parent().remove();
		}
	});
	$.jstree.plugin("ui", {
		__init : function () { 
			this.data.ui.selected = $(); 
			this.data.ui.last_selected = false; 
			this.data.ui.hovered = null;
			this.data.ui.to_select = this.get_settings().ui.initially_select;

			this.get_container()
				.delegate("a", "click.jstree", $.proxy(function (event) {
						event.preventDefault();
						event.currentTarget.blur();
						if(!$(event.currentTarget).hasClass("jstree-loading")) {
							this.select_node(event.currentTarget, true, event);
						}
					}, this))
				.delegate("a", "mouseenter.jstree", $.proxy(function (event) {
						if(!$(event.currentTarget).hasClass("jstree-loading")) {
							this.hover_node(event.target);
						}
					}, this))
				.delegate("a", "mouseleave.jstree", $.proxy(function (event) {
						if(!$(event.currentTarget).hasClass("jstree-loading")) {
							this.dehover_node(event.target);
						}
					}, this))
				.bind("reopen.jstree", $.proxy(function () { 
						this.reselect();
					}, this))
				.bind("get_rollback.jstree", $.proxy(function () { 
						this.dehover_node();
						this.save_selected();
					}, this))
				.bind("set_rollback.jstree", $.proxy(function () { 
						this.reselect();
					}, this))
				.bind("close_node.jstree", $.proxy(function (event, data) { 
						var s = this._get_settings().ui,
							obj = this._get_node(data.rslt.obj),
							clk = (obj && obj.length) ? obj.children("ul").find("a.jstree-clicked") : $(),
							_this = this;
						if(s.selected_parent_close === false || !clk.length) { return; }
						clk.each(function () { 
							_this.deselect_node(this);
							if(s.selected_parent_close === "select_parent") { _this.select_node(obj); }
						});
					}, this))
				.bind("delete_node.jstree", $.proxy(function (event, data) { 
						var s = this._get_settings().ui.select_prev_on_delete,
							obj = this._get_node(data.rslt.obj),
							clk = (obj && obj.length) ? obj.find("a.jstree-clicked") : [],
							_this = this;
						clk.each(function () { _this.deselect_node(this); });
						if(s && clk.length) { 
							data.rslt.prev.each(function () { 
								if(this.parentNode) { _this.select_node(this); return false; /* if return false is removed all prev nodes will be selected */}
							});
						}
					}, this))
				.bind("move_node.jstree", $.proxy(function (event, data) { 
						if(data.rslt.cy) { 
							data.rslt.oc.find("a.jstree-clicked").removeClass("jstree-clicked");
						}
					}, this));
		},
		defaults : {
			select_limit : -1, // 0, 1, 2 ... or -1 for unlimited
			select_multiple_modifier : "ctrl", // on, or ctrl, shift, alt
			select_range_modifier : "shift",
			selected_parent_close : "select_parent", // false, "deselect", "select_parent"
			selected_parent_open : true,
			select_prev_on_delete : true,
			disable_selecting_children : false,
			initially_select : []
		},
		_fn : { 
			_get_node : function (obj, allow_multiple) {
				if(typeof obj === "undefined" || obj === null) { return allow_multiple ? this.data.ui.selected : this.data.ui.last_selected; }
				var $obj = $(obj, this.get_container()); 
				if($obj.is(".jstree") || obj == -1) { return -1; } 
				$obj = $obj.closest("li", this.get_container()); 
				return $obj.length ? $obj : false; 
			},
			_ui_notify : function (n, data) {
				if(data.selected) {
					this.select_node(n, false);
				}
			},
			save_selected : function () {
				var _this = this;
				this.data.ui.to_select = [];
				this.data.ui.selected.each(function () { if(this.id) { _this.data.ui.to_select.push("#" + this.id.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:")); } });
				this.__callback(this.data.ui.to_select);
			},
			reselect : function () {
				var _this = this,
					s = this.data.ui.to_select;
				s = $.map($.makeArray(s), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"); });
				// this.deselect_all(); WHY deselect, breaks plugin state notifier?
				$.each(s, function (i, val) { if(val && val !== "#") { _this.select_node(val); } });
				this.data.ui.selected = this.data.ui.selected.filter(function () { return this.parentNode; });
				this.__callback();
			},
			refresh : function (obj) {
				this.save_selected();
				return this.__call_old();
			},
			hover_node : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				//if(this.data.ui.hovered && obj.get(0) === this.data.ui.hovered.get(0)) { return; }
				if(!obj.hasClass("jstree-hovered")) { this.dehover_node(); }
				this.data.ui.hovered = obj.children("a").addClass("jstree-hovered").parent();
				this._fix_scroll(obj);
				this.__callback({ "obj" : obj });
			},
			dehover_node : function () {
				var obj = this.data.ui.hovered, p;
				if(!obj || !obj.length) { return false; }
				p = obj.children("a").removeClass("jstree-hovered").parent();
				if(this.data.ui.hovered[0] === p[0]) { this.data.ui.hovered = null; }
				this.__callback({ "obj" : obj });
			},
			select_node : function (obj, check, e) {
				obj = this._get_node(obj);
				if(obj == -1 || !obj || !obj.length) { return false; }
				var s = this._get_settings().ui,
					is_multiple = (s.select_multiple_modifier == "on" || (s.select_multiple_modifier !== false && e && e[s.select_multiple_modifier + "Key"])),
					is_range = (s.select_range_modifier !== false && e && e[s.select_range_modifier + "Key"] && this.data.ui.last_selected && this.data.ui.last_selected[0] !== obj[0] && this.data.ui.last_selected.parent()[0] === obj.parent()[0]),
					is_selected = this.is_selected(obj),
					proceed = true,
					t = this;
				if(check) {
					if(s.disable_selecting_children && is_multiple && 
						(
							(obj.parentsUntil(".jstree","li").children("a.jstree-clicked").length) ||
							(obj.children("ul").find("a.jstree-clicked:eq(0)").length)
						)
					) {
						return false;
					}
					proceed = false;
					switch(!0) {
						case (is_range):
							this.data.ui.last_selected.addClass("jstree-last-selected");
							obj = obj[ obj.index() < this.data.ui.last_selected.index() ? "nextUntil" : "prevUntil" ](".jstree-last-selected").andSelf();
							if(s.select_limit == -1 || obj.length < s.select_limit) {
								this.data.ui.last_selected.removeClass("jstree-last-selected");
								this.data.ui.selected.each(function () {
									if(this !== t.data.ui.last_selected[0]) { t.deselect_node(this); }
								});
								is_selected = false;
								proceed = true;
							}
							else {
								proceed = false;
							}
							break;
						case (is_selected && !is_multiple): 
							this.deselect_all();
							is_selected = false;
							proceed = true;
							break;
						case (!is_selected && !is_multiple): 
							if(s.select_limit == -1 || s.select_limit > 0) {
								this.deselect_all();
								proceed = true;
							}
							break;
						case (is_selected && is_multiple): 
							this.deselect_node(obj);
							break;
						case (!is_selected && is_multiple): 
							if(s.select_limit == -1 || this.data.ui.selected.length + 1 <= s.select_limit) { 
								proceed = true;
							}
							break;
					}
				}
				if(proceed && !is_selected) {
					if(!is_range) { this.data.ui.last_selected = obj; }
					obj.children("a").addClass("jstree-clicked");
					if(s.selected_parent_open) {
						obj.parents(".jstree-closed").each(function () { t.open_node(this, false, true); });
					}
					this.data.ui.selected = this.data.ui.selected.add(obj);
					this._fix_scroll(obj.eq(0));
					this.__callback({ "obj" : obj, "e" : e });
				}
			},
			_fix_scroll : function (obj) {
				var c = this.get_container()[0], t;
				if(c.scrollHeight > c.offsetHeight) {
					obj = this._get_node(obj);
					if(!obj || obj === -1 || !obj.length || !obj.is(":visible")) { return; }
					t = obj.offset().top - this.get_container().offset().top;
					if(t < 0) { 
						c.scrollTop = c.scrollTop + t - 1; 
					}
					if(t + this.data.core.li_height + (c.scrollWidth > c.offsetWidth ? scrollbar_width : 0) > c.offsetHeight) { 
						c.scrollTop = c.scrollTop + (t - c.offsetHeight + this.data.core.li_height + 1 + (c.scrollWidth > c.offsetWidth ? scrollbar_width : 0)); 
					}
				}
			},
			deselect_node : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				if(this.is_selected(obj)) {
					obj.children("a").removeClass("jstree-clicked");
					this.data.ui.selected = this.data.ui.selected.not(obj);
					if(this.data.ui.last_selected.get(0) === obj.get(0)) { this.data.ui.last_selected = this.data.ui.selected.eq(0); }
					this.__callback({ "obj" : obj });
				}
			},
			toggle_select : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				if(this.is_selected(obj)) { this.deselect_node(obj); }
				else { this.select_node(obj); }
			},
			is_selected : function (obj) { return this.data.ui.selected.index(this._get_node(obj)) >= 0; },
			get_selected : function (context) { 
				return context ? $(context).find("a.jstree-clicked").parent() : this.data.ui.selected; 
			},
			deselect_all : function (context) {
				var ret = context ? $(context).find("a.jstree-clicked").parent() : this.get_container().find("a.jstree-clicked").parent();
				ret.children("a.jstree-clicked").removeClass("jstree-clicked");
				this.data.ui.selected = $([]);
				this.data.ui.last_selected = false;
				this.__callback({ "obj" : ret });
			}
		}
	});
	// include the selection plugin by default
	$.jstree.defaults.plugins.push("ui");
})(jQuery);
//*/

/* 
 * jsTree CRRM plugin
 * Handles creating/renaming/removing/moving nodes by user interaction.
 */
(function ($) {
	$.jstree.plugin("crrm", { 
		__init : function () {
			this.get_container()
				.bind("move_node.jstree", $.proxy(function (e, data) {
					if(this._get_settings().crrm.move.open_onmove) {
						var t = this;
						data.rslt.np.parentsUntil(".jstree").andSelf().filter(".jstree-closed").each(function () {
							t.open_node(this, false, true);
						});
					}
				}, this));
		},
		defaults : {
			input_width_limit : 200,
			move : {
				always_copy			: false, // false, true or "multitree"
				open_onmove			: true,
				default_position	: "last",
				check_move			: function (m) { return true; }
			}
		},
		_fn : {
			_show_input : function (obj, callback) {
				obj = this._get_node(obj);
				var rtl = this._get_settings().core.rtl,
					w = this._get_settings().crrm.input_width_limit,
					w1 = obj.children("ins").width(),
					w2 = obj.find("> a:visible > ins").width() * obj.find("> a:visible > ins").length,
					t = this.get_text(obj),
					h1 = $("<div />", { css : { "position" : "absolute", "top" : "-200px", "left" : (rtl ? "0px" : "-1000px"), "visibility" : "hidden" } }).appendTo("body"),
					h2 = obj.css("position","relative").append(
					$("<input />", { 
						"value" : t,
						"class" : "jstree-rename-input",
						// "size" : t.length,
						"css" : {
							"padding" : "0",
							"border" : "1px solid silver",
							"position" : "absolute",
							"left"  : (rtl ? "auto" : (w1 + w2 + 4) + "px"),
							"right" : (rtl ? (w1 + w2 + 4) + "px" : "auto"),
							"top" : "0px",
							"height" : (this.data.core.li_height - 2) + "px",
							"lineHeight" : (this.data.core.li_height - 2) + "px",
							"width" : "150px" // will be set a bit further down
						},
						"blur" : $.proxy(function () {
							var i = obj.children(".jstree-rename-input"),
								v = i.val();
							if(v === "") { v = t; }
							h1.remove();
							i.remove(); // rollback purposes
							this.set_text(obj,t); // rollback purposes
							this.rename_node(obj, v);
							callback.call(this, obj, v, t);
							obj.css("position","");
						}, this),
						"keyup" : function (event) {
							var key = event.keyCode || event.which;
							if(key == 27) { this.value = t; this.blur(); return; }
							else if(key == 13) { this.blur(); return; }
							else {
								h2.width(Math.min(h1.text("pW" + this.value).width(),w));
							}
						},
						"keypress" : function(event) {
							var key = event.keyCode || event.which;
							if(key == 13) { return false; }
						}
					})
				).children(".jstree-rename-input"); 
				this.set_text(obj, "");
				h1.css({
						fontFamily		: h2.css('fontFamily')		|| '',
						fontSize		: h2.css('fontSize')		|| '',
						fontWeight		: h2.css('fontWeight')		|| '',
						fontStyle		: h2.css('fontStyle')		|| '',
						fontStretch		: h2.css('fontStretch')		|| '',
						fontVariant		: h2.css('fontVariant')		|| '',
						letterSpacing	: h2.css('letterSpacing')	|| '',
						wordSpacing		: h2.css('wordSpacing')		|| ''
				});
				h2.width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();
			},
			rename : function (obj) {
				obj = this._get_node(obj);
				this.__rollback();
				var f = this.__callback;
				this._show_input(obj, function (obj, new_name, old_name) { 
					f.call(this, { "obj" : obj, "new_name" : new_name, "old_name" : old_name });
				});
			},
			create : function (obj, position, js, callback, skip_rename) {
				var t, _this = this;
				obj = this._get_node(obj);
				if(!obj) { obj = -1; }
				this.__rollback();
				t = this.create_node(obj, position, js, function (t) {
					var p = this._get_parent(t),
						pos = $(t).index();
					if(callback) { callback.call(this, t); }
					if(p.length && p.hasClass("jstree-closed")) { this.open_node(p, false, true); }
					if(!skip_rename) { 
						this._show_input(t, function (obj, new_name, old_name) { 
							_this.__callback({ "obj" : obj, "name" : new_name, "parent" : p, "position" : pos });
						});
					}
					else { _this.__callback({ "obj" : t, "name" : this.get_text(t), "parent" : p, "position" : pos }); }
				});
				return t;
			},
			remove : function (obj) {
				obj = this._get_node(obj, true);
				var p = this._get_parent(obj), prev = this._get_prev(obj);
				this.__rollback();
				obj = this.delete_node(obj);
				if(obj !== false) { this.__callback({ "obj" : obj, "prev" : prev, "parent" : p }); }
			},
			check_move : function () {
				if(!this.__call_old()) { return false; }
				var s = this._get_settings().crrm.move;
				if(!s.check_move.call(this, this._get_move())) { return false; }
				return true;
			},
			move_node : function (obj, ref, position, is_copy, is_prepared, skip_check) {
				var s = this._get_settings().crrm.move;
				if(!is_prepared) { 
					if(typeof position === "undefined") { position = s.default_position; }
					if(position === "inside" && !s.default_position.match(/^(before|after)$/)) { position = s.default_position; }
					return this.__call_old(true, obj, ref, position, is_copy, false, skip_check);
				}
				// if the move is already prepared
				if(s.always_copy === true || (s.always_copy === "multitree" && obj.rt.get_index() !== obj.ot.get_index() )) {
					is_copy = true;
				}
				this.__call_old(true, obj, ref, position, is_copy, true, skip_check);
			},

			cut : function (obj) {
				obj = this._get_node(obj, true);
				if(!obj || !obj.length) { return false; }
				this.data.crrm.cp_nodes = false;
				this.data.crrm.ct_nodes = obj;
				this.__callback({ "obj" : obj });
			},
			copy : function (obj) {
				obj = this._get_node(obj, true);
				if(!obj || !obj.length) { return false; }
				this.data.crrm.ct_nodes = false;
				this.data.crrm.cp_nodes = obj;
				this.__callback({ "obj" : obj });
			},
			paste : function (obj) { 
				obj = this._get_node(obj);
				if(!obj || !obj.length) { return false; }
				var nodes = this.data.crrm.ct_nodes ? this.data.crrm.ct_nodes : this.data.crrm.cp_nodes;
				if(!this.data.crrm.ct_nodes && !this.data.crrm.cp_nodes) { return false; }
				if(this.data.crrm.ct_nodes) { this.move_node(this.data.crrm.ct_nodes, obj); this.data.crrm.ct_nodes = false; }
				if(this.data.crrm.cp_nodes) { this.move_node(this.data.crrm.cp_nodes, obj, false, true); }
				this.__callback({ "obj" : obj, "nodes" : nodes });
			}
		}
	});
	// include the crr plugin by default
	// $.jstree.defaults.plugins.push("crrm");
})(jQuery);
//*/

/* 
 * jsTree themes plugin
 * Handles loading and setting themes, as well as detecting path to themes, etc.
 */
(function ($) {
	var themes_loaded = [];
	// this variable stores the path to the themes folder - if left as false - it will be autodetected
	$.jstree._themes = false;
	$.jstree.plugin("themes", {
		__init : function () { 
			this.get_container()
				.bind("init.jstree", $.proxy(function () {
						var s = this._get_settings().themes;
						this.data.themes.dots = s.dots; 
						this.data.themes.icons = s.icons; 
						this.set_theme(s.theme, s.url);
					}, this))
				.bind("loaded.jstree", $.proxy(function () {
						// bound here too, as simple HTML tree's won't honor dots & icons otherwise
						if(!this.data.themes.dots) { this.hide_dots(); }
						else { this.show_dots(); }
						if(!this.data.themes.icons) { this.hide_icons(); }
						else { this.show_icons(); }
					}, this));
		},
		defaults : { 
			theme : "default", 
			url : false,
			dots : true,
			icons : true
		},
		_fn : {
			set_theme : function (theme_name, theme_url) {
				if(!theme_name) { return false; }
				if(!theme_url) { theme_url = $.jstree._themes + theme_name + '/style.css'; }
				if($.inArray(theme_url, themes_loaded) == -1) {
					$.vakata.css.add_sheet({ "url" : theme_url });
					themes_loaded.push(theme_url);
				}
				if(this.data.themes.theme != theme_name) {
					this.get_container().removeClass('jstree-' + this.data.themes.theme);
					this.data.themes.theme = theme_name;
				}
				this.get_container().addClass('jstree-' + theme_name);
				if(!this.data.themes.dots) { this.hide_dots(); }
				else { this.show_dots(); }
				if(!this.data.themes.icons) { this.hide_icons(); }
				else { this.show_icons(); }
				this.__callback();
			},
			get_theme	: function () { return this.data.themes.theme; },

			show_dots	: function () { this.data.themes.dots = true; this.get_container().children("ul").removeClass("jstree-no-dots"); },
			hide_dots	: function () { this.data.themes.dots = false; this.get_container().children("ul").addClass("jstree-no-dots"); },
			toggle_dots	: function () { if(this.data.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },

			show_icons	: function () { this.data.themes.icons = true; this.get_container().children("ul").removeClass("jstree-no-icons"); },
			hide_icons	: function () { this.data.themes.icons = false; this.get_container().children("ul").addClass("jstree-no-icons"); },
			toggle_icons: function () { if(this.data.themes.icons) { this.hide_icons(); } else { this.show_icons(); } }
		}
	});
	// autodetect themes path
	$(function () {
		if($.jstree._themes === false) {
			$("script").each(function () { 
				if(this.src.toString().match(/jquery\.jstree[^\/]*?\.js(\?.*)?$/)) { 
					$.jstree._themes = this.src.toString().replace(/jquery\.jstree[^\/]*?\.js(\?.*)?$/, "") + 'themes/'; 
					return false; 
				}
			});
		}
		if($.jstree._themes === false) { $.jstree._themes = "themes/"; }
	});
	// include the themes plugin by default
	$.jstree.defaults.plugins.push("themes");
})(jQuery);
//*/

/*
 * jsTree hotkeys plugin
 * Enables keyboard navigation for all tree instances
 * Depends on the jstree ui & jquery hotkeys plugins
 */
(function ($) {
	var bound = [];
	function exec(i, event) {
		var f = $.jstree._focused(), tmp;
		if(f && f.data && f.data.hotkeys && f.data.hotkeys.enabled) { 
			tmp = f._get_settings().hotkeys[i];
			if(tmp) { return tmp.call(f, event); }
		}
	}
	$.jstree.plugin("hotkeys", {
		__init : function () {
			if(typeof $.hotkeys === "undefined") { throw "jsTree hotkeys: jQuery hotkeys plugin not included."; }
			if(!this.data.ui) { throw "jsTree hotkeys: jsTree UI plugin not included."; }
			$.each(this._get_settings().hotkeys, function (i, v) {
				if(v !== false && $.inArray(i, bound) == -1) {
					$(document).bind("keydown", i, function (event) { return exec(i, event); });
					bound.push(i);
				}
			});
			this.get_container()
				.bind("lock.jstree", $.proxy(function () {
						if(this.data.hotkeys.enabled) { this.data.hotkeys.enabled = false; this.data.hotkeys.revert = true; }
					}, this))
				.bind("unlock.jstree", $.proxy(function () {
						if(this.data.hotkeys.revert) { this.data.hotkeys.enabled = true; }
					}, this));
			this.enable_hotkeys();
		},
		defaults : {
			"up" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_prev(o));
				return false; 
			},
			"ctrl+up" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_prev(o));
				return false; 
			},
			"shift+up" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_prev(o));
				return false; 
			},
			"down" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_next(o));
				return false;
			},
			"ctrl+down" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_next(o));
				return false;
			},
			"shift+down" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_next(o));
				return false;
			},
			"left" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o) {
					if(o.hasClass("jstree-open")) { this.close_node(o); }
					else { this.hover_node(this._get_prev(o)); }
				}
				return false;
			},
			"ctrl+left" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o) {
					if(o.hasClass("jstree-open")) { this.close_node(o); }
					else { this.hover_node(this._get_prev(o)); }
				}
				return false;
			},
			"shift+left" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o) {
					if(o.hasClass("jstree-open")) { this.close_node(o); }
					else { this.hover_node(this._get_prev(o)); }
				}
				return false;
			},
			"right" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o && o.length) {
					if(o.hasClass("jstree-closed")) { this.open_node(o); }
					else { this.hover_node(this._get_next(o)); }
				}
				return false;
			},
			"ctrl+right" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o && o.length) {
					if(o.hasClass("jstree-closed")) { this.open_node(o); }
					else { this.hover_node(this._get_next(o)); }
				}
				return false;
			},
			"shift+right" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o && o.length) {
					if(o.hasClass("jstree-closed")) { this.open_node(o); }
					else { this.hover_node(this._get_next(o)); }
				}
				return false;
			},
			"space" : function () { 
				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").click(); } 
				return false; 
			},
			"ctrl+space" : function (event) { 
				event.type = "click";
				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").trigger(event); } 
				return false; 
			},
			"shift+space" : function (event) { 
				event.type = "click";
				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").trigger(event); } 
				return false; 
			},
			"f2" : function () { this.rename(this.data.ui.hovered || this.data.ui.last_selected); },
			"del" : function () { this.remove(this.data.ui.hovered || this._get_node(null)); }
		},
		_fn : {
			enable_hotkeys : function () {
				this.data.hotkeys.enabled = true;
			},
			disable_hotkeys : function () {
				this.data.hotkeys.enabled = false;
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree JSON plugin
 * The JSON data store. Datastores are build by overriding the `load_node` and `_is_loaded` functions.
 */
(function ($) {
	$.jstree.plugin("json_data", {
		__init : function() {
			var s = this._get_settings().json_data;
			if(s.progressive_unload) {
				this.get_container().bind("after_close.jstree", function (e, data) {
					data.rslt.obj.children("ul").remove();
				});
			}
		},
		defaults : { 
			// `data` can be a function:
			//  * accepts two arguments - node being loaded and a callback to pass the result to
			//  * will be executed in the current tree's scope & ajax won't be supported
			data : false, 
			ajax : false,
			correct_state : true,
			progressive_render : false,
			progressive_unload : false
		},
		_fn : {
			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_json(obj, function () { _this.__callback({ "obj" : _this._get_node(obj) }); s_call.call(this); }, e_call); },
			_is_loaded : function (obj) { 
				var s = this._get_settings().json_data;
				obj = this._get_node(obj); 
				return obj == -1 || !obj || (!s.ajax && !s.progressive_render && !$.isFunction(s.data)) || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").length > 0;
			},
			refresh : function (obj) {
				obj = this._get_node(obj);
				var s = this._get_settings().json_data;
				if(obj && obj !== -1 && s.progressive_unload && ($.isFunction(s.data) || !!s.ajax)) {
					obj.removeData("jstree_children");
				}
				return this.__call_old();
			},
			load_node_json : function (obj, s_call, e_call) {
				var s = this.get_settings().json_data, d,
					error_func = function () {},
					success_func = function () {};
				obj = this._get_node(obj);

				if(obj && obj !== -1 && (s.progressive_render || s.progressive_unload) && !obj.is(".jstree-open, .jstree-leaf") && obj.children("ul").children("li").length === 0 && obj.data("jstree_children")) {
					d = this._parse_json(obj.data("jstree_children"), obj);
					if(d) {
						obj.append(d);
						if(!s.progressive_unload) { obj.removeData("jstree_children"); }
					}
					this.clean_node(obj);
					if(s_call) { s_call.call(this); }
					return;
				}

				if(obj && obj !== -1) {
					if(obj.data("jstree_is_loading")) { return; }
					else { obj.data("jstree_is_loading",true); }
				}
				switch(!0) {
					case (!s.data && !s.ajax): throw "Neither data nor ajax settings supplied.";
					// function option added here for easier model integration (also supporting async - see callback)
					case ($.isFunction(s.data)):
						s.data.call(this, obj, $.proxy(function (d) {
							d = this._parse_json(d, obj);
							if(!d) { 
								if(obj === -1 || !obj) {
									if(s.correct_state) { this.get_container().children("ul").empty(); }
								}
								else {
									obj.children("a.jstree-loading").removeClass("jstree-loading");
									obj.removeData("jstree_is_loading");
									if(s.correct_state) { this.correct_state(obj); }
								}
								if(e_call) { e_call.call(this); }
							}
							else {
								if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
								else { obj.append(d).children("a.jstree-loading").removeClass("jstree-loading"); obj.removeData("jstree_is_loading"); }
								this.clean_node(obj);
								if(s_call) { s_call.call(this); }
							}
						}, this));
						break;
					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
						if(!obj || obj == -1) {
							d = this._parse_json(s.data, obj);
							if(d) {
								this.get_container().children("ul").empty().append(d.children());
								this.clean_node();
							}
							else { 
								if(s.correct_state) { this.get_container().children("ul").empty(); }
							}
						}
						if(s_call) { s_call.call(this); }
						break;
					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
						error_func = function (x, t, e) {
							var ef = this.get_settings().json_data.ajax.error; 
							if(ef) { ef.call(this, x, t, e); }
							if(obj != -1 && obj.length) {
								obj.children("a.jstree-loading").removeClass("jstree-loading");
								obj.removeData("jstree_is_loading");
								if(t === "success" && s.correct_state) { this.correct_state(obj); }
							}
							else {
								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
							}
							if(e_call) { e_call.call(this); }
						};
						success_func = function (d, t, x) {
							var sf = this.get_settings().json_data.ajax.success; 
							if(sf) { d = sf.call(this,d,t,x) || d; }
							if(d === "" || (d && d.toString && d.toString().replace(/^[\s\n]+$/,"") === "") || (!$.isArray(d) && !$.isPlainObject(d))) {
								return error_func.call(this, x, t, "");
							}
							d = this._parse_json(d, obj);
							if(d) {
								if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
								else { obj.append(d).children("a.jstree-loading").removeClass("jstree-loading"); obj.removeData("jstree_is_loading"); }
								this.clean_node(obj);
								if(s_call) { s_call.call(this); }
							}
							else {
								if(obj === -1 || !obj) {
									if(s.correct_state) { 
										this.get_container().children("ul").empty(); 
										if(s_call) { s_call.call(this); }
									}
								}
								else {
									obj.children("a.jstree-loading").removeClass("jstree-loading");
									obj.removeData("jstree_is_loading");
									if(s.correct_state) { 
										this.correct_state(obj);
										if(s_call) { s_call.call(this); } 
									}
								}
							}
						};
						s.ajax.context = this;
						s.ajax.error = error_func;
						s.ajax.success = success_func;
						if(!s.ajax.dataType) { s.ajax.dataType = "json"; }
						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
						$.ajax(s.ajax);
						break;
				}
			},
			_parse_json : function (js, obj, is_callback) {
				var d = false, 
					p = this._get_settings(),
					s = p.json_data,
					t = p.core.html_titles,
					tmp, i, j, ul1, ul2;

				if(!js) { return d; }
				if(s.progressive_unload && obj && obj !== -1) { 
					obj.data("jstree_children", d);
				}
				if($.isArray(js)) {
					d = $();
					if(!js.length) { return false; }
					for(i = 0, j = js.length; i < j; i++) {
						tmp = this._parse_json(js[i], obj, true);
						if(tmp.length) { d = d.add(tmp); }
					}
				}
				else {
					if(typeof js == "string") { js = { data : js }; }
					if(!js.data && js.data !== "") { return d; }
					d = $("<li />");
					if(js.attr) { d.attr(js.attr); }
					if(js.metadata) { d.data(js.metadata); }
					if(js.state) { d.addClass("jstree-" + js.state); }
					if(!$.isArray(js.data)) { tmp = js.data; js.data = []; js.data.push(tmp); }
					$.each(js.data, function (i, m) {
						tmp = $("<a />");
						if($.isFunction(m)) { m = m.call(this, js); }
						if(typeof m == "string") { tmp.attr('href','#')[ t ? "html" : "text" ](m); }
						else {
							if(!m.attr) { m.attr = {}; }
							if(!m.attr.href) { m.attr.href = '#'; }
							tmp.attr(m.attr)[ t ? "html" : "text" ](m.title);
							if(m.language) { tmp.addClass(m.language); }
						}
						tmp.prepend("<ins class='jstree-icon'>&#160;</ins>");
						if(!m.icon && js.icon) { m.icon = js.icon; }
						if(m.icon) { 
							if(m.icon.indexOf("/") === -1) { tmp.children("ins").addClass(m.icon); }
							else { tmp.children("ins").css("background","url('" + m.icon + "') center center no-repeat"); }
						}
						d.append(tmp);
					});
					d.prepend("<ins class='jstree-icon'>&#160;</ins>");
					if(js.children) { 
						if(s.progressive_render && js.state !== "open") {
							d.addClass("jstree-closed").data("jstree_children", js.children);
						}
						else {
							if(s.progressive_unload) { d.data("jstree_children", js.children); }
							if($.isArray(js.children) && js.children.length) {
								tmp = this._parse_json(js.children, obj, true);
								if(tmp.length) {
									ul2 = $("<ul />");
									ul2.append(tmp);
									d.append(ul2);
								}
							}
						}
					}
				}
				if(!is_callback) {
					ul1 = $("<ul />");
					ul1.append(d);
					d = ul1;
				}
				return d;
			},
			get_json : function (obj, li_attr, a_attr, is_callback) {
				var result = [], 
					s = this._get_settings(), 
					_this = this,
					tmp1, tmp2, li, a, t, lang;
				obj = this._get_node(obj);
				if(!obj || obj === -1) { obj = this.get_container().find("> ul > li"); }
				li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];
				if(!is_callback && this.data.types) { li_attr.push(s.types.type_attr); }
				a_attr = $.isArray(a_attr) ? a_attr : [ ];

				obj.each(function () {
					li = $(this);
					tmp1 = { data : [] };
					if(li_attr.length) { tmp1.attr = { }; }
					$.each(li_attr, function (i, v) { 
						tmp2 = li.attr(v); 
						if(tmp2 && tmp2.length && tmp2.replace(/jstree[^ ]*/ig,'').length) {
							tmp1.attr[v] = (" " + tmp2).replace(/ jstree[^ ]*/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,""); 
						}
					});
					if(li.hasClass("jstree-open")) { tmp1.state = "open"; }
					if(li.hasClass("jstree-closed")) { tmp1.state = "closed"; }
					if(li.data()) { tmp1.metadata = li.data(); }
					a = li.children("a");
					a.each(function () {
						t = $(this);
						if(
							a_attr.length || 
							$.inArray("languages", s.plugins) !== -1 || 
							t.children("ins").get(0).style.backgroundImage.length || 
							(t.children("ins").get(0).className && t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').length)
						) { 
							lang = false;
							if($.inArray("languages", s.plugins) !== -1 && $.isArray(s.languages) && s.languages.length) {
								$.each(s.languages, function (l, lv) {
									if(t.hasClass(lv)) {
										lang = lv;
										return false;
									}
								});
							}
							tmp2 = { attr : { }, title : _this.get_text(t, lang) }; 
							$.each(a_attr, function (k, z) {
								tmp2.attr[z] = (" " + (t.attr(z) || "")).replace(/ jstree[^ ]*/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"");
							});
							if($.inArray("languages", s.plugins) !== -1 && $.isArray(s.languages) && s.languages.length) {
								$.each(s.languages, function (k, z) {
									if(t.hasClass(z)) { tmp2.language = z; return true; }
								});
							}
							if(t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"").length) {
								tmp2.icon = t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"");
							}
							if(t.children("ins").get(0).style.backgroundImage.length) {
								tmp2.icon = t.children("ins").get(0).style.backgroundImage.replace("url(","").replace(")","");
							}
						}
						else {
							tmp2 = _this.get_text(t);
						}
						if(a.length > 1) { tmp1.data.push(tmp2); }
						else { tmp1.data = tmp2; }
					});
					li = li.find("> ul > li");
					if(li.length) { tmp1.children = _this.get_json(li, li_attr, a_attr, true); }
					result.push(tmp1);
				});
				return result;
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree languages plugin
 * Adds support for multiple language versions in one tree
 * This basically allows for many titles coexisting in one node, but only one of them being visible at any given time
 * This is useful for maintaining the same structure in many languages (hence the name of the plugin)
 */
(function ($) {
	var sh = false;
	$.jstree.plugin("languages", {
		__init : function () { this._load_css();  },
		defaults : [],
		_fn : {
			set_lang : function (i) { 
				var langs = this._get_settings().languages,
					st = false,
					selector = ".jstree-" + this.get_index() + ' a';
				if(!$.isArray(langs) || langs.length === 0) { return false; }
				if($.inArray(i,langs) == -1) {
					if(!!langs[i]) { i = langs[i]; }
					else { return false; }
				}
				if(i == this.data.languages.current_language) { return true; }
				st = $.vakata.css.get_css(selector + "." + this.data.languages.current_language, false, sh);
				if(st !== false) { st.style.display = "none"; }
				st = $.vakata.css.get_css(selector + "." + i, false, sh);
				if(st !== false) { st.style.display = ""; }
				this.data.languages.current_language = i;
				this.__callback(i);
				return true;
			},
			get_lang : function () {
				return this.data.languages.current_language;
			},
			_get_string : function (key, lang) {
				var langs = this._get_settings().languages,
					s = this._get_settings().core.strings;
				if($.isArray(langs) && langs.length) {
					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
				}
				if(s[lang] && s[lang][key]) { return s[lang][key]; }
				if(s[key]) { return s[key]; }
				return key;
			},
			get_text : function (obj, lang) {
				obj = this._get_node(obj) || this.data.ui.last_selected;
				if(!obj.size()) { return false; }
				var langs = this._get_settings().languages,
					s = this._get_settings().core.html_titles;
				if($.isArray(langs) && langs.length) {
					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
					obj = obj.children("a." + lang);
				}
				else { obj = obj.children("a:eq(0)"); }
				if(s) {
					obj = obj.clone();
					obj.children("INS").remove();
					return obj.html();
				}
				else {
					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
					return obj.nodeValue;
				}
			},
			set_text : function (obj, val, lang) {
				obj = this._get_node(obj) || this.data.ui.last_selected;
				if(!obj.size()) { return false; }
				var langs = this._get_settings().languages,
					s = this._get_settings().core.html_titles,
					tmp;
				if($.isArray(langs) && langs.length) {
					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
					obj = obj.children("a." + lang);
				}
				else { obj = obj.children("a:eq(0)"); }
				if(s) {
					tmp = obj.children("INS").clone();
					obj.html(val).prepend(tmp);
					this.__callback({ "obj" : obj, "name" : val, "lang" : lang });
					return true;
				}
				else {
					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
					this.__callback({ "obj" : obj, "name" : val, "lang" : lang });
					return (obj.nodeValue = val);
				}
			},
			_load_css : function () {
				var langs = this._get_settings().languages,
					str = "/* languages css */",
					selector = ".jstree-" + this.get_index() + ' a',
					ln;
				if($.isArray(langs) && langs.length) {
					this.data.languages.current_language = langs[0];
					for(ln = 0; ln < langs.length; ln++) {
						str += selector + "." + langs[ln] + " {";
						if(langs[ln] != this.data.languages.current_language) { str += " display:none; "; }
						str += " } ";
					}
					sh = $.vakata.css.add_sheet({ 'str' : str, 'title' : "jstree-languages" });
				}
			},
			create_node : function (obj, position, js, callback) {
				var t = this.__call_old(true, obj, position, js, function (t) {
					var langs = this._get_settings().languages,
						a = t.children("a"),
						ln;
					if($.isArray(langs) && langs.length) {
						for(ln = 0; ln < langs.length; ln++) {
							if(!a.is("." + langs[ln])) {
								t.append(a.eq(0).clone().removeClass(langs.join(" ")).addClass(langs[ln]));
							}
						}
						a.not("." + langs.join(", .")).remove();
					}
					if(callback) { callback.call(this, t); }
				});
				return t;
			}
		}
	});
})(jQuery);
//*/

/*
 * jsTree cookies plugin
 * Stores the currently opened/selected nodes in a cookie and then restores them
 * Depends on the jquery.cookie plugin
 */
(function ($) {
	$.jstree.plugin("cookies", {
		__init : function () {
			if(typeof $.cookie === "undefined") { throw "jsTree cookie: jQuery cookie plugin not included."; }

			var s = this._get_settings().cookies,
				tmp;
			if(!!s.save_loaded) {
				tmp = $.cookie(s.save_loaded);
				if(tmp && tmp.length) { this.data.core.to_load = tmp.split(","); }
			}
			if(!!s.save_opened) {
				tmp = $.cookie(s.save_opened);
				if(tmp && tmp.length) { this.data.core.to_open = tmp.split(","); }
			}
			if(!!s.save_selected) {
				tmp = $.cookie(s.save_selected);
				if(tmp && tmp.length && this.data.ui) { this.data.ui.to_select = tmp.split(","); }
			}
			this.get_container()
				.one( ( this.data.ui ? "reselect" : "reopen" ) + ".jstree", $.proxy(function () {
					this.get_container()
						.bind("open_node.jstree close_node.jstree select_node.jstree deselect_node.jstree", $.proxy(function (e) { 
								if(this._get_settings().cookies.auto_save) { this.save_cookie((e.handleObj.namespace + e.handleObj.type).replace("jstree","")); }
							}, this));
				}, this));
		},
		defaults : {
			save_loaded		: "jstree_load",
			save_opened		: "jstree_open",
			save_selected	: "jstree_select",
			auto_save		: true,
			cookie_options	: {}
		},
		_fn : {
			save_cookie : function (c) {
				if(this.data.core.refreshing) { return; }
				var s = this._get_settings().cookies;
				if(!c) { // if called manually and not by event
					if(s.save_loaded) {
						this.save_loaded();
						$.cookie(s.save_loaded, this.data.core.to_load.join(","), s.cookie_options);
					}
					if(s.save_opened) {
						this.save_opened();
						$.cookie(s.save_opened, this.data.core.to_open.join(","), s.cookie_options);
					}
					if(s.save_selected && this.data.ui) {
						this.save_selected();
						$.cookie(s.save_selected, this.data.ui.to_select.join(","), s.cookie_options);
					}
					return;
				}
				switch(c) {
					case "open_node":
					case "close_node":
						if(!!s.save_opened) { 
							this.save_opened(); 
							$.cookie(s.save_opened, this.data.core.to_open.join(","), s.cookie_options); 
						}
						if(!!s.save_loaded) { 
							this.save_loaded(); 
							$.cookie(s.save_loaded, this.data.core.to_load.join(","), s.cookie_options); 
						}
						break;
					case "select_node":
					case "deselect_node":
						if(!!s.save_selected && this.data.ui) { 
							this.save_selected(); 
							$.cookie(s.save_selected, this.data.ui.to_select.join(","), s.cookie_options); 
						}
						break;
				}
			}
		}
	});
	// include cookies by default
	// $.jstree.defaults.plugins.push("cookies");
})(jQuery);
//*/

/*
 * jsTree sort plugin
 * Sorts items alphabetically (or using any other function)
 */
(function ($) {
	$.jstree.plugin("sort", {
		__init : function () {
			this.get_container()
				.bind("load_node.jstree", $.proxy(function (e, data) {
						var obj = this._get_node(data.rslt.obj);
						obj = obj === -1 ? this.get_container().children("ul") : obj.children("ul");
						this.sort(obj);
					}, this))
				.bind("rename_node.jstree create_node.jstree create.jstree", $.proxy(function (e, data) {
						this.sort(data.rslt.obj.parent());
					}, this))
				.bind("move_node.jstree", $.proxy(function (e, data) {
						var m = data.rslt.np == -1 ? this.get_container() : data.rslt.np;
						this.sort(m.children("ul"));
					}, this));
		},
		defaults : function (a, b) { return this.get_text(a) > this.get_text(b) ? 1 : -1; },
		_fn : {
			sort : function (obj) {
				var s = this._get_settings().sort,
					t = this;
				obj.append($.makeArray(obj.children("li")).sort($.proxy(s, t)));
				obj.find("> li > ul").each(function() { t.sort($(this)); });
				this.clean_node(obj);
			}
		}
	});
})(jQuery);
//*/

/*
 * jsTree DND plugin
 * Drag and drop plugin for moving/copying nodes
 */
(function ($) {
	var o = false,
		r = false,
		m = false,
		ml = false,
		sli = false,
		sti = false,
		dir1 = false,
		dir2 = false,
		last_pos = false;
	$.vakata.dnd = {
		is_down : false,
		is_drag : false,
		helper : false,
		scroll_spd : 10,
		init_x : 0,
		init_y : 0,
		threshold : 5,
		helper_left : 5,
		helper_top : 10,
		user_data : {},

		drag_start : function (e, data, html) { 
			if($.vakata.dnd.is_drag) { $.vakata.drag_stop({}); }
			try {
				e.currentTarget.unselectable = "on";
				e.currentTarget.onselectstart = function() { return false; };
				if(e.currentTarget.style) { e.currentTarget.style.MozUserSelect = "none"; }
			} catch(err) { }
			$.vakata.dnd.init_x = e.pageX;
			$.vakata.dnd.init_y = e.pageY;
			$.vakata.dnd.user_data = data;
			$.vakata.dnd.is_down = true;
			$.vakata.dnd.helper = $("<div id='vakata-dragged' />").html(html); //.fadeTo(10,0.25);
			$(document).bind("mousemove", $.vakata.dnd.drag);
			$(document).bind("mouseup", $.vakata.dnd.drag_stop);
			return false;
		},
		drag : function (e) { 
			if(!$.vakata.dnd.is_down) { return; }
			if(!$.vakata.dnd.is_drag) {
				if(Math.abs(e.pageX - $.vakata.dnd.init_x) > 5 || Math.abs(e.pageY - $.vakata.dnd.init_y) > 5) { 
					$.vakata.dnd.helper.appendTo("body");
					$.vakata.dnd.is_drag = true;
					$(document).triggerHandler("drag_start.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
				}
				else { return; }
			}

			// maybe use a scrolling parent element instead of document?
			if(e.type === "mousemove") { // thought of adding scroll in order to move the helper, but mouse poisition is n/a
				var d = $(document), t = d.scrollTop(), l = d.scrollLeft();
				if(e.pageY - t < 20) { 
					if(sti && dir1 === "down") { clearInterval(sti); sti = false; }
					if(!sti) { dir1 = "up"; sti = setInterval(function () { $(document).scrollTop($(document).scrollTop() - $.vakata.dnd.scroll_spd); }, 150); }
				}
				else { 
					if(sti && dir1 === "up") { clearInterval(sti); sti = false; }
				}
				if($(window).height() - (e.pageY - t) < 20) {
					if(sti && dir1 === "up") { clearInterval(sti); sti = false; }
					if(!sti) { dir1 = "down"; sti = setInterval(function () { $(document).scrollTop($(document).scrollTop() + $.vakata.dnd.scroll_spd); }, 150); }
				}
				else { 
					if(sti && dir1 === "down") { clearInterval(sti); sti = false; }
				}

				if(e.pageX - l < 20) {
					if(sli && dir2 === "right") { clearInterval(sli); sli = false; }
					if(!sli) { dir2 = "left"; sli = setInterval(function () { $(document).scrollLeft($(document).scrollLeft() - $.vakata.dnd.scroll_spd); }, 150); }
				}
				else { 
					if(sli && dir2 === "left") { clearInterval(sli); sli = false; }
				}
				if($(window).width() - (e.pageX - l) < 20) {
					if(sli && dir2 === "left") { clearInterval(sli); sli = false; }
					if(!sli) { dir2 = "right"; sli = setInterval(function () { $(document).scrollLeft($(document).scrollLeft() + $.vakata.dnd.scroll_spd); }, 150); }
				}
				else { 
					if(sli && dir2 === "right") { clearInterval(sli); sli = false; }
				}
			}

			$.vakata.dnd.helper.css({ left : (e.pageX + $.vakata.dnd.helper_left) + "px", top : (e.pageY + $.vakata.dnd.helper_top) + "px" });
			$(document).triggerHandler("drag.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
		},
		drag_stop : function (e) {
			if(sli) { clearInterval(sli); }
			if(sti) { clearInterval(sti); }
			$(document).unbind("mousemove", $.vakata.dnd.drag);
			$(document).unbind("mouseup", $.vakata.dnd.drag_stop);
			$(document).triggerHandler("drag_stop.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
			$.vakata.dnd.helper.remove();
			$.vakata.dnd.init_x = 0;
			$.vakata.dnd.init_y = 0;
			$.vakata.dnd.user_data = {};
			$.vakata.dnd.is_down = false;
			$.vakata.dnd.is_drag = false;
		}
	};
	$(function() {
		var css_string = '#vakata-dragged { display:block; margin:0 0 0 0; padding:4px 4px 4px 24px; position:absolute; top:-2000px; line-height:16px; z-index:10000; } ';
		$.vakata.css.add_sheet({ str : css_string, title : "vakata" });
	});

	$.jstree.plugin("dnd", {
		__init : function () {
			this.data.dnd = {
				active : false,
				after : false,
				inside : false,
				before : false,
				off : false,
				prepared : false,
				w : 0,
				to1 : false,
				to2 : false,
				cof : false,
				cw : false,
				ch : false,
				i1 : false,
				i2 : false,
				mto : false
			};
			this.get_container()
				.bind("mouseenter.jstree", $.proxy(function (e) {
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							if(this.data.themes) {
								m.attr("class", "jstree-" + this.data.themes.theme); 
								if(ml) { ml.attr("class", "jstree-" + this.data.themes.theme); }
								$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme);
							}
							//if($(e.currentTarget).find("> ul > li").length === 0) {
							if(e.currentTarget === e.target && $.vakata.dnd.user_data.obj && $($.vakata.dnd.user_data.obj).length && $($.vakata.dnd.user_data.obj).parents(".jstree:eq(0)")[0] !== e.target) { // node should not be from the same tree
								var tr = $.jstree._reference(e.target), dc;
								if(tr.data.dnd.foreign) {
									dc = tr._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : tr.get_container(), is_root : true });
									if(dc === true || dc.inside === true || dc.before === true || dc.after === true) {
										$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
									}
								}
								else {
									tr.prepare_move(o, tr.get_container(), "last");
									if(tr.check_move()) {
										$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
									}
								}
							}
						}
					}, this))
				.bind("mouseup.jstree", $.proxy(function (e) {
						//if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && $(e.currentTarget).find("> ul > li").length === 0) {
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && e.currentTarget === e.target && $.vakata.dnd.user_data.obj && $($.vakata.dnd.user_data.obj).length && $($.vakata.dnd.user_data.obj).parents(".jstree:eq(0)")[0] !== e.target) { // node should not be from the same tree
							var tr = $.jstree._reference(e.currentTarget), dc;
							if(tr.data.dnd.foreign) {
								dc = tr._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : tr.get_container(), is_root : true });
								if(dc === true || dc.inside === true || dc.before === true || dc.after === true) {
									tr._get_settings().dnd.drag_finish.call(this, { "o" : o, "r" : tr.get_container(), is_root : true });
								}
							}
							else {
								tr.move_node(o, tr.get_container(), "last", e[tr._get_settings().dnd.copy_modifier + "Key"]);
							}
						}
					}, this))
				.bind("mouseleave.jstree", $.proxy(function (e) {
						if(e.relatedTarget && e.relatedTarget.id && e.relatedTarget.id === "jstree-marker-line") {
							return false; 
						}
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
							if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
							if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }
							if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }
							if($.vakata.dnd.helper.children("ins").hasClass("jstree-ok")) {
								$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
							}
						}
					}, this))
				.bind("mousemove.jstree", $.proxy(function (e) {
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							var cnt = this.get_container()[0];

							// Horizontal scroll
							if(e.pageX + 24 > this.data.dnd.cof.left + this.data.dnd.cw) {
								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
								this.data.dnd.i1 = setInterval($.proxy(function () { this.scrollLeft += $.vakata.dnd.scroll_spd; }, cnt), 100);
							}
							else if(e.pageX - 24 < this.data.dnd.cof.left) {
								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
								this.data.dnd.i1 = setInterval($.proxy(function () { this.scrollLeft -= $.vakata.dnd.scroll_spd; }, cnt), 100);
							}
							else {
								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
							}

							// Vertical scroll
							if(e.pageY + 24 > this.data.dnd.cof.top + this.data.dnd.ch) {
								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
								this.data.dnd.i2 = setInterval($.proxy(function () { this.scrollTop += $.vakata.dnd.scroll_spd; }, cnt), 100);
							}
							else if(e.pageY - 24 < this.data.dnd.cof.top) {
								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
								this.data.dnd.i2 = setInterval($.proxy(function () { this.scrollTop -= $.vakata.dnd.scroll_spd; }, cnt), 100);
							}
							else {
								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
							}

						}
					}, this))
				.bind("scroll.jstree", $.proxy(function (e) { 
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && m && ml) {
							m.hide();
							ml.hide();
						}
					}, this))
				.delegate("a", "mousedown.jstree", $.proxy(function (e) { 
						if(e.which === 1) {
							this.start_drag(e.currentTarget, e);
							return false;
						}
					}, this))
				.delegate("a", "mouseenter.jstree", $.proxy(function (e) { 
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							this.dnd_enter(e.currentTarget);
						}
					}, this))
				.delegate("a", "mousemove.jstree", $.proxy(function (e) { 
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							if(!r || !r.length || r.children("a")[0] !== e.currentTarget) {
								this.dnd_enter(e.currentTarget);
							}
							if(typeof this.data.dnd.off.top === "undefined") { this.data.dnd.off = $(e.target).offset(); }
							this.data.dnd.w = (e.pageY - (this.data.dnd.off.top || 0)) % this.data.core.li_height;
							if(this.data.dnd.w < 0) { this.data.dnd.w += this.data.core.li_height; }
							this.dnd_show();
						}
					}, this))
				.delegate("a", "mouseleave.jstree", $.proxy(function (e) { 
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							if(e.relatedTarget && e.relatedTarget.id && e.relatedTarget.id === "jstree-marker-line") {
								return false; 
							}
								if(m) { m.hide(); }
								if(ml) { ml.hide(); }
							/*
							var ec = $(e.currentTarget).closest("li"), 
								er = $(e.relatedTarget).closest("li");
							if(er[0] !== ec.prev()[0] && er[0] !== ec.next()[0]) {
								if(m) { m.hide(); }
								if(ml) { ml.hide(); }
							}
							*/
							this.data.dnd.mto = setTimeout( 
								(function (t) { return function () { t.dnd_leave(e); }; })(this),
							0);
						}
					}, this))
				.delegate("a", "mouseup.jstree", $.proxy(function (e) { 
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							this.dnd_finish(e);
						}
					}, this));

			$(document)
				.bind("drag_stop.vakata", $.proxy(function () {
						if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }
						if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }
						if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
						if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
						this.data.dnd.after		= false;
						this.data.dnd.before	= false;
						this.data.dnd.inside	= false;
						this.data.dnd.off		= false;
						this.data.dnd.prepared	= false;
						this.data.dnd.w			= false;
						this.data.dnd.to1		= false;
						this.data.dnd.to2		= false;
						this.data.dnd.i1		= false;
						this.data.dnd.i2		= false;
						this.data.dnd.active	= false;
						this.data.dnd.foreign	= false;
						if(m) { m.css({ "top" : "-2000px" }); }
						if(ml) { ml.css({ "top" : "-2000px" }); }
					}, this))
				.bind("drag_start.vakata", $.proxy(function (e, data) {
						if(data.data.jstree) { 
							var et = $(data.event.target);
							if(et.closest(".jstree").hasClass("jstree-" + this.get_index())) {
								this.dnd_enter(et);
							}
						}
					}, this));
				/*
				.bind("keydown.jstree-" + this.get_index() + " keyup.jstree-" + this.get_index(), $.proxy(function(e) {
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && !this.data.dnd.foreign) {
							var h = $.vakata.dnd.helper.children("ins");
							if(e[this._get_settings().dnd.copy_modifier + "Key"] && h.hasClass("jstree-ok")) {
								h.parent().html(h.parent().html().replace(/ \(Copy\)$/, "") + " (Copy)");
							} 
							else {
								h.parent().html(h.parent().html().replace(/ \(Copy\)$/, ""));
							}
						}
					}, this)); */



			var s = this._get_settings().dnd;
			if(s.drag_target) {
				$(document)
					.delegate(s.drag_target, "mousedown.jstree-" + this.get_index(), $.proxy(function (e) {
						o = e.target;
						$.vakata.dnd.drag_start(e, { jstree : true, obj : e.target }, "<ins class='jstree-icon'></ins>" + $(e.target).text() );
						if(this.data.themes) { 
							if(m) { m.attr("class", "jstree-" + this.data.themes.theme); }
							if(ml) { ml.attr("class", "jstree-" + this.data.themes.theme); }
							$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme); 
						}
						$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
						var cnt = this.get_container();
						this.data.dnd.cof = cnt.offset();
						this.data.dnd.cw = parseInt(cnt.width(),10);
						this.data.dnd.ch = parseInt(cnt.height(),10);
						this.data.dnd.foreign = true;
						e.preventDefault();
					}, this));
			}
			if(s.drop_target) {
				$(document)
					.delegate(s.drop_target, "mouseenter.jstree-" + this.get_index(), $.proxy(function (e) {
							if(this.data.dnd.active && this._get_settings().dnd.drop_check.call(this, { "o" : o, "r" : $(e.target), "e" : e })) {
								$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
							}
						}, this))
					.delegate(s.drop_target, "mouseleave.jstree-" + this.get_index(), $.proxy(function (e) {
							if(this.data.dnd.active) {
								$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
							}
						}, this))
					.delegate(s.drop_target, "mouseup.jstree-" + this.get_index(), $.proxy(function (e) {
							if(this.data.dnd.active && $.vakata.dnd.helper.children("ins").hasClass("jstree-ok")) {
								this._get_settings().dnd.drop_finish.call(this, { "o" : o, "r" : $(e.target), "e" : e });
							}
						}, this));
			}
		},
		defaults : {
			copy_modifier	: "ctrl",
			check_timeout	: 100,
			open_timeout	: 500,
			drop_target		: ".jstree-drop",
			drop_check		: function (data) { return true; },
			drop_finish		: $.noop,
			drag_target		: ".jstree-draggable",
			drag_finish		: $.noop,
			drag_check		: function (data) { return { after : false, before : false, inside : true }; },
			move_requested  : $.noop
		},
		_fn : {
			dnd_prepare : function () {
				if(!r || !r.length) { return; }
				this.data.dnd.off = r.offset();
				if(this._get_settings().core.rtl) {
					this.data.dnd.off.right = this.data.dnd.off.left + r.width();
				}
				if(this.data.dnd.foreign) {
					var a = this._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : r });
					this.data.dnd.after = a.after;
					this.data.dnd.before = a.before;
					this.data.dnd.inside = a.inside;
					this.data.dnd.prepared = true;
					return this.dnd_show();
				}
				this.prepare_move(o, r, "before");
				this.data.dnd.before = this.check_move();
				this.prepare_move(o, r, "after");
				this.data.dnd.after = this.check_move();
				if(this._is_loaded(r)) {
					this.prepare_move(o, r, "inside");
					this.data.dnd.inside = this.check_move();
				}
				else {
					this.data.dnd.inside = false;
				}
				this.data.dnd.prepared = true;
				return this.dnd_show();
			},
			dnd_show : function () {
				if(!this.data.dnd.prepared) { return; }
				var o = ["before","inside","after"],
					r = false,
					rtl = this._get_settings().core.rtl,
					pos;
				if(this.data.dnd.w < this.data.core.li_height/3) { o = ["before","inside","after"]; }
				else if(this.data.dnd.w <= this.data.core.li_height*2/3) {
					o = this.data.dnd.w < this.data.core.li_height/2 ? ["inside","before","after"] : ["inside","after","before"];
				}
				else { o = ["after","inside","before"]; }
				$.each(o, $.proxy(function (i, val) { 
					if(this.data.dnd[val]) {
						$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
						r = val;
						return false;
					}
				}, this));
				if(r === false) { $.vakata.dnd.helper.children("ins").attr("class","jstree-invalid"); }
				
				pos = rtl ? (this.data.dnd.off.right - 18) : (this.data.dnd.off.left + 10);
				switch(r) {
					case "before":
						m.css({ "left" : pos + "px", "top" : (this.data.dnd.off.top - 6) + "px" }).show();
						if(ml) { ml.css({ "left" : (pos + 8) + "px", "top" : (this.data.dnd.off.top - 1) + "px" }).show(); }
						break;
					case "after":
						m.css({ "left" : pos + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height - 6) + "px" }).show();
						if(ml) { ml.css({ "left" : (pos + 8) + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height - 1) + "px" }).show(); }
						break;
					case "inside":
						m.css({ "left" : pos + ( rtl ? -4 : 4) + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height/2 - 5) + "px" }).show();
						if(ml) { ml.hide(); }
						break;
					default:
						m.hide();
						if(ml) { ml.hide(); }
						break;
				}
				last_pos = r;
				return r;
			},
			dnd_open : function () {
				this.data.dnd.to2 = false;
				this.open_node(r, $.proxy(this.dnd_prepare,this), true);
			},
			dnd_finish : function (e) {
				if(this.data.dnd.foreign) {
					if(this.data.dnd.after || this.data.dnd.before || this.data.dnd.inside) {
						this._get_settings().dnd.drag_finish.call(this, { "o" : o, "r" : r, "p" : last_pos });
					}
				}
				else {
					this.dnd_prepare();
					this._get_settings().dnd.move_requested.call(this,
						{ "o" : o, "r" : r, "last_pos" : last_pos, "e" : e[this._get_settings().dnd.copy_modifier + "Key"] });
				}
				o = false;
				r = false;
				m.hide();
				if(ml) { ml.hide(); }
			},
			dnd_enter : function (obj) {
				if(this.data.dnd.mto) { 
					clearTimeout(this.data.dnd.mto);
					this.data.dnd.mto = false;
				}
				var s = this._get_settings().dnd;
				this.data.dnd.prepared = false;
				r = this._get_node(obj);
				if(s.check_timeout) { 
					// do the calculations after a minimal timeout (users tend to drag quickly to the desired location)
					if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }
					this.data.dnd.to1 = setTimeout($.proxy(this.dnd_prepare, this), s.check_timeout); 
				}
				else { 
					this.dnd_prepare(); 
				}
				if(s.open_timeout) { 
					if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }
					if(r && r.length && r.hasClass("jstree-closed")) { 
						// if the node is closed - open it, then recalculate
						this.data.dnd.to2 = setTimeout($.proxy(this.dnd_open, this), s.open_timeout);
					}
				}
				else {
					if(r && r.length && r.hasClass("jstree-closed")) { 
						this.dnd_open();
					}
				}
			},
			dnd_leave : function (e) {
				this.data.dnd.after		= false;
				this.data.dnd.before	= false;
				this.data.dnd.inside	= false;
				$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
				m.hide();
				if(ml) { ml.hide(); }
				if(r && r[0] === e.target.parentNode) {
					if(this.data.dnd.to1) {
						clearTimeout(this.data.dnd.to1);
						this.data.dnd.to1 = false;
					}
					if(this.data.dnd.to2) {
						clearTimeout(this.data.dnd.to2);
						this.data.dnd.to2 = false;
					}
				}
			},
			start_drag : function (obj, e) {
				o = this._get_node(obj);
				if(this.data.ui && this.is_selected(o)) { o = this._get_node(null, true); }
				var dt = o.length > 1 ? this._get_string("multiple_selection") : this.get_text(o),
					cnt = this.get_container();
				if(!this._get_settings().core.html_titles) { dt = dt.replace(/</ig,"&lt;").replace(/>/ig,"&gt;"); }
				$.vakata.dnd.drag_start(e, { jstree : true, obj : o }, "<ins class='jstree-icon'></ins>" + dt );
				if(this.data.themes) { 
					if(m) { m.attr("class", "jstree-" + this.data.themes.theme); }
					if(ml) { ml.attr("class", "jstree-" + this.data.themes.theme); }
					$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme); 
				}
				this.data.dnd.cof = cnt.offset();
				this.data.dnd.cw = parseInt(cnt.width(),10);
				this.data.dnd.ch = parseInt(cnt.height(),10);
				this.data.dnd.active = true;
			}
		}
	});
	$(function() {
		var css_string = '' + 
			'#vakata-dragged ins { display:block; text-decoration:none; width:16px; height:16px; margin:0 0 0 0; padding:0; position:absolute; top:4px; left:4px; ' + 
			' -moz-border-radius:4px; border-radius:4px; -webkit-border-radius:4px; ' +
			'} ' + 
			'#vakata-dragged .jstree-ok { background:green; } ' + 
			'#vakata-dragged .jstree-invalid { background:red; } ' + 
			'#jstree-marker { padding:0; margin:0; font-size:12px; overflow:hidden; height:12px; width:8px; position:absolute; top:-30px; z-index:10001; background-repeat:no-repeat; display:none; background-color:transparent; text-shadow:1px 1px 1px white; color:black; line-height:10px; } ' + 
			'#jstree-marker-line { padding:0; margin:0; line-height:0%; font-size:1px; overflow:hidden; height:1px; width:100px; position:absolute; top:-30px; z-index:10000; background-repeat:no-repeat; display:none; background-color:#456c43; ' + 
			' cursor:pointer; border:1px solid #eeeeee; border-left:0; -moz-box-shadow: 0px 0px 2px #666; -webkit-box-shadow: 0px 0px 2px #666; box-shadow: 0px 0px 2px #666; ' + 
			' -moz-border-radius:1px; border-radius:1px; -webkit-border-radius:1px; ' +
			'}' + 
			'';
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
		m = $("<div />").attr({ id : "jstree-marker" }).hide().html("&raquo;")
			.bind("mouseleave mouseenter", function (e) { 
				m.hide();
				ml.hide();
				e.preventDefault(); 
				e.stopImmediatePropagation(); 
				return false; 
			})
			.appendTo("body");
		ml = $("<div />").attr({ id : "jstree-marker-line" }).hide()
			.bind("mouseup", function (e) { 
				if(r && r.length) { 
					r.children("a").trigger(e); 
					e.preventDefault(); 
					e.stopImmediatePropagation(); 
					return false; 
				} 
			})
			.bind("mouseleave", function (e) { 
				var rt = $(e.relatedTarget);
				if(rt.is(".jstree") || rt.closest(".jstree").length === 0) {
					if(r && r.length) { 
						r.children("a").trigger(e); 
						m.hide();
						ml.hide();
						e.preventDefault(); 
						e.stopImmediatePropagation(); 
						return false; 
					}
				}
			})
			.appendTo("body");
		$(document).bind("drag_start.vakata", function (e, data) {
			if(data.data.jstree) { m.show(); if(ml) { ml.show(); } }
		});
		$(document).bind("drag_stop.vakata", function (e, data) {
			if(data.data.jstree) { m.hide(); if(ml) { ml.hide(); } }
		});
	});
})(jQuery);
//*/

/*
 * jsTree checkbox plugin
 * Inserts checkboxes in front of every node
 * Depends on the ui plugin
 * DOES NOT WORK NICELY WITH MULTITREE DRAG'N'DROP
 */
(function ($) {
	$.jstree.plugin("checkbox", {
		__init : function () {
			this.data.checkbox.noui = this._get_settings().checkbox.override_ui;
			if(this.data.ui && this.data.checkbox.noui) {
				this.select_node = this.deselect_node = this.deselect_all = $.noop;
				this.get_selected = this.get_checked;
			}

			this.get_container()
				.bind("open_node.jstree create_node.jstree clean_node.jstree refresh.jstree", $.proxy(function (e, data) { 
						this._prepare_checkboxes(data.rslt.obj);
					}, this))
				.bind("loaded.jstree", $.proxy(function (e) {
						this._prepare_checkboxes();
					}, this))
				.delegate( (this.data.ui && this.data.checkbox.noui ? "a" : "ins.jstree-checkbox") , "click.jstree", $.proxy(function (e) {
						e.preventDefault();
						if(this._get_node(e.target).hasClass("jstree-checked")) { this.uncheck_node(e.target); }
						else { this.check_node(e.target); }
						if(this.data.ui && this.data.checkbox.noui) {
							this.save_selected();
							if(this.data.cookies) { this.save_cookie("select_node"); }
						}
						else {
							e.stopImmediatePropagation();
							return false;
						}
					}, this));
		},
		defaults : {
			override_ui : false,
			two_state : false,
			real_checkboxes : false,
			checked_parent_open : true,
			real_checkboxes_names : function (n) { return [ ("check_" + (n[0].id || Math.ceil(Math.random() * 10000))) , 1]; }
		},
		__destroy : function () {
			this.get_container()
				.find("input.jstree-real-checkbox").removeClass("jstree-real-checkbox").end()
				.find("ins.jstree-checkbox").remove();
		},
		_fn : {
			_checkbox_notify : function (n, data) {
				if(data.checked) {
					this.check_node(n, false);
				}
			},
			_prepare_checkboxes : function (obj) {
				obj = !obj || obj == -1 ? this.get_container().find("> ul > li") : this._get_node(obj);
				if(obj === false) { return; } // added for removing root nodes
				var c, _this = this, t, ts = this._get_settings().checkbox.two_state, rc = this._get_settings().checkbox.real_checkboxes, rcn = this._get_settings().checkbox.real_checkboxes_names;
				obj.each(function () {
					t = $(this);
					c = t.is("li") && (t.hasClass("jstree-checked") || (rc && t.children(":checked").length)) ? "jstree-checked" : "jstree-unchecked";
					t.find("li").andSelf().each(function () {
						var $t = $(this), nm;
						$t.children("a" + (_this.data.languages ? "" : ":eq(0)") ).not(":has(.jstree-checkbox)").prepend("<ins class='jstree-checkbox'>&#160;</ins>").parent().not(".jstree-checked, .jstree-unchecked").addClass( ts ? "jstree-unchecked" : c );
						if(rc) {
							if(!$t.children(":checkbox").length) {
								nm = rcn.call(_this, $t);
								$t.prepend("<input type='checkbox' class='jstree-real-checkbox' id='" + nm[0] + "' name='" + nm[0] + "' value='" + nm[1] + "' />");
							}
							else {
								$t.children(":checkbox").addClass("jstree-real-checkbox");
							}
						}
						if(!ts) {
							if(c === "jstree-checked" || $t.hasClass("jstree-checked") || $t.children(':checked').length) {
								$t.find("li").andSelf().addClass("jstree-checked").children(":checkbox").prop("checked", true);
							}
						}
						else {
							if($t.hasClass("jstree-checked") || $t.children(':checked').length) {
								$t.addClass("jstree-checked").children(":checkbox").prop("checked", true);
							}
						}
					});
				});
				if(!ts) {
					obj.find(".jstree-checked").parent().parent().each(function () { _this._repair_state(this); }); 
				}
			},
			change_state : function (obj, state) {
				obj = this._get_node(obj);
				var coll = false, rc = this._get_settings().checkbox.real_checkboxes;
				if(!obj || obj === -1) { return false; }
				state = (state === false || state === true) ? state : obj.hasClass("jstree-checked");
				if(this._get_settings().checkbox.two_state) {
					if(state) { 
						obj.removeClass("jstree-checked").addClass("jstree-unchecked"); 
						if(rc) { obj.children(":checkbox").prop("checked", false); }
					}
					else { 
						obj.removeClass("jstree-unchecked").addClass("jstree-checked"); 
						if(rc) { obj.children(":checkbox").prop("checked", true); }
					}
				}
				else {
					if(state) { 
						coll = obj.find("li").andSelf();
						if(!coll.filter(".jstree-checked, .jstree-undetermined").length) { return false; }
						coll.removeClass("jstree-checked jstree-undetermined").addClass("jstree-unchecked"); 
						if(rc) { coll.children(":checkbox").prop("checked", false); }
					}
					else { 
						coll = obj.find("li").andSelf();
						if(!coll.filter(".jstree-unchecked, .jstree-undetermined").length) { return false; }
						coll.removeClass("jstree-unchecked jstree-undetermined").addClass("jstree-checked"); 
						if(rc) { coll.children(":checkbox").prop("checked", true); }
						if(this.data.ui) { this.data.ui.last_selected = obj; }
						this.data.checkbox.last_selected = obj;
					}
					obj.parentsUntil(".jstree", "li").each(function () {
						var $this = $(this);
						if(state) {
							if($this.children("ul").children("li.jstree-checked, li.jstree-undetermined").length) {
								$this.parentsUntil(".jstree", "li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
								if(rc) { $this.parentsUntil(".jstree", "li").andSelf().children(":checkbox").prop("checked", false); }
								return false;
							}
							else {
								$this.removeClass("jstree-checked jstree-undetermined").addClass("jstree-unchecked");
								if(rc) { $this.children(":checkbox").prop("checked", false); }
							}
						}
						else {
							if($this.children("ul").children("li.jstree-unchecked, li.jstree-undetermined").length) {
								$this.parentsUntil(".jstree", "li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
								if(rc) { $this.parentsUntil(".jstree", "li").andSelf().children(":checkbox").prop("checked", false); }
								return false;
							}
							else {
								$this.removeClass("jstree-unchecked jstree-undetermined").addClass("jstree-checked");
								if(rc) { $this.children(":checkbox").prop("checked", true); }
							}
						}
					});
				}
				if(this.data.ui && this.data.checkbox.noui) { this.data.ui.selected = this.get_checked(); }
				this.__callback(obj);
				return true;
			},
			check_node : function (obj) {
				if(this.change_state(obj, false)) { 
					obj = this._get_node(obj);
					if(this._get_settings().checkbox.checked_parent_open) {
						var t = this;
						obj.parents(".jstree-closed").each(function () { t.open_node(this, false, true); });
					}
					this.__callback({ "obj" : obj }); 
				}
			},
			uncheck_node : function (obj) {
				if(this.change_state(obj, true)) { this.__callback({ "obj" : this._get_node(obj) }); }
			},
			check_all : function () {
				var _this = this, 
					coll = this._get_settings().checkbox.two_state ? this.get_container_ul().find("li") : this.get_container_ul().children("li");
				coll.each(function () {
					_this.change_state(this, false);
				});
				this.__callback();
			},
			uncheck_all : function () {
				var _this = this,
					coll = this._get_settings().checkbox.two_state ? this.get_container_ul().find("li") : this.get_container_ul().children("li");
				coll.each(function () {
					_this.change_state(this, true);
				});
				this.__callback();
			},

			is_checked : function(obj) {
				obj = this._get_node(obj);
				return obj.length ? obj.is(".jstree-checked") : false;
			},
			get_checked : function (obj, get_all) {
				obj = !obj || obj === -1 ? this.get_container() : this._get_node(obj);
				return get_all || this._get_settings().checkbox.two_state ? obj.find(".jstree-checked") : obj.find("> ul > .jstree-checked, .jstree-undetermined > ul > .jstree-checked");
			},
			get_unchecked : function (obj, get_all) { 
				obj = !obj || obj === -1 ? this.get_container() : this._get_node(obj);
				return get_all || this._get_settings().checkbox.two_state ? obj.find(".jstree-unchecked") : obj.find("> ul > .jstree-unchecked, .jstree-undetermined > ul > .jstree-unchecked");
			},

			show_checkboxes : function () { this.get_container().children("ul").removeClass("jstree-no-checkboxes"); },
			hide_checkboxes : function () { this.get_container().children("ul").addClass("jstree-no-checkboxes"); },

			_repair_state : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return; }
				if(this._get_settings().checkbox.two_state) {
					obj.find('li').andSelf().not('.jstree-checked').removeClass('jstree-undetermined').addClass('jstree-unchecked').children(':checkbox').prop('checked', true);
					return;
				}
				var rc = this._get_settings().checkbox.real_checkboxes,
					a = obj.find("> ul > .jstree-checked").length,
					b = obj.find("> ul > .jstree-undetermined").length,
					c = obj.find("> ul > li").length;
				if(c === 0) { if(obj.hasClass("jstree-undetermined")) { this.change_state(obj, false); } }
				else if(a === 0 && b === 0) { this.change_state(obj, true); }
				else if(a === c) { this.change_state(obj, false); }
				else { 
					obj.parentsUntil(".jstree","li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
					if(rc) { obj.parentsUntil(".jstree", "li").andSelf().children(":checkbox").prop("checked", false); }
				}
			},
			reselect : function () {
				if(this.data.ui && this.data.checkbox.noui) { 
					var _this = this,
						s = this.data.ui.to_select;
					s = $.map($.makeArray(s), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"); });
					this.deselect_all();
					$.each(s, function (i, val) { _this.check_node(val); });
					this.__callback();
				}
				else { 
					this.__call_old(); 
				}
			},
			save_loaded : function () {
				var _this = this;
				this.data.core.to_load = [];
				this.get_container_ul().find("li.jstree-closed.jstree-undetermined").each(function () {
					if(this.id) { _this.data.core.to_load.push("#" + this.id); }
				});
			}
		}
	});
	$(function() {
		var css_string = '.jstree .jstree-real-checkbox { display:none; } ';
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});
})(jQuery);
//*/

/* 
 * jsTree XML plugin
 * The XML data store. Datastores are build by overriding the `load_node` and `_is_loaded` functions.
 */
(function ($) {
	$.vakata.xslt = function (xml, xsl, callback) {
		var rs = "", xm, xs, processor, support;
		// TODO: IE9 no XSLTProcessor, no document.recalc
		if(document.recalc) {
			xm = document.createElement('xml');
			xs = document.createElement('xml');
			xm.innerHTML = xml;
			xs.innerHTML = xsl;
			$("body").append(xm).append(xs);
			setTimeout( (function (xm, xs, callback) {
				return function () {
					callback.call(null, xm.transformNode(xs.XMLDocument));
					setTimeout( (function (xm, xs) { return function () { $(xm).remove(); $(xs).remove(); }; })(xm, xs), 200);
				};
			})(xm, xs, callback), 100);
			return true;
		}
		if(typeof window.DOMParser !== "undefined" && typeof window.XMLHttpRequest !== "undefined" && typeof window.XSLTProcessor === "undefined") {
			xml = new DOMParser().parseFromString(xml, "text/xml");
			xsl = new DOMParser().parseFromString(xsl, "text/xml");
			// alert(xml.transformNode());
			// callback.call(null, new XMLSerializer().serializeToString(rs));
			
		}
		if(typeof window.DOMParser !== "undefined" && typeof window.XMLHttpRequest !== "undefined" && typeof window.XSLTProcessor !== "undefined") {
			processor = new XSLTProcessor();
			support = $.isFunction(processor.transformDocument) ? (typeof window.XMLSerializer !== "undefined") : true;
			if(!support) { return false; }
			xml = new DOMParser().parseFromString(xml, "text/xml");
			xsl = new DOMParser().parseFromString(xsl, "text/xml");
			if($.isFunction(processor.transformDocument)) {
				rs = document.implementation.createDocument("", "", null);
				processor.transformDocument(xml, xsl, rs, null);
				callback.call(null, new XMLSerializer().serializeToString(rs));
				return true;
			}
			else {
				processor.importStylesheet(xsl);
				rs = processor.transformToFragment(xml, document);
				callback.call(null, $("<div />").append(rs).html());
				return true;
			}
		}
		return false;
	};
	var xsl = {
		'nest' : '<' + '?xml version="1.0" encoding="utf-8" ?>' + 
			'<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >' + 
			'<xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/html" />' + 
			'<xsl:template match="/">' + 
			'	<xsl:call-template name="nodes">' + 
			'		<xsl:with-param name="node" select="/root" />' + 
			'	</xsl:call-template>' + 
			'</xsl:template>' + 
			'<xsl:template name="nodes">' + 
			'	<xsl:param name="node" />' + 
			'	<ul>' + 
			'	<xsl:for-each select="$node/item">' + 
			'		<xsl:variable name="children" select="count(./item) &gt; 0" />' + 
			'		<li>' + 
			'			<xsl:attribute name="class">' + 
			'				<xsl:if test="position() = last()">jstree-last </xsl:if>' + 
			'				<xsl:choose>' + 
			'					<xsl:when test="@state = \'open\'">jstree-open </xsl:when>' + 
			'					<xsl:when test="$children or @hasChildren or @state = \'closed\'">jstree-closed </xsl:when>' + 
			'					<xsl:otherwise>jstree-leaf </xsl:otherwise>' + 
			'				</xsl:choose>' + 
			'				<xsl:value-of select="@class" />' + 
			'			</xsl:attribute>' + 
			'			<xsl:for-each select="@*">' + 
			'				<xsl:if test="name() != \'class\' and name() != \'state\' and name() != \'hasChildren\'">' + 
			'					<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
			'				</xsl:if>' + 
			'			</xsl:for-each>' + 
			'	<ins class="jstree-icon"><xsl:text>&#xa0;</xsl:text></ins>' + 
			'			<xsl:for-each select="content/name">' + 
			'				<a>' + 
			'				<xsl:attribute name="href">' + 
			'					<xsl:choose>' + 
			'					<xsl:when test="@href"><xsl:value-of select="@href" /></xsl:when>' + 
			'					<xsl:otherwise>#</xsl:otherwise>' + 
			'					</xsl:choose>' + 
			'				</xsl:attribute>' + 
			'				<xsl:attribute name="class"><xsl:value-of select="@lang" /> <xsl:value-of select="@class" /></xsl:attribute>' + 
			'				<xsl:attribute name="style"><xsl:value-of select="@style" /></xsl:attribute>' + 
			'				<xsl:for-each select="@*">' + 
			'					<xsl:if test="name() != \'style\' and name() != \'class\' and name() != \'href\'">' + 
			'						<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
			'					</xsl:if>' + 
			'				</xsl:for-each>' + 
			'					<ins>' + 
			'						<xsl:attribute name="class">jstree-icon ' + 
			'							<xsl:if test="string-length(attribute::icon) > 0 and not(contains(@icon,\'/\'))"><xsl:value-of select="@icon" /></xsl:if>' + 
			'						</xsl:attribute>' + 
			'						<xsl:if test="string-length(attribute::icon) > 0 and contains(@icon,\'/\')"><xsl:attribute name="style">background:url(<xsl:value-of select="@icon" />) center center no-repeat;</xsl:attribute></xsl:if>' + 
			'						<xsl:text>&#xa0;</xsl:text>' + 
			'					</ins>' + 
			'					<xsl:copy-of select="./child::node()" />' + 
			'				</a>' + 
			'			</xsl:for-each>' + 
			'			<xsl:if test="$children or @hasChildren"><xsl:call-template name="nodes"><xsl:with-param name="node" select="current()" /></xsl:call-template></xsl:if>' + 
			'		</li>' + 
			'	</xsl:for-each>' + 
			'	</ul>' + 
			'</xsl:template>' + 
			'</xsl:stylesheet>',

		'flat' : '<' + '?xml version="1.0" encoding="utf-8" ?>' + 
			'<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >' + 
			'<xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/xml" />' + 
			'<xsl:template match="/">' + 
			'	<ul>' + 
			'	<xsl:for-each select="//item[not(@parent_id) or @parent_id=0 or not(@parent_id = //item/@id)]">' + /* the last `or` may be removed */
			'		<xsl:call-template name="nodes">' + 
			'			<xsl:with-param name="node" select="." />' + 
			'			<xsl:with-param name="is_last" select="number(position() = last())" />' + 
			'		</xsl:call-template>' + 
			'	</xsl:for-each>' + 
			'	</ul>' + 
			'</xsl:template>' + 
			'<xsl:template name="nodes">' + 
			'	<xsl:param name="node" />' + 
			'	<xsl:param name="is_last" />' + 
			'	<xsl:variable name="children" select="count(//item[@parent_id=$node/attribute::id]) &gt; 0" />' + 
			'	<li>' + 
			'	<xsl:attribute name="class">' + 
			'		<xsl:if test="$is_last = true()">jstree-last </xsl:if>' + 
			'		<xsl:choose>' + 
			'			<xsl:when test="@state = \'open\'">jstree-open </xsl:when>' + 
			'			<xsl:when test="$children or @hasChildren or @state = \'closed\'">jstree-closed </xsl:when>' + 
			'			<xsl:otherwise>jstree-leaf </xsl:otherwise>' + 
			'		</xsl:choose>' + 
			'		<xsl:value-of select="@class" />' + 
			'	</xsl:attribute>' + 
			'	<xsl:for-each select="@*">' + 
			'		<xsl:if test="name() != \'parent_id\' and name() != \'hasChildren\' and name() != \'class\' and name() != \'state\'">' + 
			'		<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
			'		</xsl:if>' + 
			'	</xsl:for-each>' + 
			'	<ins class="jstree-icon"><xsl:text>&#xa0;</xsl:text></ins>' + 
			'	<xsl:for-each select="content/name">' + 
			'		<a>' + 
			'		<xsl:attribute name="href">' + 
			'			<xsl:choose>' + 
			'			<xsl:when test="@href"><xsl:value-of select="@href" /></xsl:when>' + 
			'			<xsl:otherwise>#</xsl:otherwise>' + 
			'			</xsl:choose>' + 
			'		</xsl:attribute>' + 
			'		<xsl:attribute name="class"><xsl:value-of select="@lang" /> <xsl:value-of select="@class" /></xsl:attribute>' + 
			'		<xsl:attribute name="style"><xsl:value-of select="@style" /></xsl:attribute>' + 
			'		<xsl:for-each select="@*">' + 
			'			<xsl:if test="name() != \'style\' and name() != \'class\' and name() != \'href\'">' + 
			'				<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
			'			</xsl:if>' + 
			'		</xsl:for-each>' + 
			'			<ins>' + 
			'				<xsl:attribute name="class">jstree-icon ' + 
			'					<xsl:if test="string-length(attribute::icon) > 0 and not(contains(@icon,\'/\'))"><xsl:value-of select="@icon" /></xsl:if>' + 
			'				</xsl:attribute>' + 
			'				<xsl:if test="string-length(attribute::icon) > 0 and contains(@icon,\'/\')"><xsl:attribute name="style">background:url(<xsl:value-of select="@icon" />) center center no-repeat;</xsl:attribute></xsl:if>' + 
			'				<xsl:text>&#xa0;</xsl:text>' + 
			'			</ins>' + 
			'			<xsl:copy-of select="./child::node()" />' + 
			'		</a>' + 
			'	</xsl:for-each>' + 
			'	<xsl:if test="$children">' + 
			'		<ul>' + 
			'		<xsl:for-each select="//item[@parent_id=$node/attribute::id]">' + 
			'			<xsl:call-template name="nodes">' + 
			'				<xsl:with-param name="node" select="." />' + 
			'				<xsl:with-param name="is_last" select="number(position() = last())" />' + 
			'			</xsl:call-template>' + 
			'		</xsl:for-each>' + 
			'		</ul>' + 
			'	</xsl:if>' + 
			'	</li>' + 
			'</xsl:template>' + 
			'</xsl:stylesheet>'
	},
	escape_xml = function(string) {
		return string
			.toString()
			.replace(/&/g, '&amp;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/"/g, '&quot;')
			.replace(/'/g, '&apos;');
	};
	$.jstree.plugin("xml_data", {
		defaults : { 
			data : false,
			ajax : false,
			xsl : "flat",
			clean_node : false,
			correct_state : true,
			get_skip_empty : false,
			get_include_preamble : true
		},
		_fn : {
			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_xml(obj, function () { _this.__callback({ "obj" : _this._get_node(obj) }); s_call.call(this); }, e_call); },
			_is_loaded : function (obj) { 
				var s = this._get_settings().xml_data;
				obj = this._get_node(obj);
				return obj == -1 || !obj || (!s.ajax && !$.isFunction(s.data)) || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
			},
			load_node_xml : function (obj, s_call, e_call) {
				var s = this.get_settings().xml_data,
					error_func = function () {},
					success_func = function () {};

				obj = this._get_node(obj);
				if(obj && obj !== -1) {
					if(obj.data("jstree_is_loading")) { return; }
					else { obj.data("jstree_is_loading",true); }
				}
				switch(!0) {
					case (!s.data && !s.ajax): throw "Neither data nor ajax settings supplied.";
					case ($.isFunction(s.data)):
						s.data.call(this, obj, $.proxy(function (d) {
							this.parse_xml(d, $.proxy(function (d) {
								if(d) {
									d = d.replace(/ ?xmlns="[^"]*"/ig, "");
									if(d.length > 10) {
										d = $(d);
										if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
										else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d); obj.removeData("jstree_is_loading"); }
										if(s.clean_node) { this.clean_node(obj); }
										if(s_call) { s_call.call(this); }
									}
									else {
										if(obj && obj !== -1) { 
											obj.children("a.jstree-loading").removeClass("jstree-loading");
											obj.removeData("jstree_is_loading");
											if(s.correct_state) { 
												this.correct_state(obj);
												if(s_call) { s_call.call(this); } 
											}
										}
										else {
											if(s.correct_state) { 
												this.get_container().children("ul").empty();
												if(s_call) { s_call.call(this); } 
											}
										}
									}
								}
							}, this));
						}, this));
						break;
					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
						if(!obj || obj == -1) {
							this.parse_xml(s.data, $.proxy(function (d) {
								if(d) {
									d = d.replace(/ ?xmlns="[^"]*"/ig, "");
									if(d.length > 10) {
										d = $(d);
										this.get_container().children("ul").empty().append(d.children());
										if(s.clean_node) { this.clean_node(obj); }
										if(s_call) { s_call.call(this); }
									}
								}
								else { 
									if(s.correct_state) { 
										this.get_container().children("ul").empty(); 
										if(s_call) { s_call.call(this); }
									}
								}
							}, this));
						}
						break;
					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
						error_func = function (x, t, e) {
							var ef = this.get_settings().xml_data.ajax.error; 
							if(ef) { ef.call(this, x, t, e); }
							if(obj !== -1 && obj.length) {
								obj.children("a.jstree-loading").removeClass("jstree-loading");
								obj.removeData("jstree_is_loading");
								if(t === "success" && s.correct_state) { this.correct_state(obj); }
							}
							else {
								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
							}
							if(e_call) { e_call.call(this); }
						};
						success_func = function (d, t, x) {
							d = x.responseText;
							var sf = this.get_settings().xml_data.ajax.success; 
							if(sf) { d = sf.call(this,d,t,x) || d; }
							if(d === "" || (d && d.toString && d.toString().replace(/^[\s\n]+$/,"") === "")) {
								return error_func.call(this, x, t, "");
							}
							this.parse_xml(d, $.proxy(function (d) {
								if(d) {
									d = d.replace(/ ?xmlns="[^"]*"/ig, "");
									if(d.length > 10) {
										d = $(d);
										if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
										else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d); obj.removeData("jstree_is_loading"); }
										if(s.clean_node) { this.clean_node(obj); }
										if(s_call) { s_call.call(this); }
									}
									else {
										if(obj && obj !== -1) { 
											obj.children("a.jstree-loading").removeClass("jstree-loading");
											obj.removeData("jstree_is_loading");
											if(s.correct_state) { 
												this.correct_state(obj);
												if(s_call) { s_call.call(this); } 
											}
										}
										else {
											if(s.correct_state) { 
												this.get_container().children("ul").empty();
												if(s_call) { s_call.call(this); } 
											}
										}
									}
								}
							}, this));
						};
						s.ajax.context = this;
						s.ajax.error = error_func;
						s.ajax.success = success_func;
						if(!s.ajax.dataType) { s.ajax.dataType = "xml"; }
						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
						$.ajax(s.ajax);
						break;
				}
			},
			parse_xml : function (xml, callback) {
				var s = this._get_settings().xml_data;
				$.vakata.xslt(xml, xsl[s.xsl], callback);
			},
			get_xml : function (tp, obj, li_attr, a_attr, is_callback) {
				var result = "", 
					s = this._get_settings(), 
					_this = this,
					tmp1, tmp2, li, a, lang;
				if(!tp) { tp = "flat"; }
				if(!is_callback) { is_callback = 0; }
				obj = this._get_node(obj);
				if(!obj || obj === -1) { obj = this.get_container().find("> ul > li"); }
				li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];
				if(!is_callback && this.data.types && $.inArray(s.types.type_attr, li_attr) === -1) { li_attr.push(s.types.type_attr); }

				a_attr = $.isArray(a_attr) ? a_attr : [ ];

				if(!is_callback) { 
					if(s.xml_data.get_include_preamble) { 
						result += '<' + '?xml version="1.0" encoding="UTF-8"?' + '>'; 
					}
					result += "<root>"; 
				}
				obj.each(function () {
					result += "<item";
					li = $(this);
					$.each(li_attr, function (i, v) { 
						var t = li.attr(v);
						if(!s.xml_data.get_skip_empty || typeof t !== "undefined") {
							result += " " + v + "=\"" + escape_xml((" " + (t || "")).replace(/ jstree[^ ]*/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"")) + "\""; 
						}
					});
					if(li.hasClass("jstree-open")) { result += " state=\"open\""; }
					if(li.hasClass("jstree-closed")) { result += " state=\"closed\""; }
					if(tp === "flat") { result += " parent_id=\"" + escape_xml(is_callback) + "\""; }
					result += ">";
					result += "<content>";
					a = li.children("a");
					a.each(function () {
						tmp1 = $(this);
						lang = false;
						result += "<name";
						if($.inArray("languages", s.plugins) !== -1) {
							$.each(s.languages, function (k, z) {
								if(tmp1.hasClass(z)) { result += " lang=\"" + escape_xml(z) + "\""; lang = z; return false; }
							});
						}
						if(a_attr.length) { 
							$.each(a_attr, function (k, z) {
								var t = tmp1.attr(z);
								if(!s.xml_data.get_skip_empty || typeof t !== "undefined") {
									result += " " + z + "=\"" + escape_xml((" " + t || "").replace(/ jstree[^ ]*/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"")) + "\"";
								}
							});
						}
						if(tmp1.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"").length) {
							result += ' icon="' + escape_xml(tmp1.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"")) + '"';
						}
						if(tmp1.children("ins").get(0).style.backgroundImage.length) {
							result += ' icon="' + escape_xml(tmp1.children("ins").get(0).style.backgroundImage.replace("url(","").replace(")","").replace(/'/ig,"").replace(/"/ig,"")) + '"';
						}
						result += ">";
						result += "<![CDATA[" + _this.get_text(tmp1, lang) + "]]>";
						result += "</name>";
					});
					result += "</content>";
					tmp2 = li[0].id || true;
					li = li.find("> ul > li");
					if(li.length) { tmp2 = _this.get_xml(tp, li, li_attr, a_attr, tmp2); }
					else { tmp2 = ""; }
					if(tp == "nest") { result += tmp2; }
					result += "</item>";
					if(tp == "flat") { result += tmp2; }
				});
				if(!is_callback) { result += "</root>"; }
				return result;
			}
		}
	});
})(jQuery);
//*/

/*
 * jsTree search plugin
 * Enables both sync and async search on the tree
 * DOES NOT WORK WITH JSON PROGRESSIVE RENDER
 */
(function ($) {
	$.expr[':'].jstree_contains = function(a,i,m){
		return (a.textContent || a.innerText || "").toLowerCase().indexOf(m[3].toLowerCase())>=0;
	};
	$.expr[':'].jstree_title_contains = function(a,i,m) {
		return (a.getAttribute("title") || "").toLowerCase().indexOf(m[3].toLowerCase())>=0;
	};
	$.jstree.plugin("search", {
		__init : function () {
			this.data.search.str = "";
			this.data.search.result = $();
			if(this._get_settings().search.show_only_matches) {
				this.get_container()
					.bind("search.jstree", function (e, data) {
						$(this).children("ul").find("li").hide().removeClass("jstree-last");
						data.rslt.nodes.parentsUntil(".jstree").andSelf().show()
							.filter("ul").each(function () { $(this).children("li:visible").eq(-1).addClass("jstree-last"); });
					})
					.bind("clear_search.jstree", function () {
						$(this).children("ul").find("li").css("display","").end().end().jstree("clean_node", -1);
					});
			}
		},
		defaults : {
			ajax : false,
			search_method : "jstree_contains", // for case insensitive - jstree_contains
			show_only_matches : false
		},
		_fn : {
			search : function (str, skip_async) {
				if($.trim(str) === "") { this.clear_search(); return; }
				var s = this.get_settings().search, 
					t = this,
					error_func = function () { },
					success_func = function () { };
				this.data.search.str = str;

				if(!skip_async && s.ajax !== false && this.get_container_ul().find("li.jstree-closed:not(:has(ul)):eq(0)").length > 0) {
					this.search.supress_callback = true;
					error_func = function () { };
					success_func = function (d, t, x) {
						var sf = this.get_settings().search.ajax.success; 
						if(sf) { d = sf.call(this,d,t,x) || d; }
						this.data.search.to_open = d;
						this._search_open();
					};
					s.ajax.context = this;
					s.ajax.error = error_func;
					s.ajax.success = success_func;
					if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, str); }
					if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, str); }
					if(!s.ajax.data) { s.ajax.data = { "search_string" : str }; }
					if(!s.ajax.dataType || /^json/.exec(s.ajax.dataType)) { s.ajax.dataType = "json"; }
					$.ajax(s.ajax);
					return;
				}
				if(this.data.search.result.length) { this.clear_search(); }
				this.data.search.result = this.get_container().find("a" + (this.data.languages ? "." + this.get_lang() : "" ) + ":" + (s.search_method) + "(" + this.data.search.str + ")");
				this.data.search.result.addClass("jstree-search").parent().parents(".jstree-closed").each(function () {
					t.open_node(this, false, true);
				});
				this.__callback({ nodes : this.data.search.result, str : str });
			},
			clear_search : function (str) {
				this.data.search.result.removeClass("jstree-search");
				this.__callback(this.data.search.result);
				this.data.search.result = $();
			},
			_search_open : function (is_callback) {
				var _this = this,
					done = true,
					current = [],
					remaining = [];
				if(this.data.search.to_open.length) {
					$.each(this.data.search.to_open, function (i, val) {
						if(val == "#") { return true; }
						if($(val).length && $(val).is(".jstree-closed")) { current.push(val); }
						else { remaining.push(val); }
					});
					if(current.length) {
						this.data.search.to_open = remaining;
						$.each(current, function (i, val) { 
							_this.open_node(val, function () { _this._search_open(true); }); 
						});
						done = false;
					}
				}
				if(done) { this.search(this.data.search.str, true); }
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree contextmenu plugin
 */
(function ($) {
	$.vakata.context = {
		hide_on_mouseleave : false,

		cnt		: $("<div id='vakata-contextmenu' />"),
		vis		: false,
		tgt		: false,
		par		: false,
		func	: false,
		data	: false,
		rtl		: false,
		show	: function (s, t, x, y, d, p, rtl) {
			$.vakata.context.rtl = !!rtl;
			var html = $.vakata.context.parse(s), h, w;
			if(!html) { return; }
			$.vakata.context.vis = true;
			$.vakata.context.tgt = t;
			$.vakata.context.par = p || t || null;
			$.vakata.context.data = d || null;
			$.vakata.context.cnt
				.html(html)
				.css({ "visibility" : "hidden", "display" : "block", "left" : 0, "top" : 0 });

			if($.vakata.context.hide_on_mouseleave) {
				$.vakata.context.cnt
					.one("mouseleave", function(e) { $.vakata.context.hide(); });
			}

			h = $.vakata.context.cnt.height();
			w = $.vakata.context.cnt.width();
			if(x + w > $(document).width()) { 
				x = $(document).width() - (w + 5); 
				$.vakata.context.cnt.find("li > ul").addClass("right"); 
			}
			if(y + h > $(document).height()) { 
				y = y - (h + t[0].offsetHeight); 
				$.vakata.context.cnt.find("li > ul").addClass("bottom"); 
			}

			$.vakata.context.cnt
				.css({ "left" : x, "top" : y })
				.find("li:has(ul)")
					.bind("mouseenter", function (e) { 
						var w = $(document).width(),
							h = $(document).height(),
							ul = $(this).children("ul").show(); 
						if(w !== $(document).width()) { ul.toggleClass("right"); }
						if(h !== $(document).height()) { ul.toggleClass("bottom"); }
					})
					.bind("mouseleave", function (e) { 
						$(this).children("ul").hide(); 
					})
					.end()
				.css({ "visibility" : "visible" })
				.show();
			$(document).triggerHandler("context_show.vakata");
		},
		hide	: function () {
			$.vakata.context.vis = false;
			$.vakata.context.cnt.attr("class","").css({ "visibility" : "hidden" });
			$(document).triggerHandler("context_hide.vakata");
		},
		parse	: function (s, is_callback) {
			if(!s) { return false; }
			var str = "",
				tmp = false,
				was_sep = true;
			if(!is_callback) { $.vakata.context.func = {}; }
			str += "<ul>";
			$.each(s, function (i, val) {
				if(!val) { return true; }
				$.vakata.context.func[i] = val.action;
				if(!was_sep && val.separator_before) {
					str += "<li class='vakata-separator vakata-separator-before'></li>";
				}
				was_sep = false;
				str += "<li class='" + (val._class || "") + (val._disabled ? " jstree-contextmenu-disabled " : "") + "'><ins ";
				if(val.icon && val.icon.indexOf("/") === -1) { str += " class='" + val.icon + "' "; }
				if(val.icon && val.icon.indexOf("/") !== -1) { str += " style='background:url(" + val.icon + ") center center no-repeat;' "; }
				str += ">&#160;</ins><a href='#' rel='" + i + "'>";
				if(val.submenu) {
					str += "<span style='float:" + ($.vakata.context.rtl ? "left" : "right") + ";'>&raquo;</span>";
				}
				str += val.label + "</a>";
				if(val.submenu) {
					tmp = $.vakata.context.parse(val.submenu, true);
					if(tmp) { str += tmp; }
				}
				str += "</li>";
				if(val.separator_after) {
					str += "<li class='vakata-separator vakata-separator-after'></li>";
					was_sep = true;
				}
			});
			str = str.replace(/<li class\='vakata-separator vakata-separator-after'\><\/li\>$/,"");
			str += "</ul>";
			$(document).triggerHandler("context_parse.vakata");
			return str.length > 10 ? str : false;
		},
		exec	: function (i) {
			if($.isFunction($.vakata.context.func[i])) {
				// if is string - eval and call it!
				$.vakata.context.func[i].call($.vakata.context.data, $.vakata.context.par);
				return true;
			}
			else { return false; }
		}
	};
	$(function () {
		var css_string = '' + 
			'#vakata-contextmenu { display:block; visibility:hidden; left:0; top:-200px; position:absolute; margin:0; padding:0; min-width:180px; background:#ebebeb; border:1px solid silver; z-index:10000; *width:180px; } ' + 
			'#vakata-contextmenu ul { min-width:180px; *width:180px; } ' + 
			'#vakata-contextmenu ul, #vakata-contextmenu li { margin:0; padding:0; list-style-type:none; display:block; } ' + 
			'#vakata-contextmenu li { line-height:20px; min-height:20px; position:relative; padding:0px; } ' + 
			'#vakata-contextmenu li a { padding:1px 6px; line-height:17px; display:block; text-decoration:none; margin:1px 1px 0 1px; } ' + 
			'#vakata-contextmenu li ins { float:left; width:16px; height:16px; text-decoration:none; margin-right:2px; } ' + 
			'#vakata-contextmenu li a:hover, #vakata-contextmenu li.vakata-hover > a { background:gray; color:white; } ' + 
			'#vakata-contextmenu li ul { display:none; position:absolute; top:-2px; left:100%; background:#ebebeb; border:1px solid gray; } ' + 
			'#vakata-contextmenu .right { right:100%; left:auto; } ' + 
			'#vakata-contextmenu .bottom { bottom:-1px; top:auto; } ' + 
			'#vakata-contextmenu li.vakata-separator { min-height:0; height:1px; line-height:1px; font-size:1px; overflow:hidden; margin:0 2px; background:silver; /* border-top:1px solid #fefefe; */ padding:0; } ';
		$.vakata.css.add_sheet({ str : css_string, title : "vakata" });
		$.vakata.context.cnt
			.delegate("a","click", function (e) { e.preventDefault(); })
			.delegate("a","mouseup", function (e) {
				if(!$(this).parent().hasClass("jstree-contextmenu-disabled") && $.vakata.context.exec($(this).attr("rel"))) {
					$.vakata.context.hide();
				}
				else { $(this).blur(); }
			})
			.delegate("a","mouseover", function () {
				$.vakata.context.cnt.find(".vakata-hover").removeClass("vakata-hover");
			})
			.appendTo("body");
		$(document).bind("mousedown", function (e) { if($.vakata.context.vis && !$.contains($.vakata.context.cnt[0], e.target)) { $.vakata.context.hide(); } });
		if(typeof $.hotkeys !== "undefined") {
			$(document)
				.bind("keydown", "up", function (e) { 
					if($.vakata.context.vis) { 
						var o = $.vakata.context.cnt.find("ul:visible").last().children(".vakata-hover").removeClass("vakata-hover").prevAll("li:not(.vakata-separator)").first();
						if(!o.length) { o = $.vakata.context.cnt.find("ul:visible").last().children("li:not(.vakata-separator)").last(); }
						o.addClass("vakata-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "down", function (e) { 
					if($.vakata.context.vis) { 
						var o = $.vakata.context.cnt.find("ul:visible").last().children(".vakata-hover").removeClass("vakata-hover").nextAll("li:not(.vakata-separator)").first();
						if(!o.length) { o = $.vakata.context.cnt.find("ul:visible").last().children("li:not(.vakata-separator)").first(); }
						o.addClass("vakata-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "right", function (e) { 
					if($.vakata.context.vis) { 
						$.vakata.context.cnt.find(".vakata-hover").children("ul").show().children("li:not(.vakata-separator)").removeClass("vakata-hover").first().addClass("vakata-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "left", function (e) { 
					if($.vakata.context.vis) { 
						$.vakata.context.cnt.find(".vakata-hover").children("ul").hide().children(".vakata-separator").removeClass("vakata-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "esc", function (e) { 
					$.vakata.context.hide(); 
					e.preventDefault();
				})
				.bind("keydown", "space", function (e) { 
					$.vakata.context.cnt.find(".vakata-hover").last().children("a").click();
					e.preventDefault();
				});
		}
	});

	$.jstree.plugin("contextmenu", {
		__init : function () {
			this.get_container()
				.delegate("a", "contextmenu.jstree", $.proxy(function (e) {
						e.preventDefault();
						if(!$(e.currentTarget).hasClass("jstree-loading")) {
							this.show_contextmenu(e.currentTarget, e.pageX, e.pageY);
						}
					}, this))
				.delegate("a", "click.jstree", $.proxy(function (e) {
						if(this.data.contextmenu) {
							$.vakata.context.hide();
						}
					}, this))
				.bind("destroy.jstree", $.proxy(function () {
						// TODO: move this to descruct method
						if(this.data.contextmenu) {
							$.vakata.context.hide();
						}
					}, this));
			$(document).bind("context_hide.vakata", $.proxy(function () { this.data.contextmenu = false; }, this));
		},
		defaults : { 
			select_node : false, // requires UI plugin
			show_at_node : true,
			items : { // Could be a function that should return an object like this one
				"create" : {
					"separator_before"	: false,
					"separator_after"	: true,
					"label"				: "Create",
					"action"			: function (obj) { this.create(obj); }
				},
				"rename" : {
					"separator_before"	: false,
					"separator_after"	: false,
					"label"				: "Rename",
					"action"			: function (obj) { this.rename(obj); }
				},
				"remove" : {
					"separator_before"	: false,
					"icon"				: false,
					"separator_after"	: false,
					"label"				: "Delete",
					"action"			: function (obj) { if(this.is_selected(obj)) { this.remove(); } else { this.remove(obj); } }
				},
				"ccp" : {
					"separator_before"	: true,
					"icon"				: false,
					"separator_after"	: false,
					"label"				: "Edit",
					"action"			: false,
					"submenu" : { 
						"cut" : {
							"separator_before"	: false,
							"separator_after"	: false,
							"label"				: "Cut",
							"action"			: function (obj) { this.cut(obj); }
						},
						"copy" : {
							"separator_before"	: false,
							"icon"				: false,
							"separator_after"	: false,
							"label"				: "Copy",
							"action"			: function (obj) { this.copy(obj); }
						},
						"paste" : {
							"separator_before"	: false,
							"icon"				: false,
							"separator_after"	: false,
							"label"				: "Paste",
							"action"			: function (obj) { this.paste(obj); }
						}
					}
				}
			}
		},
		_fn : {
			show_contextmenu : function (obj, x, y) {
				obj = this._get_node(obj);
				var s = this.get_settings().contextmenu,
					a = obj.children("a:visible:eq(0)"),
					o = false,
					i = false;
				if(s.select_node && this.data.ui && !this.is_selected(obj)) {
					this.deselect_all();
					this.select_node(obj, true);
				}
				if(s.show_at_node || typeof x === "undefined" || typeof y === "undefined") {
					o = a.offset();
					x = o.left;
					y = o.top + this.data.core.li_height;
				}
				i = obj.data("jstree") && obj.data("jstree").contextmenu ? obj.data("jstree").contextmenu : s.items;
				if($.isFunction(i)) { i = i.call(this, obj); }
				this.data.contextmenu = true;
				$.vakata.context.show(i, a, x, y, this, obj, this._get_settings().core.rtl);
				if(this.data.themes) { $.vakata.context.cnt.attr("class", "jstree-" + this.data.themes.theme + "-context"); }
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree types plugin
 * Adds support types of nodes
 * You can set an attribute on each li node, that represents its type.
 * According to the type setting the node may get custom icon/validation rules
 */
(function ($) {
	$.jstree.plugin("types", {
		__init : function () {
			var s = this._get_settings().types;
			this.data.types.attach_to = [];
			this.get_container()
				.bind("init.jstree", $.proxy(function () { 
						var types = s.types, 
							attr  = s.type_attr, 
							icons_css = "", 
							_this = this;

						$.each(types, function (i, tp) {
							$.each(tp, function (k, v) { 
								if(!/^(max_depth|max_children|icon|valid_children)$/.test(k)) { _this.data.types.attach_to.push(k); }
							});
							if(!tp.icon) { return true; }
							if( tp.icon.image || tp.icon.position) {
								if(i == "default")	{ icons_css += '.jstree-' + _this.get_index() + ' a > .jstree-icon { '; }
								else				{ icons_css += '.jstree-' + _this.get_index() + ' li[' + attr + '="' + i + '"] > a > .jstree-icon { '; }
								if(tp.icon.image)	{ icons_css += ' background-image:url(' + tp.icon.image + '); '; }
								if(tp.icon.position){ icons_css += ' background-position:' + tp.icon.position + '; '; }
								else				{ icons_css += ' background-position:0 0; '; }
								icons_css += '} ';
							}
						});
						if(icons_css !== "") { $.vakata.css.add_sheet({ 'str' : icons_css, title : "jstree-types" }); }
					}, this))
				.bind("before.jstree", $.proxy(function (e, data) { 
						var s, t, 
							o = this._get_settings().types.use_data ? this._get_node(data.args[0]) : false, 
							d = o && o !== -1 && o.length ? o.data("jstree") : false;
						if(d && d.types && d.types[data.func] === false) { e.stopImmediatePropagation(); return false; }
						if($.inArray(data.func, this.data.types.attach_to) !== -1) {
							if(!data.args[0] || (!data.args[0].tagName && !data.args[0].jquery)) { return; }
							s = this._get_settings().types.types;
							t = this._get_type(data.args[0]);
							if(
								( 
									(s[t] && typeof s[t][data.func] !== "undefined") || 
									(s["default"] && typeof s["default"][data.func] !== "undefined") 
								) && this._check(data.func, data.args[0]) === false
							) {
								e.stopImmediatePropagation();
								return false;
							}
						}
					}, this));
			if(is_ie6) {
				this.get_container()
					.bind("load_node.jstree set_type.jstree", $.proxy(function (e, data) {
							var r = data && data.rslt && data.rslt.obj && data.rslt.obj !== -1 ? this._get_node(data.rslt.obj).parent() : this.get_container_ul(),
								c = false,
								s = this._get_settings().types;
							$.each(s.types, function (i, tp) {
								if(tp.icon && (tp.icon.image || tp.icon.position)) {
									c = i === "default" ? r.find("li > a > .jstree-icon") : r.find("li[" + s.type_attr + "='" + i + "'] > a > .jstree-icon");
									if(tp.icon.image) { c.css("backgroundImage","url(" + tp.icon.image + ")"); }
									c.css("backgroundPosition", tp.icon.position || "0 0");
								}
							});
						}, this));
			}
		},
		defaults : {
			// defines maximum number of root nodes (-1 means unlimited, -2 means disable max_children checking)
			max_children		: -1,
			// defines the maximum depth of the tree (-1 means unlimited, -2 means disable max_depth checking)
			max_depth			: -1,
			// defines valid node types for the root nodes
			valid_children		: "all",

			// whether to use $.data
			use_data : false, 
			// where is the type stores (the rel attribute of the LI element)
			type_attr : "rel",
			// a list of types
			types : {
				// the default type
				"default" : {
					"max_children"	: -1,
					"max_depth"		: -1,
					"valid_children": "all"

					// Bound functions - you can bind any other function here (using boolean or function)
					//"select_node"	: true
				}
			}
		},
		_fn : {
			_types_notify : function (n, data) {
				if(data.type && this._get_settings().types.use_data) {
					this.set_type(data.type, n);
				}
			},
			_get_type : function (obj) {
				obj = this._get_node(obj);
				return (!obj || !obj.length) ? false : obj.attr(this._get_settings().types.type_attr) || "default";
			},
			set_type : function (str, obj) {
				obj = this._get_node(obj);
				var ret = (!obj.length || !str) ? false : obj.attr(this._get_settings().types.type_attr, str);
				if(ret) { this.__callback({ obj : obj, type : str}); }
				return ret;
			},
			_check : function (rule, obj, opts) {
				obj = this._get_node(obj);
				var v = false, t = this._get_type(obj), d = 0, _this = this, s = this._get_settings().types, data = false;
				if(obj === -1) { 
					if(!!s[rule]) { v = s[rule]; }
					else { return; }
				}
				else {
					if(t === false) { return; }
					data = s.use_data ? obj.data("jstree") : false;
					if(data && data.types && typeof data.types[rule] !== "undefined") { v = data.types[rule]; }
					else if(!!s.types[t] && typeof s.types[t][rule] !== "undefined") { v = s.types[t][rule]; }
					else if(!!s.types["default"] && typeof s.types["default"][rule] !== "undefined") { v = s.types["default"][rule]; }
				}
				if($.isFunction(v)) { v = v.call(this, obj); }
				if(rule === "max_depth" && obj !== -1 && opts !== false && s.max_depth !== -2 && v !== 0) {
					// also include the node itself - otherwise if root node it is not checked
					obj.children("a:eq(0)").parentsUntil(".jstree","li").each(function (i) {
						// check if current depth already exceeds global tree depth
						if(s.max_depth !== -1 && s.max_depth - (i + 1) <= 0) { v = 0; return false; }
						d = (i === 0) ? v : _this._check(rule, this, false);
						// check if current node max depth is already matched or exceeded
						if(d !== -1 && d - (i + 1) <= 0) { v = 0; return false; }
						// otherwise - set the max depth to the current value minus current depth
						if(d >= 0 && (d - (i + 1) < v || v < 0) ) { v = d - (i + 1); }
						// if the global tree depth exists and it minus the nodes calculated so far is less than `v` or `v` is unlimited
						if(s.max_depth >= 0 && (s.max_depth - (i + 1) < v || v < 0) ) { v = s.max_depth - (i + 1); }
					});
				}
				return v;
			},
			check_move : function () {
				if(!this.__call_old()) { return false; }
				var m  = this._get_move(),
					s  = m.rt._get_settings().types,
					mc = m.rt._check("max_children", m.cr),
					md = m.rt._check("max_depth", m.cr),
					vc = m.rt._check("valid_children", m.cr),
					ch = 0, d = 1, t;

				if(vc === "none") { return false; } 
				if($.isArray(vc) && m.ot && m.ot._get_type) {
					m.o.each(function () {
						if($.inArray(m.ot._get_type(this), vc) === -1) { d = false; return false; }
					});
					if(d === false) { return false; }
				}
				if(s.max_children !== -2 && mc !== -1) {
					ch = m.cr === -1 ? this.get_container().find("> ul > li").not(m.o).length : m.cr.find("> ul > li").not(m.o).length;
					if(ch + m.o.length > mc) { return false; }
				}
				if(s.max_depth !== -2 && md !== -1) {
					d = 0;
					if(md === 0) { return false; }
					if(typeof m.o.d === "undefined") {
						// TODO: deal with progressive rendering and async when checking max_depth (how to know the depth of the moved node)
						t = m.o;
						while(t.length > 0) {
							t = t.find("> ul > li");
							d ++;
						}
						m.o.d = d;
					}
					if(md - m.o.d < 0) { return false; }
				}
				return true;
			},
			create_node : function (obj, position, js, callback, is_loaded, skip_check) {
				if(!skip_check && (is_loaded || this._is_loaded(obj))) {
					var p  = (typeof position == "string" && position.match(/^before|after$/i) && obj !== -1) ? this._get_parent(obj) : this._get_node(obj),
						s  = this._get_settings().types,
						mc = this._check("max_children", p),
						md = this._check("max_depth", p),
						vc = this._check("valid_children", p),
						ch;
					if(typeof js === "string") { js = { data : js }; }
					if(!js) { js = {}; }
					if(vc === "none") { return false; } 
					if($.isArray(vc)) {
						if(!js.attr || !js.attr[s.type_attr]) { 
							if(!js.attr) { js.attr = {}; }
							js.attr[s.type_attr] = vc[0]; 
						}
						else {
							if($.inArray(js.attr[s.type_attr], vc) === -1) { return false; }
						}
					}
					if(s.max_children !== -2 && mc !== -1) {
						ch = p === -1 ? this.get_container().find("> ul > li").length : p.find("> ul > li").length;
						if(ch + 1 > mc) { return false; }
					}
					if(s.max_depth !== -2 && md !== -1 && (md - 1) < 0) { return false; }
				}
				return this.__call_old(true, obj, position, js, callback, is_loaded, skip_check);
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree HTML plugin
 * The HTML data store. Datastores are build by replacing the `load_node` and `_is_loaded` functions.
 */
(function ($) {
	$.jstree.plugin("html_data", {
		__init : function () { 
			// this used to use html() and clean the whitespace, but this way any attached data was lost
			this.data.html_data.original_container_html = this.get_container().find(" > ul > li").clone(true);
			// remove white space from LI node - otherwise nodes appear a bit to the right
			this.data.html_data.original_container_html.find("li").andSelf().contents().filter(function() { return this.nodeType == 3; }).remove();
		},
		defaults : { 
			data : false,
			ajax : false,
			correct_state : true
		},
		_fn : {
			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_html(obj, function () { _this.__callback({ "obj" : _this._get_node(obj) }); s_call.call(this); }, e_call); },
			_is_loaded : function (obj) { 
				obj = this._get_node(obj); 
				return obj == -1 || !obj || (!this._get_settings().html_data.ajax && !$.isFunction(this._get_settings().html_data.data)) || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
			},
			load_node_html : function (obj, s_call, e_call) {
				var d,
					s = this.get_settings().html_data,
					error_func = function () {},
					success_func = function () {};
				obj = this._get_node(obj);
				if(obj && obj !== -1) {
					if(obj.data("jstree_is_loading")) { return; }
					else { obj.data("jstree_is_loading",true); }
				}
				switch(!0) {
					case ($.isFunction(s.data)):
						s.data.call(this, obj, $.proxy(function (d) {
							if(d && d !== "" && d.toString && d.toString().replace(/^[\s\n]+$/,"") !== "") {
								d = $(d);
								if(!d.is("ul")) { d = $("<ul />").append(d); }
								if(obj == -1 || !obj) { this.get_container().children("ul").empty().append(d.children()).find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); }
								else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d).children("ul").find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); obj.removeData("jstree_is_loading"); }
								this.clean_node(obj);
								if(s_call) { s_call.call(this); }
							}
							else {
								if(obj && obj !== -1) {
									obj.children("a.jstree-loading").removeClass("jstree-loading");
									obj.removeData("jstree_is_loading");
									if(s.correct_state) { 
										this.correct_state(obj);
										if(s_call) { s_call.call(this); } 
									}
								}
								else {
									if(s.correct_state) { 
										this.get_container().children("ul").empty();
										if(s_call) { s_call.call(this); } 
									}
								}
							}
						}, this));
						break;
					case (!s.data && !s.ajax):
						if(!obj || obj == -1) {
							this.get_container()
								.children("ul").empty()
								.append(this.data.html_data.original_container_html)
								.find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end()
								.filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon");
							this.clean_node();
						}
						if(s_call) { s_call.call(this); }
						break;
					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
						if(!obj || obj == -1) {
							d = $(s.data);
							if(!d.is("ul")) { d = $("<ul />").append(d); }
							this.get_container()
								.children("ul").empty().append(d.children())
								.find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end()
								.filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon");
							this.clean_node();
						}
						if(s_call) { s_call.call(this); }
						break;
					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
						obj = this._get_node(obj);
						error_func = function (x, t, e) {
							var ef = this.get_settings().html_data.ajax.error; 
							if(ef) { ef.call(this, x, t, e); }
							if(obj != -1 && obj.length) {
								obj.children("a.jstree-loading").removeClass("jstree-loading");
								obj.removeData("jstree_is_loading");
								if(t === "success" && s.correct_state) { this.correct_state(obj); }
							}
							else {
								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
							}
							if(e_call) { e_call.call(this); }
						};
						success_func = function (d, t, x) {
							var sf = this.get_settings().html_data.ajax.success; 
							if(sf) { d = sf.call(this,d,t,x) || d; }
							if(d === "" || (d && d.toString && d.toString().replace(/^[\s\n]+$/,"") === "")) {
								return error_func.call(this, x, t, "");
							}
							if(d) {
								d = $(d);
								if(!d.is("ul")) { d = $("<ul />").append(d); }
								if(obj == -1 || !obj) { this.get_container().children("ul").empty().append(d.children()).find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); }
								else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d).children("ul").find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); obj.removeData("jstree_is_loading"); }
								this.clean_node(obj);
								if(s_call) { s_call.call(this); }
							}
							else {
								if(obj && obj !== -1) {
									obj.children("a.jstree-loading").removeClass("jstree-loading");
									obj.removeData("jstree_is_loading");
									if(s.correct_state) { 
										this.correct_state(obj);
										if(s_call) { s_call.call(this); } 
									}
								}
								else {
									if(s.correct_state) { 
										this.get_container().children("ul").empty();
										if(s_call) { s_call.call(this); } 
									}
								}
							}
						};
						s.ajax.context = this;
						s.ajax.error = error_func;
						s.ajax.success = success_func;
						if(!s.ajax.dataType) { s.ajax.dataType = "html"; }
						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
						$.ajax(s.ajax);
						break;
				}
			}
		}
	});
	// include the HTML data plugin by default
	$.jstree.defaults.plugins.push("html_data");
})(jQuery);
//*/

/* 
 * jsTree themeroller plugin
 * Adds support for jQuery UI themes. Include this at the end of your plugins list, also make sure "themes" is not included.
 */
(function ($) {
	$.jstree.plugin("themeroller", {
		__init : function () {
			var s = this._get_settings().themeroller;
			this.get_container()
				.addClass("ui-widget-content")
				.addClass("jstree-themeroller")
				.delegate("a","mouseenter.jstree", function (e) {
					if(!$(e.currentTarget).hasClass("jstree-loading")) {
						$(this).addClass(s.item_h);
					}
				})
				.delegate("a","mouseleave.jstree", function () {
					$(this).removeClass(s.item_h);
				})
				.bind("init.jstree", $.proxy(function (e, data) { 
						data.inst.get_container().find("> ul > li > .jstree-loading > ins").addClass("ui-icon-refresh");
						this._themeroller(data.inst.get_container().find("> ul > li"));
					}, this))
				.bind("open_node.jstree create_node.jstree", $.proxy(function (e, data) { 
						this._themeroller(data.rslt.obj);
					}, this))
				.bind("loaded.jstree refresh.jstree", $.proxy(function (e) {
						this._themeroller();
					}, this))
				.bind("close_node.jstree", $.proxy(function (e, data) {
						this._themeroller(data.rslt.obj);
					}, this))
				.bind("delete_node.jstree", $.proxy(function (e, data) {
						this._themeroller(data.rslt.parent);
					}, this))
				.bind("correct_state.jstree", $.proxy(function (e, data) {
						data.rslt.obj
							.children("ins.jstree-icon").removeClass(s.opened + " " + s.closed + " ui-icon").end()
							.find("> a > ins.ui-icon")
								.filter(function() { 
									return this.className.toString()
										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")
										.indexOf("ui-icon-") === -1; 
								}).removeClass(s.item_open + " " + s.item_clsd).addClass(s.item_leaf || "jstree-no-icon");
					}, this))
				.bind("select_node.jstree", $.proxy(function (e, data) {
						data.rslt.obj.children("a").addClass(s.item_a);
					}, this))
				.bind("deselect_node.jstree deselect_all.jstree", $.proxy(function (e, data) {
						this.get_container()
							.find("a." + s.item_a).removeClass(s.item_a).end()
							.find("a.jstree-clicked").addClass(s.item_a);
					}, this))
				.bind("dehover_node.jstree", $.proxy(function (e, data) {
						data.rslt.obj.children("a").removeClass(s.item_h);
					}, this))
				.bind("hover_node.jstree", $.proxy(function (e, data) {
						this.get_container()
							.find("a." + s.item_h).not(data.rslt.obj).removeClass(s.item_h);
						data.rslt.obj.children("a").addClass(s.item_h);
					}, this))
				.bind("move_node.jstree", $.proxy(function (e, data) {
						this._themeroller(data.rslt.o);
						this._themeroller(data.rslt.op);
					}, this));
		},
		__destroy : function () {
			var s = this._get_settings().themeroller,
				c = [ "ui-icon" ];
			$.each(s, function (i, v) {
				v = v.split(" ");
				if(v.length) { c = c.concat(v); }
			});
			this.get_container()
				.removeClass("ui-widget-content")
				.find("." + c.join(", .")).removeClass(c.join(" "));
		},
		_fn : {
			_themeroller : function (obj) {
				var s = this._get_settings().themeroller;
				obj = (!obj || obj == -1) ? this.get_container_ul() : this._get_node(obj);
				obj = (!obj || obj == -1) ? this.get_container_ul() : obj.parent();
				obj
					.find("li.jstree-closed")
						.children("ins.jstree-icon").removeClass(s.opened).addClass("ui-icon " + s.closed).end()
						.children("a").addClass(s.item)
							.children("ins.jstree-icon").addClass("ui-icon")
								.filter(function() { 
									return this.className.toString()
										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")
										.indexOf("ui-icon-") === -1; 
								}).removeClass(s.item_leaf + " " + s.item_open).addClass(s.item_clsd || "jstree-no-icon")
								.end()
							.end()
						.end()
					.end()
					.find("li.jstree-open")
						.children("ins.jstree-icon").removeClass(s.closed).addClass("ui-icon " + s.opened).end()
						.children("a").addClass(s.item)
							.children("ins.jstree-icon").addClass("ui-icon")
								.filter(function() { 
									return this.className.toString()
										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")
										.indexOf("ui-icon-") === -1; 
								}).removeClass(s.item_leaf + " " + s.item_clsd).addClass(s.item_open || "jstree-no-icon")
								.end()
							.end()
						.end()
					.end()
					.find("li.jstree-leaf")
						.children("ins.jstree-icon").removeClass(s.closed + " ui-icon " + s.opened).end()
						.children("a").addClass(s.item)
							.children("ins.jstree-icon").addClass("ui-icon")
								.filter(function() { 
									return this.className.toString()
										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")
										.indexOf("ui-icon-") === -1; 
								}).removeClass(s.item_clsd + " " + s.item_open).addClass(s.item_leaf || "jstree-no-icon");
			}
		},
		defaults : {
			"opened"	: "ui-icon-triangle-1-se",
			"closed"	: "ui-icon-triangle-1-e",
			"item"		: "ui-state-default",
			"item_h"	: "ui-state-hover",
			"item_a"	: "ui-state-active",
			"item_open"	: "ui-icon-folder-open",
			"item_clsd"	: "ui-icon-folder-collapsed",
			"item_leaf"	: "ui-icon-document"
		}
	});
	$(function() {
		var css_string = '' + 
			'.jstree-themeroller .ui-icon { overflow:visible; } ' + 
			'.jstree-themeroller a { padding:0 2px; } ' + 
			'.jstree-themeroller .jstree-no-icon { display:none; }';
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});
})(jQuery);
//*/

/* 
 * jsTree unique plugin
 * Forces different names amongst siblings (still a bit experimental)
 * NOTE: does not check language versions (it will not be possible to have nodes with the same title, even in different languages)
 */
(function ($) {
	$.jstree.plugin("unique", {
		__init : function () {
			this.get_container()
				.bind("before.jstree", $.proxy(function (e, data) { 
						var nms = [], res = true, p, t;
						if(data.func == "move_node") {
							// obj, ref, position, is_copy, is_prepared, skip_check
							if(data.args[4] === true) {
								if(data.args[0].o && data.args[0].o.length) {
									data.args[0].o.children("a").each(function () { nms.push($(this).text().replace(/^\s+/g,"")); });
									res = this._check_unique(nms, data.args[0].np.find("> ul > li").not(data.args[0].o), "move_node");
								}
							}
						}
						if(data.func == "create_node") {
							// obj, position, js, callback, is_loaded
							if(data.args[4] || this._is_loaded(data.args[0])) {
								p = this._get_node(data.args[0]);
								if(data.args[1] && (data.args[1] === "before" || data.args[1] === "after")) {
									p = this._get_parent(data.args[0]);
									if(!p || p === -1) { p = this.get_container(); }
								}
								if(typeof data.args[2] === "string") { nms.push(data.args[2]); }
								else if(!data.args[2] || !data.args[2].data) { nms.push(this._get_string("new_node")); }
								else { nms.push(data.args[2].data); }
								res = this._check_unique(nms, p.find("> ul > li"), "create_node");
							}
						}
						if(data.func == "rename_node") {
							// obj, val
							nms.push(data.args[1]);
							t = this._get_node(data.args[0]);
							p = this._get_parent(t);
							if(!p || p === -1) { p = this.get_container(); }
							res = this._check_unique(nms, p.find("> ul > li").not(t), "rename_node");
						}
						if(!res) {
							e.stopPropagation();
							return false;
						}
					}, this));
		},
		defaults : { 
			error_callback : $.noop
		},
		_fn : { 
			_check_unique : function (nms, p, func) {
				var cnms = [], ok = true;
				p.children("a").each(function () { cnms.push($(this).text().replace(/^\s+/g,"")); });
				if(!cnms.length || !nms.length) { return true; }
				$.each(nms, function (i, v) {
					if($.inArray(v, cnms) !== -1) {
						ok = false;
						return false;
					}
				});
				if(!ok) {
					this._get_settings().unique.error_callback.call(null, nms, p, func);
				}
				return ok;
			},
			check_move : function () {
				if(!this.__call_old()) { return false; }
				var p = this._get_move(), nms = [];
				if(p.o && p.o.length) {
					p.o.children("a").each(function () { nms.push($(this).text().replace(/^\s+/g,"")); });
					return this._check_unique(nms, p.np.find("> ul > li").not(p.o), "check_move");
				}
				return true;
			}
		}
	});
})(jQuery);
//*/

/*
 * jsTree wholerow plugin
 * Makes select and hover work on the entire width of the node
 * MAY BE HEAVY IN LARGE DOM
 */
(function ($) {
	$.jstree.plugin("wholerow", {
		__init : function () {
			if(!this.data.ui) { throw "jsTree wholerow: jsTree UI plugin not included."; }
			this.data.wholerow.html = false;
			this.data.wholerow.to = false;
			this.get_container()
				.bind("init.jstree", $.proxy(function (e, data) { 
						this._get_settings().core.animation = 0;
					}, this))
				.bind("open_node.jstree create_node.jstree clean_node.jstree loaded.jstree", $.proxy(function (e, data) { 
						this._prepare_wholerow_span( data && data.rslt && data.rslt.obj ? data.rslt.obj : -1 );
					}, this))
				.bind("search.jstree clear_search.jstree reopen.jstree after_open.jstree after_close.jstree create_node.jstree delete_node.jstree clean_node.jstree", $.proxy(function (e, data) { 
						if(this.data.to) { clearTimeout(this.data.to); }
						this.data.to = setTimeout( (function (t, o) { return function() { t._prepare_wholerow_ul(o); }; })(this,  data && data.rslt && data.rslt.obj ? data.rslt.obj : -1), 0);
					}, this))
				.bind("deselect_all.jstree", $.proxy(function (e, data) { 
						this.get_container().find(" > .jstree-wholerow .jstree-clicked").removeClass("jstree-clicked " + (this.data.themeroller ? this._get_settings().themeroller.item_a : "" ));
					}, this))
				.bind("select_node.jstree deselect_node.jstree ", $.proxy(function (e, data) { 
						data.rslt.obj.each(function () { 
							var ref = data.inst.get_container().find(" > .jstree-wholerow li:visible:eq(" + ( parseInt((($(this).offset().top - data.inst.get_container().offset().top + data.inst.get_container()[0].scrollTop) / data.inst.data.core.li_height),10)) + ")");
							// ref.children("a")[e.type === "select_node" ? "addClass" : "removeClass"]("jstree-clicked");
							ref.children("a").attr("class",data.rslt.obj.children("a").attr("class"));
						});
					}, this))
				.bind("hover_node.jstree dehover_node.jstree", $.proxy(function (e, data) { 
						this.get_container().find(" > .jstree-wholerow .jstree-hovered").removeClass("jstree-hovered " + (this.data.themeroller ? this._get_settings().themeroller.item_h : "" ));
						if(e.type === "hover_node") {
							var ref = this.get_container().find(" > .jstree-wholerow li:visible:eq(" + ( parseInt(((data.rslt.obj.offset().top - this.get_container().offset().top + this.get_container()[0].scrollTop) / this.data.core.li_height),10)) + ")");
							// ref.children("a").addClass("jstree-hovered");
							ref.children("a").attr("class",data.rslt.obj.children(".jstree-hovered").attr("class"));
						}
					}, this))
				.delegate(".jstree-wholerow-span, ins.jstree-icon, li", "click.jstree", function (e) {
						var n = $(e.currentTarget);
						if(e.target.tagName === "A" || (e.target.tagName === "INS" && n.closest("li").is(".jstree-open, .jstree-closed"))) { return; }
						n.closest("li").children("a:visible:eq(0)").click();
						e.stopImmediatePropagation();
					})
				.delegate("li", "mouseover.jstree", $.proxy(function (e) {
						e.stopImmediatePropagation();
						if($(e.currentTarget).children(".jstree-hovered, .jstree-clicked").length) { return false; }
						this.hover_node(e.currentTarget);
						return false;
					}, this))
				.delegate("li", "mouseleave.jstree", $.proxy(function (e) {
						if($(e.currentTarget).children("a").hasClass("jstree-hovered").length) { return; }
						this.dehover_node(e.currentTarget);
					}, this));
			if(is_ie7 || is_ie6) {
				$.vakata.css.add_sheet({ str : ".jstree-" + this.get_index() + " { position:relative; } ", title : "jstree" });
			}
		},
		defaults : {
		},
		__destroy : function () {
			this.get_container().children(".jstree-wholerow").remove();
			this.get_container().find(".jstree-wholerow-span").remove();
		},
		_fn : {
			_prepare_wholerow_span : function (obj) {
				obj = !obj || obj == -1 ? this.get_container().find("> ul > li") : this._get_node(obj);
				if(obj === false) { return; } // added for removing root nodes
				obj.each(function () {
					$(this).find("li").andSelf().each(function () {
						var $t = $(this);
						if($t.children(".jstree-wholerow-span").length) { return true; }
						$t.prepend("<span class='jstree-wholerow-span' style='width:" + ($t.parentsUntil(".jstree","li").length * 18) + "px;'>&#160;</span>");
					});
				});
			},
			_prepare_wholerow_ul : function () {
				var o = this.get_container().children("ul").eq(0), h = o.html();
				o.addClass("jstree-wholerow-real");
				if(this.data.wholerow.last_html !== h) {
					this.data.wholerow.last_html = h;
					this.get_container().children(".jstree-wholerow").remove();
					this.get_container().append(
						o.clone().removeClass("jstree-wholerow-real")
							.wrapAll("<div class='jstree-wholerow' />").parent()
							.width(o.parent()[0].scrollWidth)
							.css("top", (o.height() + ( is_ie7 ? 5 : 0)) * -1 )
							.find("li[id]").each(function () { this.removeAttribute("id"); }).end()
					);
				}
			}
		}
	});
	$(function() {
		var css_string = '' + 
			'.jstree .jstree-wholerow-real { position:relative; z-index:1; } ' + 
			'.jstree .jstree-wholerow-real li { cursor:pointer; } ' + 
			'.jstree .jstree-wholerow-real a { border-left-color:transparent !important; border-right-color:transparent !important; } ' + 
			'.jstree .jstree-wholerow { position:relative; z-index:0; height:0; } ' + 
			'.jstree .jstree-wholerow ul, .jstree .jstree-wholerow li { width:100%; } ' + 
			'.jstree .jstree-wholerow, .jstree .jstree-wholerow ul, .jstree .jstree-wholerow li, .jstree .jstree-wholerow a { margin:0 !important; padding:0 !important; } ' + 
			'.jstree .jstree-wholerow, .jstree .jstree-wholerow ul, .jstree .jstree-wholerow li { background:transparent !important; }' + 
			'.jstree .jstree-wholerow ins, .jstree .jstree-wholerow span, .jstree .jstree-wholerow input { display:none !important; }' + 
			'.jstree .jstree-wholerow a, .jstree .jstree-wholerow a:hover { text-indent:-9999px; !important; width:100%; padding:0 !important; border-right-width:0px !important; border-left-width:0px !important; } ' + 
			'.jstree .jstree-wholerow-span { position:absolute; left:0; margin:0px; padding:0; height:18px; border-width:0; padding:0; z-index:0; }';
		if(is_ff2) {
			css_string += '' + 
				'.jstree .jstree-wholerow a { display:block; height:18px; margin:0; padding:0; border:0; } ' + 
				'.jstree .jstree-wholerow-real a { border-color:transparent !important; } ';
		}
		if(is_ie7 || is_ie6) {
			css_string += '' + 
				'.jstree .jstree-wholerow, .jstree .jstree-wholerow li, .jstree .jstree-wholerow ul, .jstree .jstree-wholerow a { margin:0; padding:0; line-height:18px; } ' + 
				'.jstree .jstree-wholerow a { display:block; height:18px; line-height:18px; overflow:hidden; } ';
		}
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});
})(jQuery);
//*/

/*
* jsTree model plugin
* This plugin gets jstree to use a class model to retrieve data, creating great dynamism
*/
(function ($) {
	var nodeInterface = ["getChildren","getChildrenCount","getAttr","getName","getProps"],
		validateInterface = function(obj, inter) {
			var valid = true;
			obj = obj || {};
			inter = [].concat(inter);
			$.each(inter, function (i, v) {
				if(!$.isFunction(obj[v])) { valid = false; return false; }
			});
			return valid;
		};
	$.jstree.plugin("model", {
		__init : function () {
			if(!this.data.json_data) { throw "jsTree model: jsTree json_data plugin not included."; }
			this._get_settings().json_data.data = function (n, b) {
				var obj = (n == -1) ? this._get_settings().model.object : n.data("jstree_model");
				if(!validateInterface(obj, nodeInterface)) { return b.call(null, false); }
				if(this._get_settings().model.async) {
					obj.getChildren($.proxy(function (data) {
						this.model_done(data, b);
					}, this));
				}
				else {
					this.model_done(obj.getChildren(), b);
				}
			};
		},
		defaults : {
			object : false,
			id_prefix : false,
			async : false
		},
		_fn : {
			model_done : function (data, callback) {
				var ret = [], 
					s = this._get_settings(),
					_this = this;

				if(!$.isArray(data)) { data = [data]; }
				$.each(data, function (i, nd) {
					var r = nd.getProps() || {};
					r.attr = nd.getAttr() || {};
					if(nd.getChildrenCount()) { r.state = "closed"; }
					r.data = nd.getName();
					if(!$.isArray(r.data)) { r.data = [r.data]; }
					if(_this.data.types && $.isFunction(nd.getType)) {
						r.attr[s.types.type_attr] = nd.getType();
					}
					if(r.attr.id && s.model.id_prefix) { r.attr.id = s.model.id_prefix + r.attr.id; }
					if(!r.metadata) { r.metadata = { }; }
					r.metadata.jstree_model = nd;
					ret.push(r);
				});
				callback.call(null, ret);
			}
		}
	});
})(jQuery);
//*/

})();

define("jquery.jstree-patched", ["jquery"], function(){});

/*
 * jQuery Hotkeys Plugin
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * Based upon the plugin by Tzury Bar Yochay:
 * http://github.com/tzuryby/hotkeys
 *
 * Original idea by:
 * Binny V A, http://www.openjs.com/scripts/events/keyboard_shortcuts/
*/

(function(jQuery){
	
	jQuery.hotkeys = {
		version: "0.8",

		specialKeys: {
			8: "backspace", 9: "tab", 13: "return", 16: "shift", 17: "ctrl", 18: "alt", 19: "pause",
			20: "capslock", 27: "esc", 32: "space", 33: "pageup", 34: "pagedown", 35: "end", 36: "home",
			37: "left", 38: "up", 39: "right", 40: "down", 45: "insert", 46: "del", 
			96: "0", 97: "1", 98: "2", 99: "3", 100: "4", 101: "5", 102: "6", 103: "7",
			104: "8", 105: "9", 106: "*", 107: "+", 109: "-", 110: ".", 111 : "/", 
			112: "f1", 113: "f2", 114: "f3", 115: "f4", 116: "f5", 117: "f6", 118: "f7", 119: "f8", 
			120: "f9", 121: "f10", 122: "f11", 123: "f12", 144: "numlock", 145: "scroll", 191: "/", 224: "meta"
		},
	
		shiftNums: {
			"`": "~", "1": "!", "2": "@", "3": "#", "4": "$", "5": "%", "6": "^", "7": "&", 
			"8": "*", "9": "(", "0": ")", "-": "_", "=": "+", ";": ": ", "'": "\"", ",": "<", 
			".": ">",  "/": "?",  "\\": "|"
		}
	};

	function keyHandler( handleObj ) {
		// Only care when a possible input has been specified
		if ( typeof handleObj.data !== "string" ) {
			return;
		}
		
		var origHandler = handleObj.handler,
			keys = handleObj.data.toLowerCase().split(" ");
	
		handleObj.handler = function( event ) {
			// Don't fire in text-accepting inputs that we didn't directly bind to
			if ( this !== event.target && (/textarea|select/i.test( event.target.nodeName ) ||
				 event.target.type === "text") ) {
				return;
			}
			
			// Keypress represents characters, not special keys
			var special = event.type !== "keypress" && jQuery.hotkeys.specialKeys[ event.which ],
				character = String.fromCharCode( event.which ).toLowerCase(),
				key, modif = "", possible = {};

			// check combinations (alt|ctrl|shift+anything)
			if ( event.altKey && special !== "alt" ) {
				modif += "alt+";
			}

			if ( event.ctrlKey && special !== "ctrl" ) {
				modif += "ctrl+";
			}
			
			// TODO: Need to make sure this works consistently across platforms
			if ( event.metaKey && !event.ctrlKey && special !== "meta" ) {
				modif += "meta+";
			}

			if ( event.shiftKey && special !== "shift" ) {
				modif += "shift+";
			}

			if ( special ) {
				possible[ modif + special ] = true;

			} else {
				possible[ modif + character ] = true;
				possible[ modif + jQuery.hotkeys.shiftNums[ character ] ] = true;

				// "$" can be triggered as "Shift+4" or "Shift+$" or just "$"
				if ( modif === "shift+" ) {
					possible[ jQuery.hotkeys.shiftNums[ character ] ] = true;
				}
			}

			for ( var i = 0, l = keys.length; i < l; i++ ) {
				if ( possible[ keys[i] ] ) {
					return origHandler.apply( this, arguments );
				}
			}
		};
	}

	jQuery.each([ "keydown", "keyup", "keypress" ], function() {
		jQuery.event.special[ this ] = { add: keyHandler };
	});

})( jQuery );
define("jquery.hotkeys", ["jquery"], function(){});



define('src/SmartTree',[	'src/uiConfig',
			'src/CslNode',
			'src/options',
			'src/cslData',
			'src/debug',
			'jquery.jstree-patched',
			'jquery.hotkeys'
		], function (
			CSLEDIT_uiConfig,
			CSLEDIT_CslNode,
			CSLEDIT_options,
			CSLEDIT_data,
			debug,
			jstree
		) {
	var CSLEDIT_SmartTree = function (treeElement, nodePaths, enableMacroLinks /*optional*/, leafNodes /*optional*/) {
		var ranges,
			macroLinks, // like symlinks for macros
						// [{ instanceCslId: ?, macroRange: ?}]
			callbacks,
			verifyAllChanges = false, // does a complete check against CSLEDIT_data after
									  // every change for debugging
			oldSelectedNode = -1;

		leafNodes = leafNodes || [];

		var setCallbacks = function (_callbacks) {
			callbacks = _callbacks;
		};
		
		var pathContainsLeafNode = function (nodePath) {
			// NOTE: this doesn't use the parent element, so "contributor/name" and "names/name"
			//       would *both* be leaf nodes if "name" is given
			var result = false,
				path = nodePath.split("/");
			$.each(leafNodes, function (i, leafNode) {
				if (path.indexOf(leafNode) !== -1) {
					result = true;
					return false;
				}
			});
			return result;
		};

		// Check the tree matches the data - for testing and debugging
		var verifyTree = function () {
			var cslData = CSLEDIT_data.get();

			if (verifyAllChanges) {
				console.time("verifyTree");
				// Check for inconsistencies with CSLEDIT_data
				treeElement.find('li[cslid]').each(function () {
					var $this = $(this),
						cslId;

					cslId = parseInt($this.attr('cslid'), 10);
				debug.assertEqual(CSLEDIT_data.getNode(cslId, cslData).name, $this.attr('rel'));
				});

				// Can't have non-macrolink nodes as children of a text node
			debug.assertEqual(treeElement.find('li[cslid][rel=text] li[macrolink!=true]').length, 0);
				console.timeEnd("verifyTree");
			}
		};
		
		var createTree = function () {
			var jsTreeData,
				nodeTypes;

			jsTreeData = jsTreeDataFromCslData(nodePaths);

			treeElement.on("loaded.jstree", function () {
				// set up range root nodes
				$.each(ranges, function (index, range) {
					range.rootNode = treeElement.children('ul').children(
						'li[cslid=' + range.first + ']');
				debug.assertEqual(range.rootNode.length, 1);
				});
				callbacks.loaded();

				verifyTree();
			});
			treeElement.on("select_node.jstree", function (event, ui) {
				treeElement.jstree("set_focus");

				if (selectedNode() === oldSelectedNode) {
					treeElement.jstree("toggle_node", ui.rslt.obj);
				} else {
					treeElement.jstree("open_node", ui.rslt.obj);
				}
				oldSelectedNode = selectedNode();

				callbacks.selectNode(event, ui);
			});
			
			// build the node types from the uiConfig data		
			nodeTypes = {};
			$.each(CSLEDIT_uiConfig.nodeIcons, function (type, icon) {
				nodeTypes[type] = { icon : { image : CSLEDIT_options.getUrl(icon) } };
			});

			treeElement.jstree({
				"json_data" : { data : jsTreeData },
				"types" : { types : nodeTypes },
				"plugins" : ["themes", "json_data", "ui", "crrm", "dnd", /*"contextmenu",*/
					"types", "hotkeys"],
				//"core" : { "initially_open" : [ "node1" ] },
				"core" : { "animation" : 200 },
				"ui" : { /*"initially_select" : [ "cslTreeNode0" ],*/ "select_limit" : 1 },
				"dnd" : {
					"open_timeout" : 800,
					"move_requested" : callbacks.moveNode
				},
				"crrm" : {
					"move" : {
						// only allow re-ordering, not moving to different nodes
						"check_move" : function (move) {
							return callbacks.checkMove(
								parseInt(move.o.attr("cslid"), 10),
								parseInt(move.r.attr("cslid"), 10), move.p);
						}
					}
				},
				"hotkeys" : {
					"del" : callbacks.deleteNode,
					"f2" : false
				}
				
			});
		};
		
		var jsTreeDataFromCslData = function (nodePaths) {
			var cslNodes = [],
				jsTreeData = [],
				cslData = CSLEDIT_data.get();

			ranges = [];
			macroLinks = [];

			$.each(nodePaths, function (i, path) {
				var nodes = CSLEDIT_data.getNodesFromPath(path, cslData);
				cslNodes = cslNodes.concat(nodes);
			});

			$.each(cslNodes, function (i, node) {
				var lastCslId = [ -1 ],
					firstCslId = node.cslId;
				jsTreeData.push(jsTreeDataFromCslData_inner(node, lastCslId));
				ranges.push({
					first : firstCslId,
					last : lastCslId[0]
				});
			});

			return jsTreeData;
		};

		var jsTreeDataFromCslData_inner = function (cslData, lastCslId, macroLink) {
			var index,
				children = [],
				cslNodes = [],
				thisCslData,
				macro;

			if (typeof cslData.cslId === "undefined") {
				cslData.cslId = -1;
			}
			cslData.children = cslData.children || [];

			if (cslData.cslId > lastCslId[0]) {
				lastCslId[0] = cslData.cslId;
			}

			if (!pathContainsLeafNode(cslData.name)) {
				for (index = 0; index < cslData.children.length; index++) {
					children.push(jsTreeDataFromCslData_inner(
						cslData.children[index], lastCslId, macroLink));
				}
			}

			var jsTreeData = {
				data : CSLEDIT_uiConfig.displayNameFromNode(cslData),
				attr : {
					rel : cslData.name,
					cslid : cslData.cslId
				},
				children : children
			};

			if (typeof macroLink !== "undefined") {
				jsTreeData.attr.macrolink = macroLink;
			}

			if (enableMacroLinks) {
				// Add 'symlink' to Macro
				macro = new CSLEDIT_CslNode(cslData).getAttr("macro");
				if (cslData.name === "text" && macro !== "") {
					addMacro(jsTreeData, cslData, macro);
				}
			}

			return jsTreeData;
		};

		var addMacro = function (jsTreeData, cslNode, macroName) {
			var macroNodes,
				macroNode,
				lastCslId,
				index;

			// delete any existing macroLinks
			for (index = 0; index < macroLinks.length; index++) {
				if (macroLinks[index].instanceCslId === cslNode.cslId) {
					macroLinks.splice(index, 1);
					index--;
				}
			}

			// find the macro node:
			macroNodes = CSLEDIT_data.getNodesFromPath("style/macro");

			$.each(macroNodes, function (i, node) {
				if (new CSLEDIT_CslNode(node).getAttr("name") === macroName) {
					macroNode = node;
					return false;
				}
			});

			if (typeof macroNode === "undefined") {
				debug.log('WARNING: macro "' + macroName + '" doesn\'t exist');
				return;
			}
			
			lastCslId = [macroNode.cslId];
			
			// add the macro's children to this node
			$.each(macroNode.children, function (i, childNode) {
				jsTreeData.children.push(jsTreeDataFromCslData_inner(childNode, lastCslId, true));
			});

			macroLinks.push({
				instanceCslId : cslNode.cslId, 
				first: macroNode.cslId,
				last: lastCslId[0]
			});
		};

		var selectedNode = function () {
			var selected,
				cslid;

			selected = treeElement.jstree('get_selected'),
			cslid = parseInt(selected.attr("cslid"), 10);
			return cslid;
		};

		var expandNode = function (id) {
			treeElement.jstree("open_node", 'li[cslid=' + id + ']');
		};

		var rangeIndex = function (id) {
			var result = -1,
				index = 0;	

			$.each(ranges, function (i, range) {
				if (id >= range.first && id <= range.last) {
					result = index;
					return false; // to jump out of the $.each() loop
				}
				index++;
			});

			return result;
		};

		var macroLinksShiftCslIds = function (id, nodesAdded) {
			treeElement.find('li[cslid][macrolink="true"]').each(function () {
				var $this = $(this),
					cslId;
				
				cslId = parseInt($this.attr('cslid'), 10);
				if (cslId >= id) {
					$this.attr('cslid', cslId + nodesAdded);
				}
			});

			$.each(macroLinks, function (i, macroLink) {
				if (macroLink.first >= id) {
					macroLink.first += nodesAdded;
				}
				if (macroLink.last >= id) {
					macroLink.last += nodesAdded;
				}
			});
		};
			
		var macroLinksAddNode = function (parentId, position, newNode, nodesAdded) {
			var id = newNode.cslId,
				parentNodes;

			// Shift references to the macro definition
			macroLinksShiftCslIds(id, nodesAdded);

			// TODO: check if new node is a macro instance
			parentNodes = treeElement.find('li[cslid=' + parentId + '][macrolink="true"]');

			// shift references to the instance cslIds
			$.each(macroLinks, function (i, macroLink) {
				if (macroLink.instanceCslId >= id) {
					macroLink.instanceCslId += nodesAdded;
				}
			});

			// Add macro node children to all instances
			$.each(macroLinks, function (i, macroLink) {
				if (macroLink.first === parentId) {
					parentNodes = parentNodes.add(
						treeElement.find('li[cslid=' + macroLink.instanceCslId + ']'));
				debug.assert(parentNodes.length > 0);
				}
			});

			
			parentNodes.each(function () {
				createSubTree($(this), position,
					jsTreeDataFromCslData_inner(newNode, [id], true));
			});
		};

		var macroLinksDeleteNode = function (nodeId, nodesDeleted) {
			var index,
				macroLink;
			
			treeElement.find('li[cslid=' + nodeId + '][macrolink="true"]').each(function () {
				treeElement.jstree('remove', $(this));
			});

			// Delete macro node children from all instances
			for (index = 0; index < macroLinks.length; index++) {
				macroLink = macroLinks[index];

				if (macroLink.instanceCslId === nodeId) {
					macroLinks.splice(index, 1);
					break;
				}
				if (macroLink.first === nodeId) {
					debug.log("WARNING: macro deleted, leaving broken instance links");
					// remove all children
					treeElement.find('li[cslid=' + macroLink.instanceCslId + '][macrolink!=true]').each(
						function () {
							$.jstree._reference(treeElement)._get_children($(this)).each(function () {
								treeElement.jstree('remove', $(this));
							});
						});

					// clean up macroLinks array:
					macroLinks.splice(index, 1);
					index--;
				}
			}
			
			macroLinksShiftCslIds(nodeId + nodesDeleted, -nodesDeleted);
			// shift references to the instance cslIds
			$.each(macroLinks, function (i, macroLink) {
				if (macroLink.instanceCslId >= nodeId + nodesDeleted + 1) {
					macroLink.instanceCslId -= nodesDeleted;
				}
			});
		};

		var macroLinksUpdateNode = function (id, _amendedNode) {
			var amendedNode = new CSLEDIT_CslNode(_amendedNode),
				macroName,
				jsTreeData = {children: [], attr: [], data: ""},
				removeChildren = false,
				addNewChildren = false;

			if (amendedNode.name !== "text") {
				return;
			}
			
			macroName = amendedNode.getAttr("macro");
			if (macroName === "") {
				removeChildren = true;
			} else if (amendedNode.name === "text") {
				addMacro(jsTreeData, amendedNode, macroName);
				removeChildren = true;
				addNewChildren = true;
			}

			if (removeChildren || addNewChildren) {
				treeElement.find('[cslid=' + amendedNode.cslId + ']').each(function () {
					var $this = $(this);
					if (removeChildren) {
						$.jstree._reference(treeElement)._get_children($this).each(function () {
							treeElement.jstree('remove', $(this));
						});
					}
					if (addNewChildren) {
						$.each(jsTreeData.children, function (i, child) {
							createSubTree($this, i, child);
						});
					}
				});
			}
		};

		var addNode = function (parentId, position, newNode, nodesAdded) {
			var id,	parentNode,	thisRangeIndex,	currentCslId, range,
				matchingCslNodes, newTreeNode;

			id = newNode.cslId;

			// note: no two ranges are expected to have the same parent id
			thisRangeIndex = rangeIndex(parentId);

			// shift ranges
			$.each(ranges, function (index, range) {
				shiftCslIds(range, id, nodesAdded);
				
				// if adding to the end of a range, expand the range
				if (thisRangeIndex === index && id > range.last) {
					range.last += nodesAdded;
				}
			});

			if (enableMacroLinks) {
				macroLinksAddNode(parentId, position, newNode, nodesAdded);
			}

			if (thisRangeIndex === -1) {
				matchingCslNodes = [];
				// check if the new node belongs to this smartTree
				$.each(nodePaths, function (i, path) {
					matchingCslNodes = matchingCslNodes.concat(CSLEDIT_data.getNodesFromPath(path));
				});

				$.each(matchingCslNodes, function (i, node) {
					var lastCslId = [-1];
					if (node.cslId === newNode.cslId) {
						var newJsTreeNode;
						newJsTreeNode = jsTreeDataFromCslData_inner(newNode, lastCslId);
						createSubTree(-1, "last", newJsTreeNode);
						
						var newTreeNode = treeElement.find('li[cslid="' + newNode.cslId + '"]');
						ranges.push({
							first : newNode.cslId,
							last : newNode.cslId + CSLEDIT_data.numNodes(newNode) - 1,
							rootNode : newTreeNode
						});
						
						return false;
					}
				});

				return;
			}
			range = ranges[thisRangeIndex];

			
			if (!pathContainsLeafNode(CSLEDIT_data.getNodePath(newNode.cslId))) {
				parentNode = treeElement.find('li[cslid="' + parentId + '"][macrolink!="true"]');
			debug.assertEqual(parentNode.length, 1);
				createSubTree(parentNode, position, jsTreeDataFromCslData_inner(newNode, [id]));
				macroLinksUpdateNode(newNode.cslId, newNode);
			}
			verifyTree();
		};

		var totalCreateNodeTime = 0;

		// needed because "create_node" doesn't allow adding nodes with children
		var createSubTree = function (parentNode, position, jsTreeData) {
			var newNode;

			newNode = treeElement.jstree('create_node', parentNode, position, 
				{
					data : jsTreeData.data
					// attr : jsTreeData.attr
					// Don't know why, but 'create_node' fails if including a
					// 'ref' attribute on a root node. It works to just add the
					// attribute later though
				});
			newNode.attr(jsTreeData.attr);

			$.each(jsTreeData.children, function (i, child) {
				createSubTree(newNode, i, child);
			});
		};

		var shiftCslIds = function (range, fromId, amount) {
			var cslId;

			if (range.first >= fromId) {
				range.rootNode.attr("cslid", parseInt(range.rootNode.attr("cslid"), 10) + amount);
				range.rootNode.find('li[cslid][macroLink!="true"]').each(function () {
					cslId = parseInt($(this).attr("cslid"), 10);
				debug.assert(cslId <= range.last);
					if (cslId >= range.first) {
						$(this).attr("cslid", cslId + amount);
					}
				});
				
				range.first += amount;
				range.last += amount;
			} else if (range.last >= fromId) {
				range.rootNode.find('li[cslid][macroLink!="true"]').each(function () {
					cslId = parseInt($(this).attr("cslid"), 10);
				debug.assert(cslId <= range.last);
					if (cslId >= fromId) {
						$(this).attr("cslid", cslId + amount);
					}
				});
				range.last += amount;
			}
		};

		var deleteNode = function (id, nodesDeleted) {
			var node,
				thisRangeIndex = rangeIndex(id),
				allNodes,
				currentCslId,
				range;

			// shift ranges, except for ones containing the deleted node
			$.each(ranges, function (index, range) {
				if (thisRangeIndex !== index) {
					shiftCslIds(range, id + nodesDeleted, -nodesDeleted);
				}
			});

			if (enableMacroLinks) {
				macroLinksDeleteNode(id, nodesDeleted);
			}

			if (thisRangeIndex === -1) {
				return;
			}
			range = ranges[thisRangeIndex];

			if (id === range.first) {
				ranges.splice(thisRangeIndex, 1);

				treeElement.jstree("remove", range.rootNode);

			} else { // update range
				node = treeElement.find('li[cslid="' + id + '"][macrolink!="true"]');
			debug.assert(node.length > 0);
			debug.assert(id !== 0);

				treeElement.jstree("remove", node);

				// shift this range
				shiftCslIds(range, id, -nodesDeleted);
			}

			verifyTree();
		};

		var amendNode = function (id, amendedNode) {
			var thisRangeIndex = rangeIndex(id),
				nodes = treeElement.find('li[cslid="' + id + '"]');

			nodes.each(function () {
				treeElement.jstree('rename_node', $(this), CSLEDIT_uiConfig.displayNameFromNode(amendedNode));
			});
			
			if (thisRangeIndex === -1) {
				return;
			}

			if (enableMacroLinks) {
				macroLinksUpdateNode(amendedNode.cslId, amendedNode);
			}
			
			verifyTree();
		};

		var getSelectedNodePath = function () {
			var selectedNodes = [],
				treeNode,
				cslId;

			treeNode = treeElement.jstree('get_selected'),
			cslId = treeNode.attr("cslid");

			while (typeof cslId !== "undefined") {
				selectedNodes.splice(0, 0, parseInt(cslId, 10));
				
				treeNode = treeNode.parent().parent();
				cslId = treeNode.attr("cslid");
			}

			return selectedNodes;
		};

		return {
			createTree : createTree,
			deselectAll : function () {
				treeElement.jstree("deselect_all");
			},
			selectedNode : selectedNode,
			expandNode : expandNode,
			addNode : addNode,
			deleteNode : deleteNode,
			amendNode : amendNode,

			shiftCslIds : shiftCslIds,

			setCallbacks : setCallbacks,

			setVerifyAllChanges : function (verify) {
				verifyAllChanges = verify;
			},

			getRanges : function () {
				return ranges;
			},
			getMacroLinks : function () {
				return macroLinks;
			},
			getSelectedNodePath : getSelectedNodePath,

			collapseAll : function () {
				treeElement.jstree("close_all");
			}
		};
	};

	return CSLEDIT_SmartTree;
});



// Heading for a smart tree
//
// Can use a NodeWatcher to associate the heading with a specific CSL node path

define('src/SmartTreeHeading',
		[	'src/NodeWatcher',
			'src/cslData',
			'src/debug'
		],
		function (
			CSLEDIT_NodeWatcher,
			CSLEDIT_data,
			debug
		) {
	var CSLEDIT_SmartTreeHeading = function (element, nodePath, title, possibleChildren, showPropertyPanel) {
		var that = this;
			
		this.element = element;
		this.title = title;

		this.possibleChildren = possibleChildren;
		this.showPropertyPanel = showPropertyPanel;

		if (typeof(nodePath) === "undefined" || nodePath === "") {
			this.updateHtml(null);
		} else {
			this.nodeWatcher = new CSLEDIT_NodeWatcher(nodePath, CSLEDIT_data, function (nodeData) {
				that.updateHtml(nodeData);
			});

			this.addNode = function (id, position, nodeData, numNodes) {
				that.nodeWatcher.addNode(id, position, nodeData, numNodes);
			};
			this.deleteNode = function (id, numNodes) {
				that.nodeWatcher.deleteNode(id, numNodes);
			};
			this.amendNode = function (id, nodeData) {
				that.nodeWatcher.amendNode(id, nodeData);
			};

			this.element.click(function () {
				if (that.nodeData !== null) {
					debug.log("selecting node " + that.nodeWatcher.nodeData.cslId);
					that.callbacks.selectNode(that.nodeWatcher.nodeData.cslId);
				}
			});
		}
	};

	CSLEDIT_SmartTreeHeading.prototype.updateHtml = function (nodeData) {
		var cslidAttribute;

		if (nodeData !== null) {
			cslidAttribute = 'cslid="' + nodeData.cslId + '"';
		}
		this.element.html('<h3 class="smartTreeHeading"><span ' + cslidAttribute + '>' +
		   this.title + '</span></h3>');

		debug.log("updated smart tree to " + this.element.html());
	};

	CSLEDIT_SmartTreeHeading.prototype.setCallbacks = function (callbacks) {
		this.callbacks = callbacks;
	};

	CSLEDIT_SmartTreeHeading.prototype.selectedNode = function () {
		if (this.nodeWatcher.nodeData !== null) {
			return this.nodeWatcher.nodeData.cslId;
		} else {
			return null;
		}
	};

	CSLEDIT_SmartTreeHeading.prototype.getSelectedNodePath = function () {
		var splitNodePath = this.nodeWatcher.nodePath.split("/"),
			nodePath = [],
			cslIdPath = [],
			nodes;

		while (splitNodePath.length > 0) {
			nodePath.push(splitNodePath.splice(0, 1));
			nodes = CSLEDIT_data.getNodesFromPath(nodePath.join("/"));
		debug.assertEqual(nodes.length, 1);
			cslIdPath.push(nodes[0].cslId);
		}

		return cslIdPath;
	};

	return CSLEDIT_SmartTreeHeading;
});



define('src/MultiPanel',[],function () {
	var CSLEDIT_MultiPanel = function (id) {
		var that = this;

		this.element = $('<fieldset class="multiPanel" id="' + id + '"></fieldset>');
		this.typeLegend = $('<legend class="typeLegend">Type:</legend>');
		this.typeSelect = $('<select class="typeSelect"/>');
		this.typeLegend.append(this.typeSelect);

		this.currentContentPanel = $('<div class="contentPanel"/>');
		this.element.append(this.typeLegend);
		this.element.append(this.currentContentPanel);
		this.contentPanels = [];

		// a non-anonymous function allowing this.update to access the correct 'this'
		this.updateFunction = function () {
			that.update.apply(that);
		};

		this.typeSelect.on('change', this.updateFunction);
	};

	CSLEDIT_MultiPanel.prototype.onChange = function (callback) {
		this.onChangeCallback = callback;
	};

	CSLEDIT_MultiPanel.prototype.addPanel = function (name) {
		var that = this,
			newPanel;

		this.typeSelect.append($('<option>' + name + '</option>'));

		newPanel = $('<div/>').css({display: "none"});
		this.contentPanels.push(newPanel);
		this.currentContentPanel.append(newPanel);
	};

	CSLEDIT_MultiPanel.prototype.update = function () {
		var that = this,
			selectedIndex = this.typeSelect.find('option').index(
				this.typeSelect.find('option:selected'));

		// display the correct panel
		$.each(that.contentPanels, function (i, panel) {
			if (i === selectedIndex) {
				panel.css({display: ""});
			} else {
				panel.css({display: "none"});
			}
		});

		if (typeof that.onChangeCallback === "function") {
			that.onChangeCallback(selectedIndex);
		}
	};

	CSLEDIT_MultiPanel.prototype.select = function (index) {
		this.typeSelect.val(this.typeSelect.find('option').eq(index).html());
		this.update();
	};
	return CSLEDIT_MultiPanel;
});



/* provides a way to edit space-delimited list of stings,
 * each of which must be one of the supplied values
 */

define('src/MultiComboBox',['src/debug'], function (debug) {
	var CSLEDIT_MultiComboBox = function (element, possibleValues, onChange, unique) {
		this._element = element;
		this._values = [];
		this._onChange = onChange;
		this._unique = unique;

		debug.assert(possibleValues.length > 0);
		this._selectHtml = '<select><option>' +	possibleValues.join('</option><option>') +
			'</option></select>';

		this._refresh(true);
	};

	CSLEDIT_MultiComboBox.prototype.getElement = function () {
		return this._element;
	};

	CSLEDIT_MultiComboBox.prototype.setTooltip = function (tooltip) {
		this._element.attr("title", tooltip);
	};

	CSLEDIT_MultiComboBox.prototype.val = function (val, suppressOnChange) {
		if (typeof val === "undefined") {
			this._readValues();
			return this._values.join(" ");
		} else {
			if (val === "") {
				this._values = [];
			} else {
				this._values = val.split(" ");
			}
			if (typeof suppressOnChange === "undefined") {
				suppressOnChange = false;
			}
			this._refresh(suppressOnChange);
		}
	};

	CSLEDIT_MultiComboBox.prototype._readValues = function () {
		var that = this;
		// repopulate _values from current combo box values
		that._values = [];
		this._element.find('select').each(function () {
			that._values.push($(this).val());
		});
	};

	CSLEDIT_MultiComboBox.prototype._refresh = function (suppressOnChange) {
		var that = this,
			table = $('<table></table>'),
			addButton;

		this._element.html('');
		
		$.each(this._values, function (i, value) {
			var row = $('<tr></tr>'),
				select = $(that._selectHtml).css({"margin-right": 0}),
				deleteButton = $('<button class="delete" data-index="' + i +
					'"> - </button>').css({"margin-left": 0});

			select.val(value);

			row.append($('<td></td>').append(select));
			row.append($('<td></td>').append(deleteButton));
			table.append(row);
		});

		addButton = $('<button class="add">+</button>');
		table.append($('<tr></tr>').append($('<td></td>').append(addButton)));

		this._element.append(table);

		this._element.find('button.delete').on('click', function (event) {
			var index = $(event.target).attr("data-index");
			that._readValues();
			that._values.splice(index, 1);
			that._refresh();
		});

		this._element.find('button.add').on('click', function (event) {
			that._readValues();
			that._values.push('');
			that._refresh();
		});

		this._element.find('select').on('change', function (event) {
			that._changed();
		});

		if (!suppressOnChange) {
			that._changed();
		}
	};

	CSLEDIT_MultiComboBox.prototype._changed = function () {
		if (typeof this._onChange !== "undefined") {
			this._readValues();
			this._onChange(this._values.join(' '));
		}
	};
	return CSLEDIT_MultiComboBox;
});



define('src/genericPropertyPanel',[	'src/MultiPanel',
			'src/MultiComboBox',
			'src/uiConfig',
			'src/CslNode',
			'src/cslData',
			'src/debug'
		], function (
			CSLEDIT_MultiPanel,
			CSLEDIT_MultiComboBox,
			CSLEDIT_uiConfig,
			CSLEDIT_CslNode,
			CSLEDIT_data,
			debug
		) {
	var onChangeTimeout,
		multiInputs,
		nodeData,
		newAttributes,
		toolbar,
		panel,
		checkboxControlIndex,
		checkboxControls,
		checkboxControlSchema = {
			'font-weight' : {
				'normal' : 'default',
				'bold' : { text : '<strong>B</strong>' }
				// 'light' not supported
			},
			'font-style' : {
				'italic' : { text : '<i>I</i>' },
				'normal' : 'default'
				// "oblique" not supported
			},
			'text-decoration' : {
				'none' : 'default',
				'underline' : { text : '<u>U</u>' }
			},
			'font-variant' : {
				'small-caps' : {
					text : '<span style="font-variant: small-caps;">Small Caps</span>'
				},
				'normal' : 'default'
			},
			'vertical-align' : {
				'baseline' : 'default',
				'sup' : { text : '<sup>sup</sup>' },
				'sub' : { text : '<sub>sub</sub>' }
			},
			'quotes' : {
				'false' : 'default',
				'true' : { text : '&#8220;&#8221;' }
			},
			'strip-periods' : {
				'false' : 'default',
				'true' : { text : 'Strip Periods' }
			}
		},
		choicePanel,
		schemaChoices,
		schemaChoiceIndexes,
		schemaAttributes,
		executeCommand,
		fieldsets;

	var addCustomClasses = function (element, attributeName) {
		var classes = CSLEDIT_uiConfig.attributeClasses[attributeName];
		if (typeof(classes) !== "undefined") {
			element.addClass(classes);
		}
	};

	var inputAttributeRow = function (index, attributeName, schemaAttribute, enabled) {
		var row, textInput;

		row = $('<tr></tr>');
		row.append($('<td align="right"></td>').append(label(index, attributeName)));

		textInput = $('<input class="propertyInput"></input>');
		textInput.attr('id', inputId(index));
		addCustomClasses(textInput, attributeName);

		if (schemaAttribute.documentation !== "") {
			textInput.attr('title', schemaAttribute.documentation);
		}

		if (!enabled && !schemaAttribute.hasOwnProperty("defaultValue")) {
			textInput.attr('disabled', true);
		}

		row.append($('<td></td>').append(textInput));

		return row;
	};

	var label = function (index, attribute) {
		var element = $('<label class="propertyLabel"></label>');
		element.attr('for', inputId(index));
		element.attr('id', labelId(index));
		element.html(attribute);

		return element;
	};

	var indexOfAttribute = function (attributeName, attributes) {
		var index;
		for (index = 0; index < attributes.length; index++) {
			if (attributes[index].key === attributeName) {
				return index;
			}
		}
		// couldn't find
		return -1;
	};

	var indexesOfAttribute = function (attributeName, attributes) {
		var indexes = [],
			index;
		for (index = 0; index < attributes.length; index++) {
			if (attributes[index].key === attributeName) {
				indexes.push(index);
			}
		}
		return indexes;
	};

	var positionInSchema = function (attributeName) {
		var index = 0,
			position = -1;

		$.each(checkboxControlSchema, function (key, value) {
			if (key === attributeName) {
				position = index;
				return false;
			}
			index++;
		});

		return position;
	};

	var isValidValue = function (value, schemaAttribute) {
		var containsValueType = false,
			isValid = false;

		$.each(schemaAttribute.values, function (i, schemaValue) {
			if (schemaValue.type === "value") {
				containsValueType = true;
				return false;
			}
		});

		if (containsValueType) {
			if (schemaAttribute.list) {
				// Note: doesn't check validity of list contents at present
				isValid = true;
			} else {
				$.each(schemaAttribute.values, function (i, schemaValue) {
					if (value === schemaValue.value) {
						isValid = true;
						return false;
					}
				});
			}
		} else {
			isValid = true;
		}

		return isValid;
	};

	var checkboxChanged = function (event) {
		var target = $(event.target),
			attribute = target.attr('data-attribute'),
			value,
			index = indexOfAttribute(attribute, nodeData.attributes),
			siblingControls = $(event.target).siblings('[data-attribute="' + attribute + '"]');
		
		// disable any other buttons for this attribute
		siblingControls.removeAttr('checked').button('refresh');

		if (target.is(':checked')) {
			value = target.attr('data-value');
		} else {
			value = defaultValueForCustomControl(attribute);
		}

		nodeData.attributes[index] = {
			key : attribute,
			value : value,
			enabled : true
		};

		executeCommand("amendNode", [nodeData.cslId, stripChildren(nodeData)]);
	};

	var stripChildren = function (nodeData) {
		return {
			name : nodeData.name,
			cslId : nodeData.cslId,
			attributes : nodeData.attributes,
			textValue : nodeData.textValue
		};
	};
	
	var nodeChanged = function () {
		// read user data
		$('[id^="nodeAttributeLabel"]').each(function () {
			var key, value, index, enabled;
			index = $(this).attr("id").replace(/^nodeAttributeLabel/, "");
			key = $(this).html();

			if ($("#nodeAttribute" + index).length > 0) {
				value = $("#nodeAttribute" + index).val();
			} else {
			debug.assert(index in multiInputs);
				value = multiInputs[index].val();
			}

			// TODO: check choice attributes here too
			if (schemaAttributes.hasOwnProperty(key) &&
					schemaAttributes[key].alwaysOutput === true) {
				enabled = true;
			} else if (schemaAttributes.hasOwnProperty(key) &&
					schemaAttributes[key].hasOwnProperty("defaultValue")) {
				enabled = (value !== schemaAttributes[key].defaultValue);
			} else {
				enabled = nodeData.attributes[index].enabled;
			}

			nodeData.attributes[index] = {
				key : key,
				value : value,
				enabled : enabled
			};
		});
		nodeData.textValue = $('#textNodeInput').val();
		executeCommand("amendNode", [nodeData.cslId, stripChildren(nodeData)]);
	};

	var labelId = function (index) {
		return 'nodeAttributeLabel' + index;
	};

	var inputId = function (index) {
		return 'nodeAttribute' + index;
	};

	var defaultValueForCustomControl = function (attributeName) {
		var defaultValue;
		$.each(checkboxControlSchema[attributeName], function (value, control) {
			if (control === 'default') {
				defaultValue = value;
				return false;
			}
		});
		return defaultValue;
	};

	// TODO: Use buttons in the style of the +/- add/delete node ones
	var createButton = function (attributeName, cslSchemaAttribute, index, attribute) {
	debug.assert(typeof defaultValueForCustomControl(attributeName) !== "undefined");

		$.each(checkboxControlSchema[attributeName], function (attributeValue, control) {
			var button, buttonLabel, checkboxControlId;
			checkboxControlId = "checkboxControl" + checkboxControlIndex;

			if (control !== 'default') {
				buttonLabel = $('<label for="' + checkboxControlId + '">' + control.text + '</label>');
				button = $('<input type="checkbox" id="' + checkboxControlId + '" data-attribute="' +
					attributeName + '" data-value="' + attributeValue + '" />');

				if (cslSchemaAttribute.documentation !== "") {
					button.attr("title", cslSchemaAttribute.documentation);
				}

				checkboxControls.push({
					position : positionInSchema(attributeName),
					control : button,
					label : buttonLabel
				});

				if (attribute.value === attributeValue) {
					button.attr('checked', 'checked');
				}
				checkboxControlIndex++;
			}
		});
	};

	var createAttributeEditor = function (attributeName, schemaAttribute, index) {
		var attribute,
			schemaValues,
			dropdownValues,
			dropdownDocumentation,
			valueIndex,
			thisRow,
			multiInput,
			intValue,
			value;

		attribute = null;

		$.each(nodeData.attributes, function (i, thisAttribute) {
			var existingAttributeIndex;
			
			if (thisAttribute.key === attributeName &&
				isValidValue(thisAttribute.value, schemaAttribute)) {

				// do deep copy if one already exists
				existingAttributeIndex = indexOfAttribute(attributeName, newAttributes);
				if (existingAttributeIndex !== -1) {
					attribute = {
						key : thisAttribute.key,
						value : thisAttribute.value,
						enabled : thisAttribute.enabled
					};
				} else {
					attribute = thisAttribute;
				}
				
				if (!("enabled" in attribute)) {
					attribute["enabled"] = true;
				}
			}
		});
		if (attribute === null) {
			if (!schemaAttribute.hasOwnProperty("defaultValue")) {
				value = "";
			} else {
				value = schemaAttribute.defaultValue;
			}
			// create attribute if it doesn't exist
			attribute = { key : attributeName, value : value, enabled : false };
		}

		newAttributes.push(attribute);

		if (typeof checkboxControlSchema[attributeName] !== "undefined") {
			createButton(attributeName, schemaAttribute, index, attribute);
			return;
		}

		schemaValues = schemaAttribute.values;
		dropdownValues = [];
		dropdownDocumentation = {};

		// add macro dropdown values, they aren't in the schema
		if (attributeName === "macro") {
			$.each(CSLEDIT_data.getNodesFromPath("style/macro"), function (i, node) {
				var cslNode = new CSLEDIT_CslNode(node);
				if (cslNode.hasAttr("name")) {
					dropdownValues.push(cslNode.getAttr("name"));
				}
			});
		}

		if (schemaValues.length > 0) {
			for (valueIndex = 0; valueIndex < schemaValues.length; valueIndex++) {
				switch (schemaValues[valueIndex].type) {
				case "novalue":
					dropdownValues.push(schemaValues[valueIndex].value);
					dropdownDocumentation[schemaValues[valueIndex].value] =
						schemaValues[valueIndex].documentation;
					break;
				case "value":
					dropdownValues.push(schemaValues[valueIndex].value);
					if (schemaValues[valueIndex].documention !== "") {
						dropdownDocumentation[schemaValues[valueIndex].value] =
							schemaValues[valueIndex].documentation;
					}
					break;
				case "data":
					switch (schemaValues[valueIndex].value) {
					case "boolean":
						dropdownValues.push("true");
						dropdownValues.push("false");
						break;
					case "integer":
						for (intValue = 0; intValue < 20; intValue++) {							
							dropdownValues.push(intValue);
						}
						break;
					case "language":
						/*
						dropdownValues.push("English");
						dropdownValues.push("etc... ");
						dropdownValues.push("(TODO: find proper list");*/
						break;
					default:
						debug.log("WARNING: data type not recognised: " + 
							schemaValues[valueIndex].type);
					}
					break;
				default:
				debug.assert(false, "attribute value type not recognised");
				}
			}
		}

		if (dropdownValues.length === 1) {
			// if only 1 one value is possible, put it in a label
			thisRow = $('<tr/>');
			thisRow.append($('<td align="right"/>').append(label(index, attributeName)));
			thisRow.append($('<td/>').append(
				'<label id="nodeAttribute' + index + '">' + dropdownValues[0] + '</label>'));
		} else if (dropdownValues.length > 1) {
			thisRow = $('<tr></tr>');
			thisRow.append($('<td align="right"></td>').append(label(index, attributeName)));
			if (schemaAttribute.list) {
				multiInput = new CSLEDIT_MultiComboBox(
						$('<td class="input"></td>'), dropdownValues, function () {nodeChanged(); });
				multiInput.val(attribute.value, true);
				
				if (!attribute.enabled && !schemaAttribute.hasOwnProperty("defaultValue")) {
					multiInput.getElement().attr("disabled", true);
				}
				thisRow.append(multiInput.getElement());
				multiInputs[index] = multiInput;
			} else {
				thisRow.append((function () {
					var select, cell;
					select = $('<select id="' + inputId(index) + '" class="propertySelect" attr="' + 
						index + '"></select>');
					addCustomClasses(select, attributeName);
					
					$.each(dropdownValues, function (i, value) {
						var option = $("<option>" + value + "</option>");
						if (value in dropdownDocumentation) {
							option.attr("title", dropdownDocumentation[value]);
						}
						select.append(option);
					});

					cell = $('<td class="input"></td>').append(select);
					if (!attribute.enabled && !schemaAttribute.hasOwnProperty("defaultValue")) {
						cell.attr('disabled', true);
					}
					
					return cell;
				}()));
			}
		} else {
			thisRow = inputAttributeRow(index, attributeName, schemaAttribute, attribute.enabled);
		}

		var toggleButton;

		if (!schemaAttribute.hasOwnProperty("defaultValue")) {
			toggleButton = $('<button class="toggleAttrButton" attrIndex="' + index + '"></button>');
			if (attribute.enabled) {
				toggleButton.html('Disable');
			} else {
				toggleButton.html('Enable');
			}
			thisRow.append($('<td></td>').append(toggleButton));
		}
		thisRow.find("#" + inputId(index)).val(attribute.value);
			
		if (schemaAttribute.documentation !== "") {
			thisRow.attr('title', schemaAttribute.documentation);
		}

		return thisRow;
	};

	var setupChoiceTabs = function () {
		var possibleSelectedChoices = [], // choices with some attributes enabled
			definiteSelectedChoices = []; // choices with all attributes enabled

		if (typeof choicePanel === "undefined" || choicePanel === null) {
			return;
		}

		// select the enabled mode
		$.each(schemaChoices, function (choiceIndex, choice) {
			// check against the first attribute in each schemaChoice list to determine 
			// which mode we are in
			var definitelySelected = false,
				possiblySelected = false;
			
			$.each(choice.attributes, function (attributeName, attribute) {
				definitelySelected = true;
				return false;
			});

			$.each(choice.attributes, function (attributeName, schemaAttribute) {
				var attributeIndexes = indexesOfAttribute(attributeName, nodeData.attributes),
					thisAttribute;
				
				$.each(attributeIndexes, function (i, attributeIndex) {
					if (nodeData.attributes[attributeIndex].enabled &&
						isValidValue(nodeData.attributes[attributeIndex].value, schemaAttribute)) {
						thisAttribute = nodeData.attributes[attributeIndex];
						return false;
					}
				});

				if (typeof thisAttribute !== "undefined" && thisAttribute.enabled) {
					possiblySelected = true;
				} else {
					definitelySelected = false;
				}
			});

			if (definitelySelected) {
				definiteSelectedChoices.push(choiceIndex);
			}
			if (possiblySelected) {
				possibleSelectedChoices.push(choiceIndex);
			}
		});

		if (definiteSelectedChoices.length > 0) {
			if (definiteSelectedChoices.length > 1) {
				debug.log("WARNING: not clear which mode the node is in.\n" + 
					"more than 1 definite selected choice");
			}

			choicePanel.select(definiteSelectedChoices[0]);
			enableControlsInTab(definiteSelectedChoices[0]);
		} else if (possibleSelectedChoices.length > 0) {
			if (possibleSelectedChoices.length > 1) {
				debug.log('WARNING: not clear which mode this node is in');
			}
			choicePanel.select(possibleSelectedChoices[0]);
			enableControlsInTab(possibleSelectedChoices[0]);
		} else {
			// just select the first one
			choicePanel.select(0);
			enableControlsInTab(0);
		}
		
		choicePanel.onChange(function (index) {
			enableControlsInTab(index);
			nodeChanged();
		});
	};

	var enableControlsInTab = function (index) {
		// enable all controls in selected tab and disable the rest
		$.each(schemaChoiceIndexes, function (choiceIndex, choice) {
			$.each(choice, function (i, attributeIndex) {
				nodeData.attributes[attributeIndex].enabled = (choiceIndex === index);
				panel.find('#' + inputId(attributeIndex)).val(nodeData.attributes[attributeIndex].value);
			});
		});
	};

	var drawFieldsets = function (attributeEditors) {
		var groupTables = {},
			fieldsets = [],
			miscTable = $('<table/>'),
			miscFieldset = $('<fieldset class="float"><legend>' +
				CSLEDIT_uiConfig.displayNameFromNode(nodeData) +
				'</legend></fieldset>');

		$.each(CSLEDIT_uiConfig.attributeGroups, function (name, attributes) {
			var fieldset;

			groupTables[name] = $('<table/>');
			fieldset = $('<fieldset class="float"><legend>' + name + '</legend></fieldset>');

			if (attributes.indexOf("fontFormattingControls") !== -1) {
				fieldset.append(toolbar);
			}
			fieldset.append(groupTables[name]);

			fieldsets.push(fieldset);
		});

		miscTable = $('<table/>');
		
		$.each(attributeEditors, function (attributeName, editor) {
			var foundGroup = false;
			$.each(CSLEDIT_uiConfig.attributeGroups, function (groupName, attributes) {
				if (attributes.indexOf(attributeName) !== -1) {
					groupTables[groupName].append(editor);
					foundGroup = true;
				}
			});
			if (!foundGroup) {
				miscTable.append(editor);
			}
		});

		// only display fieldsets with non-empty tables
		$.each(fieldsets, function (i, fieldset) {
			if (fieldset.find('tr').length > 0) {
				panel.append(fieldset);
			}
		});

		if (miscTable.find('tr').length > 0) {
			miscFieldset.append(miscTable);
			panel.append(miscFieldset);
		}
	};

	var setupPanel = function (_panel, _nodeData, dataType, _schemaAttributes, _schemaChoices,
			_executeCommand) {
		var table,
			attrIndex,
			attributeEditors = {};
		
		schemaChoices = _schemaChoices;
		schemaAttributes = _schemaAttributes;
		executeCommand = _executeCommand;

		panel = _panel;
		nodeData = _nodeData;

		// remove child nodes
		panel.children().remove();

		toolbar = $('<div class="propertyToolbar"></div>');
		panel.append(toolbar);

		// TODO: data validation
		switch (dataType) {
		case null:
			// ignore - no data type
			break;
		case "anyURI":
			// text input with uri validation
			break;
		default:
			// no validation
		}

		checkboxControls = [];
		newAttributes = [];
		multiInputs = {};
		schemaChoiceIndexes = [];

		checkboxControlIndex = 0;

		choicePanel = null;

		// start with attribute editors in choice tabs
		attrIndex = -1;
		if (schemaChoices.length > 0) {

			choicePanel = new CSLEDIT_MultiPanel('multiPanel');
			choicePanel.element.addClass("float");
			panel.append(choicePanel.element);

			$.each(schemaChoices, function (choiceIndex, choice) {
				var addedToTab = false,
					table = $('<table/>');
				schemaChoiceIndexes[choiceIndex] = [];

				$.each(choice.attributes, function (attributeName, attribute) {
					var editor;
					if (!addedToTab) {
						// exception for date-part node
						if (nodeData.name === "date-part") {
							choicePanel.addPanel(attribute.values[attribute.values.length - 1].value);
						} else {
							choicePanel.addPanel(attributeName);
						}
						addedToTab = true;
					}
					
					attrIndex++;
					editor = createAttributeEditor(attributeName, attribute, attrIndex);
					schemaChoiceIndexes[choiceIndex].push(attrIndex);

					editor.find('button.toggleAttrButton').remove();
					editor.find('*').removeAttr('disabled');
					table.append(editor);
				});

				if (addedToTab) {
					choicePanel.contentPanels[choiceIndex].append(table);
				} else {
					choicePanel.addPanel("No attributes for this option");
				}
			});
		}

		table = $('<table></table>');
		// create value editor (if a text or data element)
		if (dataType !== null) {
			$('<tr><td align="right"><label for="textNodeInput" id="textNodeInputLabel" class="propertyLabel">' +
				dataType + ' value</label></td>' + 
				'<td class="input"><input id="textNodeInput" class="propertyInput"></input></td></tr>'
			).appendTo(panel);
		
			$("#textNodeInput").val(nodeData.textValue);
		}

		// other attribute editors
		$.each(schemaAttributes, function (attributeName, schemaAttribute) {
			attrIndex++;
			attributeEditors[attributeName] = createAttributeEditor(attributeName, schemaAttribute, attrIndex);
		});
		
		drawFieldsets(attributeEditors);

		nodeData.attributes = newAttributes;

		$(".propertyInput").on("input", function () {
			clearTimeout(onChangeTimeout);
			onChangeTimeout = setTimeout(function () { nodeChanged(); }, 500);
		});

		$(".propertySelect").on("change", function () { nodeChanged(); });

		$('.toggleAttrButton').click(function (buttonEvent) {
			var index = $(buttonEvent.target).attr("attrIndex");

			if (nodeData.attributes[index].enabled) {
				nodeData.attributes[index].enabled = false;
				$("#nodeAttribute" + index).attr("disabled", "disabled");
			} else {
				nodeData.attributes[index].enabled = true;
				$("#nodeAttribute" + index).removeAttr("disabled");
			}

			setupPanel(panel, nodeData, dataType, schemaAttributes, schemaChoices,
				executeCommand);
			clearTimeout(onChangeTimeout);
			onChangeTimeout = setTimeout(function () { nodeChanged(); }, 10);
		});

		checkboxControls.sort(function (a, b) {
			return a.position - b.position;
		});

		$.each(checkboxControls, function (i, control) {
			if (control.hasOwnProperty('control')) {
				toolbar.append(control.control);
				toolbar.append(control.label);
				
				control.control.button();

				if (typeof control.control.attr("title") !== "undefined") {
					control.control.button('widget').attr("title", control.control.attr("title"));
				}
			}
		});

		toolbar.find('input[id^=checkboxControl]').on('change', checkboxChanged);

		setupChoiceTabs();
	};
	
	return {
		setupPanel : setupPanel
	};
});



define('src/ConditionalPropertyPanel',['src/CslNode', 'src/debug'], function (CSLEDIT_CslNode, debug) {
	var CSLEDIT_ConditionalPropertyPanel = function (element, node, executeCommand) {
		var that = this;

		this.element = element;
		this.node = new CSLEDIT_CslNode(node);
		this.node.children = []; // not interested in the children
		this.executeCommand = executeCommand;

		this.conditions = []; // the 'model' for this view

		// any / none / all selector
		this.matchSelect = $('<select></select>');
		$.each(CSLEDIT_schema.attributes('choose/if').match.values, function (i, value) {
			that.matchSelect.append('<option>' + value.value + '</option>');
		});

		// generate mainOptions from the schema
		this.mainOptions = {};
		$.each(this.attributeUI, function (attribute, ui) {
			var mainOptionProperties = that.mainOptions[ui.mainOption] || [];
			
			mainOptionProperties.push({
				attribute: attribute,
				subOption: ui.subOption
			});
			that.mainOptions[ui.mainOption] = mainOptionProperties;
		});

		this.setup();
	};

	CSLEDIT_ConditionalPropertyPanel.prototype.attributeValue = function (attribute) {
		var that = this,
			values = [];

		$.each(that.conditions, function (i, condition) {
			if (condition.attribute === attribute) {
				values.push(condition.value);
			}
		});

		return values.join(" ");
	};

	CSLEDIT_ConditionalPropertyPanel.prototype.removeDuplicateOptions = function () {
		var that = this;

		$.each(that.node.attributes, function (attrIndex, attribute) {
			var selectedValues = that.attributeValue(attribute.key).split(" "),
				processedValues = [],
				availableValues;

			if (attribute.key !== "match") {
				// remove currently selcted values from availableValues
				availableValues = that.possibleValues(attribute.key);
				$.each(selectedValues, function (i, value) {
					var index = availableValues.indexOf(value);
					if (index !== -1) {
						availableValues.splice(index, 1);
					}
				});

				// remove duplicate values
				$.each(that.valueControls, function (i, valueControl) {
					if (that.conditions[i].attribute === attribute.key) {
						var $this = $(this),
							value = $this.val();

						// check if it's a duplicate
						if (processedValues.indexOf(value) !== -1) {
							if (availableValues.length === 0) {
								// no more available values, set processedValues and setup again
								that.node.setAttr(attribute.key, processedValues.join(" "));
								that.executeCommand('amendNode', [that.node.cslId, that.node]);
								that.setup();
								return;
							} else {
								// give it a new value
								value = availableValues.pop();
								$this.val(value);
								selectedValues.push(value);
							}
						}
						processedValues.push(value);
					}
				});

				debug.log("removing selected values from " + that.valueControls.length);
				// remove currently selected values from other controls options
				$.each(that.valueControls, function (i, valueControl) {
					if (that.conditions[i].attribute === attribute.key) {
						var $this = $(this);

						// remove all except current val
						$this.find('option[value!="' + $this.val() + '"]').remove();

						//debug.log("adding available options: " + availableOptions.length);

						// add back the other available options
						$.each(availableValues, function (i, option) {
							$this.append('<option>' + option + '</option>');
						});
					}
				});
			}
		});
	};

	CSLEDIT_ConditionalPropertyPanel.prototype.attributeUI = {
		"type" : {
			mainOption: "The document type is"
		},
		"disambiguate" : {
			mainOption: "Citations are disambiguated"
		},
		"variable" : {
			mainOption: "The variable",
			subOption: "is present"
		},
		"is-numeric" : {
			mainOption: "The variable",
			subOption: "is a number"
		},
		"is-uncertain-date" : {
			mainOption: "The date",
			subOption: "is uncertain"
		},
		"locator" : {
			mainOption: "The locator subtype",
			subOption: "is present"
		},
		"position" : {
			mainOption: "The position is"
		}	
	};

	CSLEDIT_ConditionalPropertyPanel.prototype.possibleValues = function (attribute) {
		// get possible values from schema
		var possibleValues = [];
		$.each(CSLEDIT_schema.choices("choose/if"), function (i, choice) {
			if (choice.attributes.hasOwnProperty(attribute)) {
				$.each(choice.attributes[attribute].values, function (i2, possibleValue) {
					if (possibleValue.type === "value") {
						possibleValues.push(possibleValue.value);
					}
				});
				return false;
			}
		});

		// for MLZ schema which doesn't put the values in choices
		if (possibleValues.length === 0 && attribute in CSLEDIT_schema.attributes("choose/if")) {
			$.each(CSLEDIT_schema.attributes("choose/if")[attribute].values, function (i, possibleValue) {
				if (possibleValue.type === "value") {
					possibleValues.push(possibleValue.value);
				}
			});
		};

		return possibleValues;
	};

	CSLEDIT_ConditionalPropertyPanel.prototype.availableValues = function (attribute) {
		var availableValues = this.possibleValues(attribute),
			selectedValues = this.attributeValue();

		// remove currently selcted values from availableValues
		$.each(this.attributeValue(attribute).split(" "), function (i, value) {
			var index = availableValues.indexOf(value);
			if (index !== -1) {
				availableValues.splice(index, 1);
			}
		});
		return availableValues;
	};

	CSLEDIT_ConditionalPropertyPanel.prototype.createConditionControls = function (i, condition) {
		var that = this,
			mainOption,
			mainOptionControl,
			valueControl,
			subOptionControl;

		// create mainOption
		mainOptionControl = $('<select class="mainOptionSelect"></select>');
		mainOptionControl.attr('data-index', i);
		$.each(that.mainOptions, function (mainOption, properties) {
			mainOptionControl.append('<option>' + mainOption + '</option>');
		});
		mainOption = that.attributeUI[condition.attribute].mainOption;
		mainOptionControl.val(mainOption);
		that.mainOptionControls[i] = mainOptionControl;

		// create subOptionControl
		if (that.mainOptions[mainOption].length > 1) {
			subOptionControl = $('<select class="subOptionSelect"></select>');
			subOptionControl.attr('data-index', i);
			$.each(that.mainOptions[mainOption], function (i, properties) {
				subOptionControl.append($('<option>' + properties.subOption + '</option>'));
				if (condition.attribute === properties.attribute) {
					subOptionControl.val(properties.subOption);
				}
			});
		} else {
			subOptionControl = $('<span></span>');
			$.each(that.mainOptions[mainOption], function (i, properties) {
				subOptionControl.append(properties.subOption);
			});
		}
		that.subOptionControls[i] = subOptionControl;
		
		// create value control
		if (that.possibleValues(condition.attribute).length > 1) {
			valueControl = $('<select class="valueSelect"></select>');
			valueControl.attr('data-index', i);
		
			$.each(that.possibleValues(condition.attribute), function (i, possibleValue) {
				valueControl.append('<option>' + possibleValue + '</option>');
			});
			valueControl.val(condition.value);
		} else {
			valueControl = $(); // empty
		}

		that.valueControls[i] = valueControl;
	};

	// for adding or amending
	CSLEDIT_ConditionalPropertyPanel.prototype.setCondition = function (index, newCondition) {
		var that = this,
			oldCondition = that.conditions[index],
			value;

		// set condition
		that.conditions[index] = newCondition;	

		// update view
		that.createConditionControls(index, newCondition);
		that.refresh();

		if (typeof(oldCondition) !== "undefined") {
			// update old attribute value
			value = that.attributeValue(oldCondition.attribute);
			if (value === "") {
				that.node.setAttrEnabled(oldCondition.attribute, false);
			} else {
				that.node.setAttr(oldCondition.attribute, value);
			}
		}

		// update new attribute value
		that.node.setAttr(newCondition.attribute, that.attributeValue(newCondition.attribute));
		that.executeCommand('amendNode', [that.node.cslId, that.node]);
	};

	CSLEDIT_ConditionalPropertyPanel.prototype.removeCondition = function (index) {
		var that = this,
			attribute = that.conditions[index].attribute,
			i;

		// update conditions
		that.conditions.splice(index, 1);

		// update view
		that.mainOptionControls.length = that.conditions.length;
		that.subOptionControls.length = that.conditions.length;
		that.valueControls.length = that.conditions.length;

		for (i = index; i < that.conditions.length; i++) {
			that.createConditionControls(i, that.conditions[i]);
		}

		that.refresh();

		// update value
		if (that.attributeValue(attribute) === "") {
			that.node.setAttrEnabled(attribute, false);
		} else {
			that.node.setAttr(attribute, that.attributeValue(attribute));
		}
		that.executeCommand('amendNode', [that.node.cslId, that.node]);
	};

	CSLEDIT_ConditionalPropertyPanel.prototype.setupEventHandlers = function () {
		var that = this;

		// event handlers
		this.element.find('select.mainOptionSelect').on('change', function () {
			var $this = $(this),
				index = $this.attr('data-index'),
				optionProperties = that.mainOptions[$this.val()][0],
				attribute = optionProperties.attribute,
				newCondition = {};

			newCondition.attribute = attribute;
			newCondition.value = that.availableValues(attribute)[0];
			if (typeof(newCondition.value) === "undefined") {
				alert("No more available values for this condition type");
				return;
			}
			that.setCondition(index, newCondition);
		});

		this.element.find('select.subOptionSelect').on('change', function () {
			var $this = $(this),
				index = $this.attr('data-index'),
				subOption = $this.val(),
				optionProperties = that.mainOptions[
					that.element.find('select.mainOptionSelect').eq(index).val()],
				attribute,
				newCondition = {},
				oldValue = that.conditions[index].value;

			$.each(optionProperties, function (i, properties) {
				if (properties.subOption === subOption) {
					attribute = properties.attribute;
					return false;
				}
			});

			debug.assert(typeof(attribute) !== "undefined");

			newCondition.attribute = attribute;

			if (that.availableValues(attribute).indexOf(oldValue) !== -1) {
				newCondition.value = oldValue;
			} else {
				newCondition.value = that.availableValues(attribute)[0];
			}

			if (typeof(newCondition.value) === "undefined") {
				alert("No more available values for this condition type");
				return;
			}
			that.setCondition(index, newCondition);
		});

		this.element.find('select.valueSelect').on('change', function () {
			var $this = $(this),
				index = $this.attr('data-index'),
				newCondition = {};

			newCondition.attribute = that.conditions[index].attribute;
			newCondition.value = $this.val();

			that.setCondition(index, newCondition);
		});

		this.element.find('button.addValue').on('click', function () {
			var newCondition = {};

			$.each(that.attributeUI, function (attribute) {
				var values = that.availableValues(attribute);

				if (values.length > 0) {
					newCondition.attribute = attribute;
					newCondition.value = values[0];
					return false;
				}
			});

			if (!newCondition.hasOwnProperty("attribute")) {
				alert("No more available conditions");
				return;
			}

			that.setCondition(that.conditions.length, newCondition);
		});

		this.element.find('button.deleteValue').on('click', function (event) {
			var index = that.element.find('button.deleteValue').index(event.target);

			that.removeCondition(index);
		});
		
		this.matchSelect.on('change', function () {
			// update data
			that.node.setAttr('match', that.matchSelect.val());
			that.executeCommand('amendNode', [that.node.cslId, that.node]);

			// update view
			that.refresh();
		});
	};

	CSLEDIT_ConditionalPropertyPanel.prototype.setup = function () {
		var that = this;

		this.conditions = [];

		$.each(this.node.attributes, function (i, attribute) {
			if (attribute.key !== "match" && attribute.enabled) {
				$.each(attribute.value.split(" "), function (i, value) {
					that.conditions.push({
						attribute : attribute.key,
						value : value
					});
				});
			}
		});
		
		// set matchSelect value
		this.matchSelect.val(this.node.getAttr('match') || 
				CSLEDIT_schema.attributes("choose/if").match.defaultValue);

		if (this.conditions.length === 0) {
			// should show at least one attribute value, so create one
			// NOTE: this is slightly strange behaviour for a view
			//       but should never happen - only after loading an
			//       invalid style

			this.node.setAttr("type", "article");
			this.node.setAttr("match", "any");
			that.executeCommand('amendNode', [this.node.cslId, this.node]);
			this.setup();
			return;
		}

		this.mainOptionControls = [];
		this.valueControls = [];
		this.subOptionControls = [];
		$.each(that.conditions, function (i, condition) {
			that.createConditionControls(i, condition);
		});

		this.refresh();
	};

	CSLEDIT_ConditionalPropertyPanel.prototype.refresh = function () {
		this.drawControls();
		this.removeDuplicateOptions();
		this.setupEventHandlers();
	};

	CSLEDIT_ConditionalPropertyPanel.prototype.drawControls = function () {
		var that = this,
			table = $('<table class="conditional"><col class="c1" /><col class="c2" />' + 
					'<col class="c3" /><col class="c4" /><col class="c5" /></table>'),
			valueSeparator,
			matchValue = this.node.getAttr('match') ||
				CSLEDIT_schema.attributes("choose/if").match.defaultValue;
		
		this.element.children().remove();

		this.element.append($('<p></p>').
				append(this.node.name + ' ').
				append(this.matchSelect).
				append(' of the following conditions are met'));

		if (matchValue === "all") {
			valueSeparator = '<span class="weak">and</span>';
		} else {
			valueSeparator = '<span class="weak">or</span>';
		}

		$.each(this.valueControls, function (i, valueControl) {
			var row = $('<tr></tr>');

			row.append($('<td class="mainOption"></td>').append(that.mainOptionControls[i]));
			row.append($('<td></td>').append(valueControl));

			row.append($('<td></td>').append(that.subOptionControls[i]));
			if (i === that.valueControls.length - 1) {
				row.append($('<td/>'));
			} else {
				row.append($('<td>' + valueSeparator + '</td>'));
			}

			row.append('<td class="delete"><button class="deleteValue">-</button></td>');
			if (that.valueControls.length === 1) {
				row.find('button.deleteValue').css({visibility:"hidden"});
			}

			if (i === that.valueControls.length - 1) {
				row.append('<td class="add"><button class="addValue">+</button></td>');
			} else {
				row.append('<td class="add"></td>');
			}

			table.append(row);
		});
		
		this.element.append(table);
	};
	return CSLEDIT_ConditionalPropertyPanel;
});



define('src/infoPropertyPanel',['src/CslNode', 'src/cslData', 'src/debug'], function (CSLEDIT_CslNode, CSLEDIT_data, debug) {
	var panel, infoNode, inputTimeout, executeCommand;

	var layout = [
		{ name : "Title", node : "title" },
		{ name : "Title (short)", node : "title-short" },
		{ name : "Id", node : "id" },
		{ name : "Summary", node : "summary" },
		{ name : "Rights", node : "rights" },
		{ name : "Published", node : "published" },
		{ name : "ISSNL", node : "issnl" },
		{ name : "eISSN", node : "eissn" },
		{ name : "ISSN", node : "issn" },
		// hiding "Updated" for now
		// if it goes back, it needs updating on each change
		// { name : "Updated", node : "updated" },
		{ name : "Link", node : "link" },
		{ name : "Author", node : "author" },
		{ name : "Contributor", node : "contributor" },
		{ name : "Category", node : "category" }
	];

	var pluralise = function (noun) {
		if (noun[noun.length - 1] === "y") {
			return noun.replace(/y$/, "ies");
		} else {
			return noun + "s";
		}
	};

	// TODO: could probably get some of this info from the schema
	var multipleNodes = ["link","author","contributor","category","issn"];
	var attributeNodes = ["link", "category"];
	var nameNodes = ["author", "contributor"];

	var attributeEditorRow = function (item, node, schemaAttributes) {
		var thisRow = $('<div></div>');
		$.each(schemaAttributes, function (name) {
			var input, attributeValue;
			thisRow.append(' <label>' + name + '</label> ');

			attributeValue = new CSLEDIT_CslNode(node).getAttr(name);

			input = createInput(item.node, node, name, attributeValue);
			thisRow.append(input);
		});
		return thisRow;
	};

	var createInput = function (nodeName, node, type, value, parentCslId) {
		var input = $('<input></input>');
		if (typeof node === "undefined" || node === null) {
			if (typeof parentCslId === "undefined") {
				input.attr("parentcslid", infoNode.cslId);
			} else {
				input.attr("parentcslid", parentCslId);
			}
		} else {
			input.attr("cslid", node.cslId);
		}
		input.attr("type", type);
		input.attr("nodename", nodeName);
		input.val(value);
		input.on('input', onInput);

		return input;
	};

	var onInput = function () {
		var $this = $(this);

		clearTimeout(inputTimeout);
		inputTimeout = setTimeout(function () {
			var cslId,
				parentId,
				type,
				nodeName,
				thisNode,
				index,
				parentNode,
				numChildNodes;

			cslId = parseInt($this.attr("cslid"));
			parentId = parseInt($this.attr("parentcslid"));
			type = $this.attr("type");
			nodeName = $this.attr("nodename");

			thisNode = new CSLEDIT_CslNode(nodeName);
			if (!isNaN(cslId)) {
				thisNode.copy(CSLEDIT_data.getNode(cslId));
			}

			if (type === "textValue") {
				thisNode.textValue = $this.val();
			} else {
				thisNode.setAttr(type, $this.val()); 
			}

			if (isNaN(cslId)) {
				CSLEDIT_viewController.setSuppressSelectNode(true);
				executeCommand('addNode', [parentId, "last", thisNode]);
				CSLEDIT_viewController.setSuppressSelectNode(false);
				parentNode = CSLEDIT_data.getNode(parentId);
				numChildNodes = CSLEDIT_data.numNodes(parentNode) - 1;

				// update all cslids
				$.each(["cslid", "parentcslid"], function (i, attribute) {
					panel.find('input[' + attribute + ']').each(function() {
						var $this = $(this),
							cslId;
					
						cslId = parseInt($this.attr(attribute));

						if (cslId >= parentId + numChildNodes) {
							$this.attr(attribute, cslId + 1);
						}
					});
				});

				// set added node cslid
				$this.removeAttr("parentcslid");
				$this.attr("cslid", parentId + numChildNodes);
			} else {
				executeCommand('amendNode', [cslId, thisNode]);
			}
		}, 500);
	};

	var textValueEditorRow = function (item, node) {
		var thisRow, value = "";

		thisRow = $('<div></div>');
		thisRow.append(' <label>' + item.name + '</label> ');

		if (typeof node !== "undefined") {
			value = node.textValue;
		}
		thisRow.append(createInput(item.node, node, "textValue", value));
		return thisRow;
	};

	var nameEditorRow = function (item, cslNode) {
		var thisRow, children, input, cslChildren;
	   
		thisRow = $('<div></div>');
		children = CSLEDIT_schema.childElements("info/author");

		cslChildren = {};
		$.each(cslNode.children, function (i, actualChild) {
			cslChildren[actualChild.name] = actualChild;
		});

		$.each(children, function (child, unused) {
			var value = "";

			thisRow.append(' <label>' + child + '</label> ');
			//input = $('<input class="' + item.node + '-' + child + '"></input>');

			if (child in cslChildren) {
				value = cslChildren[child].textValue;
			}
			input = createInput(child, cslChildren[child], "textValue", value, cslNode.cslId);
			thisRow.append(input);
		});
		return thisRow;
	};

	var editorRow = function (item, node, schemaAttributes) {
		var row;
		if (attributeNodes.indexOf(item.node) >= 0) {
			return attributeEditorRow(item, node, schemaAttributes);
		} else if (nameNodes.indexOf(item.node) >=0) {
			return nameEditorRow(item, node);
		} else {
			row = textValueEditorRow(item, node);
			row.find("input").css({width:"400px"});
			return row;
		}
	};

	// It's assumed that infoNode will always refer to the correct node
	// while the panel is visible
	var setupPanel = function (_panel, _executeCommand) {
		panel = _panel;
		executeCommand = _executeCommand;
		infoNode = CSLEDIT_data.getNodesFromPath("style/info");
	debug.assertEqual(infoNode.length, 1); // fail in error.log
		infoNode = infoNode[0];

		panel.children().remove();

		$.each(layout, function (i, item) {
			var nodes = CSLEDIT_data.getNodesFromPath("info/" + item.node, infoNode),
				schemaAttributes, deleteButton, addButton, value, thisRow,
				table,
				titleRow, inputRow;
			
			if (multipleNodes.indexOf(item.node) >= 0) {
				schemaAttributes = {};
				$.each(CSLEDIT_schema.attributes("info/" + item.node), function (attrName, attr) {
					schemaAttributes[attrName] = attr;
				});
				
				// add choices to attributes
				// TODO: correct this to treat choices as mutaully exclusive
				//       as they should be
				$.each(CSLEDIT_schema.choices("info/" + item.node), function (i, choice) {
					$.each(choice.attributes, function (attrName, attr) {
						schemaAttributes[attrName] = attr;
					});
				});

				panel.append('<h4>' + pluralise(item.name) + '</h4>');
				table = $("<table></table>");
				$.each(nodes, function (i, node) {
					thisRow = editorRow(item, node, schemaAttributes);

					// convert 1st thisRow into table title
					if (typeof titleRow === "undefined") {
						titleRow = $('<tr></tr>');
						thisRow.find('label').each(function () {
							titleRow.append($('<td></td>').append($(this)));
						});
						table.append(titleRow);
					}
					
					// convert thisRow into table row
					inputRow = $('<tr></tr>');
					thisRow.find('input').each(function () {
						inputRow.append($('<td></td>').append($(this)));
					});

					deleteButton = $('<button>Delete</button>');
					deleteButton.on('click', function () {
						executeCommand("deleteNode", [node.cslId]);
						setupPanel(panel, executeCommand);
					});

					inputRow.append($('<td></td>').append(deleteButton));
					table.append(inputRow);
				});

				panel.append(table);
				
				addButton = $('<button>Add ' + item.name + '</button>');
				panel.append(addButton);

				addButton.on('click', function () {
					CSLEDIT_viewController.setSuppressSelectNode(true);
					executeCommand("addNode",
						[infoNode.cslId, "last", new CSLEDIT_CslNode(item.node)]);
					CSLEDIT_viewController.setSuppressSelectNode(false);
					setupPanel(panel, executeCommand);
				});
				panel.append('<br /><br />');
			} else {
			debug.assert(nodes.length < 2);
				thisRow = editorRow(item, nodes[0], null);

				// TODO: do this in less hacky way
				panel.css("position", "relative");
				thisRow.children('input').eq(0).css("position", "absolute");
				thisRow.children('input').eq(0).css("left", "100px");
				thisRow.children('label').eq(0).css("line-height", "1.5");
				panel.append(thisRow);
			}
		});

	};

	return {
		setupPanel : setupPanel
	};
});



define('src/sortPropertyPanel',['src/CslNode', 'src/cslData', 'src/debug'], function (CSLEDIT_CslNode, CSLEDIT_data, debug) {
	var onChangeTimeout, setupPanel, list, nodeData, panel, executeCommand,
		namesAttributeNames = [
			"names-min",
			"names-use-first",
			"names-use-last"
		];
	
	// TODO: put into a common place - copied from src/smartTree.js
	var getAttr = function (attribute, attributes) {
		var index;

		for (index = 0; index < attributes.length; index++) {
			if (attributes[index].enabled && attributes[index].key === attribute) {
				return attributes[index].value;
			}
		}
		return "";
	};

	var sortableListUpdated = function () {
		// iterate through nodeData and the UI element noting the changes
		
		var index = 0,
			dragDirection = "unknown", // the direction the user dragged
			fromId,
			toPosition;

		list.children().each(function () {
			var variable, macro, childNode, visibleKey;

			if (index >= nodeData.children.length) {
			debug.assertEqual(dragDirection, "down");
				toPosition = nodeData.children.length - 1;
				return false;
			}

			visibleKey = $(this).find('select.sortKey').val();
			childNode = nodeData.children[index];
		debug.assertEqual(childNode.name, "key");

			if (visibleFieldName(
					getAttr("macro", childNode.attributes),
					getAttr("variable", childNode.attributes)) !==
				visibleKey) {

				if (dragDirection === "up") {
					fromId = childNode.cslId;
					return false;
				} else if (dragDirection === "down") {
					toPosition = index - 1;
					return false;
				} else if (visibleFieldName(
					getAttr("macro", nodeData.children[index + 1].attributes),
					getAttr("variable", nodeData.children[index + 1].attributes)) ===
					visibleKey)
				{
					// The next data element matches, so this is an deletion,
					// and the user dragged down.
					dragDirection = "down";
					fromId = childNode.cslId;
					index++;
				} else {
					// The next data element doesn't match, so this is an addition,
					// and the user dragged up.
					dragDirection = "up";
					toPosition = index;
					index--;
				}
			}
		
			index++;
		});

		if (dragDirection === "up" && typeof fromId === "undefined") {
			fromId = nodeData.children[index].cslId;
		}

		CSLEDIT_viewController.setSuppressSelectNode(true);
		executeCommand("moveNode", [fromId, nodeData.cslId, toPosition]);
		CSLEDIT_viewController.setSuppressSelectNode(false);
		nodeData = CSLEDIT_data.getNode(nodeData.cslId);
	};

	var visibleFieldName = function (macro, variable) {
		if (macro !== "" && typeof macro !== "undefined") {
			return "Macro: " + macro;
		} else {
			return variable;
		}
	};

	var attributesFromVisibleFieldName = function (visibleName) {
		var attributes = [];

		if (visibleName.indexOf("Macro: ") === 0) {
			attributes.push({
				key : "macro",
				value : visibleName.slice("Macro: ".length),
				enabled : true
			});
		} else {
			attributes.push({
				key : "variable",
				value : visibleName,
				enabled : true
			});
		}

		return attributes;
	};

	var getNamesAttributes = function () {
		var attributes = [];

		$.each(namesAttributeNames, function (i, name) {
			var val = panel.find("select." + name).val();

			if (val !== "0") {
				attributes.push({
					key : name,
					value : val,
					enabled : true
				});
			}
		});

		return attributes;
	};

	var getKeyNodeData = function (index) {
		var keyNode = new CSLEDIT_CslNode("key");

		keyNode.attributes = attributesFromVisibleFieldName(
			list.find('select.sortKey').eq(index).val());

		keyNode.attributes = keyNode.attributes.concat(getNamesAttributes());
		return keyNode;
	};

	var onInput = function () {
		var listElements = list.find('li'),
			childIndex,
			keyNode;
	
		childIndex = listElements.index($(this).parent());
		keyNode = nodeData.children[childIndex];
	debug.assertEqual(keyNode.name, "key");

		executeCommand("amendNode", [keyNode.cslId, 
			getKeyNodeData(childIndex)]);
	};

	var onDelete = function () {
		var listElements = list.find('li'),
			childIndex,
			cslId;
		
		childIndex = listElements.index($(this).parent());

		cslId = CSLEDIT_data.getNode(nodeData.cslId).children[childIndex].cslId;
		listElements.eq(childIndex).remove();
		executeCommand('deleteNode', [cslId]);
	};

	setupPanel = function (_panel, _nodeData, _executeCommand) {
		var table, macros, variables, index, addKeyButton, sortKeyHtml;

		panel = _panel;
		nodeData = _nodeData;
		executeCommand = _executeCommand;

		// clear panel 
		panel.children().remove();

		// sortable list
		list = $('<ul class="sortKeys"></ul>');
		list.appendTo(panel);
		list.sortable({
			update : sortableListUpdated
		});

		variables = [];
		$.each(CSLEDIT_schema.choices("sort/key")[0].attributes.variable.values, function (i, variable) {
			variables.push(variable.value);
		});

		macros = [];
		$.each(CSLEDIT_data.getNodesFromPath("style/macro"), function (i, node) {
		debug.assertEqual(node.attributes[0].key, "name");
			macros.push(node.attributes[0].value);
		});

		sortKeyHtml = '<li class="ui-state-default">';
		sortKeyHtml += '<span class="ui-icon ui-icon-arrowthick-2-n-s"></span> ';
		sortKeyHtml += '<select class="sortKey">';
		$.each(macros, function (i, macro) {
			sortKeyHtml += '<option macro="' + macro + '">Macro: ' + macro + '</option>';
		});
		$.each(variables, function (i, variable) {
			sortKeyHtml += '<option variable="' + variable + '">' + variable + '</option>';
		});
		sortKeyHtml += '</select>';
		sortKeyHtml += ' <button class="deleteSortKey">Delete</button>';
		sortKeyHtml += '</li>';

		$.each(nodeData.children, function (i, child) {
			var row = $(sortKeyHtml),
				select,
				macro,
				variable;
			
			select = row.find("select.sortKey");
		debug.assertEqual(select.length, 1);

			select.val(visibleFieldName(
				getAttr("macro", child.attributes),
				getAttr("variable", child.attributes)));

			list.append(row);
		});

		list.find('button.deleteSortKey').on('click', onDelete);

		list.find('select').on('change', onInput /*function () {
			var listElements = list.find('li'),
				childIndex,
				keyNode;
		
			childIndex = listElements.index($(this).parent());
			keyNode = nodeData.children[childIndex];
		debug.assertEqual(keyNode.name, "key");

			executeCommand("amendNode", [keyNode.cslId, 
				getKeyNodeData(childIndex)]);
		}*/);

		addKeyButton = $('<button>Add key</button>');
		addKeyButton.on('click', function () {
			var selectNodes;

			CSLEDIT_viewController.setSuppressSelectNode(true);
			executeCommand('addNode', [nodeData.cslId, "last",
				new CSLEDIT_CslNode('key', [
					{
						key : "variable",
						value : "author",
						enabled : true
					}
				])]);
			CSLEDIT_viewController.setSuppressSelectNode(false);

			nodeData = CSLEDIT_data.getNode(nodeData.cslId);

			list.append(sortKeyHtml);
			selectNodes = list.find('select');
			selectNodes.on('change', onInput);
			selectNodes.last().val("author");

			list.find('button.deleteSortKey').last().on('click', onDelete);
		});
		panel.append(addKeyButton);
		panel.append('<br /><br />');

		(function () {
			var select;

			// TODO: only enable if sort keys contain a names element
			select = $('<select class="names-min"></select>');
			for (index = 0; index < 20; index++) {
				$('<option>' + index + '</option>').appendTo(select);
			}
			$('<label>Names-min: </label>').appendTo(panel);
			select.appendTo(panel);
			panel.append(' ');

			select = $('<select class="names-use-first"></select>');
			for (index = 0; index < 20; index++) {
				$('<option>' + index + '</option>').appendTo(select);
			}
			$('<label>Names-use-first: </label>').appendTo(panel);
			select.appendTo(panel);
			panel.append(' ');
			
			select = $('<select class="names-use-last"></select>');
			for (index = 0; index < 20; index++) {
				$('<option>' + index + '</option>').appendTo(select);
			}
			$('<label>Names-use-last: </label>').appendTo(panel);
			select.appendTo(panel);

			panel.find('select[class^="names"]').on('change', function () {
				// update all keys with names attrs
				// TODO: only add names attrs to keys containing names
				var namesAttributes = getNamesAttributes(),
					index;

				for (index = 0; index < nodeData.children.length; index++) {

				}

				$.each(nodeData.children, function (index, keyNode) {
				debug.assertEqual(keyNode.name, "key");
					executeCommand("amendNode", [keyNode.cslId, getKeyNodeData(index)]);
				});
			});
		}());
	};

	return {
		setupPanel : setupPanel
	};
});



define('src/propertyPanel',
		[	'src/genericPropertyPanel',
			'src/ConditionalPropertyPanel',
			'src/infoPropertyPanel',
			'src/sortPropertyPanel',
			'src/controller'
		],
		function (
			CSLEDIT_genericPropertyPanel,
			CSLEDIT_ConditionalPropertyPanel,
			CSLEDIT_infoPropertyPanel,
			CSLEDIT_sortPropertyPanel,
			CSLEDIT_controller
		) {
	var suppressUpdates = false; // used to prevent panel updates triggered the panel itself

	// property panels should use this instead of calling CSLEDIT_controller.exec
	// directly to prevent updates to the panel
	var executeCommand = function (command, args) {
		suppressUpdates = true;
		CSLEDIT_controller.exec(command, args);
		suppressUpdates = false;
	};

	var setup = function (propertyPanelElement, node, elementString) {
		var dataType,
			schemaAttributes;

		if (suppressUpdates) {
			return;
		}

		// show appropriate property panel
		switch (node.name) {
		case "sort":
			propertyPanelElement.children().remove();
			propertyPanelElement.append(
				"<p>This node allows you to sort your references depending on their " +
				"metadata.</p>" +
				'<p>Create new sort keys using the "+" add node button at the top left.</p>'
				);

		/* TODO: Re-enable sort property panel if:
		 *         1. bug is fixed where re-ordering the sort keys causes crash
		 *         2. ascending/descending option is added for each sort key
		 *
			CSLEDIT_sortPropertyPanel.setupPanel(propertyPanelElement, node, executeCommand);
		*/
			break;
		case "info":
			CSLEDIT_infoPropertyPanel.setupPanel(propertyPanelElement, executeCommand);
			break;
		case "if":
		case "else-if":
			new CSLEDIT_ConditionalPropertyPanel(propertyPanelElement, node, executeCommand);
			break;
		case "choose":
			propertyPanelElement.children().remove();
			propertyPanelElement.append(
				"<p>This node allows you to customise the formatting " +
				"depending on the properties of the reference being cited.</p>" +
				"<p>e.g. To show the volume number <em>only</em> " +
				"if the document type is article-journal:</p>" +
				'<ol>' +
				'<li>1. Use the "+" add node button at the top left to add an "if" node</li>' +
				'<li>2. Edit the "if" node to say "The document type is article-journal"</li>' +
				'<li>3. Within the "if" node, add a "number" node and set it\'s ' +
				'variable to "volume"</li>' +
				'</ol>'
				);
			break;
		default:
			dataType = CSLEDIT_schema.elementDataType(elementString);
			schemaAttributes = CSLEDIT_schema.attributes(elementString);

			CSLEDIT_genericPropertyPanel.setupPanel(
				propertyPanelElement, node, dataType, schemaAttributes,
				CSLEDIT_schema.choices(elementString), executeCommand);
		}
	};

	return {
		setup : setup
	};
});



define('src/NodePathView',['src/cslData'], function (CSLEDIT_data) {
	var CSLEDIT_NodePathView = function (element, callbacks, syntaxHighlighter) {
		this.element = 	element;
		this.callbacks = callbacks;
		this.syntaxHighlighter = syntaxHighlighter;
	};

	CSLEDIT_NodePathView.prototype.selectNode = function (nodePath) {
		var that = this,
			nodesHtml = [],
			cslData = CSLEDIT_data.get();

		$.each(nodePath, function (i, cslId) {
			var node = CSLEDIT_data.getNode(cslId, cslData);
			nodesHtml.push('<span cslid="' + node.cslId + '">' + node.name + '</span>');
		});

		this.element.html(nodesHtml.join(" > "));

		this.element.find('span[cslid]').css({"cursor" : "pointer"});
		this.element.find('span[cslid]').off('click');
		this.element.find('span[cslid]').on('click', function(event) {
			var thisNodePath = [],
				thisCslId = parseInt($(event.target).attr("cslid"));

			$.each(nodePath, function (i, cslId) {
				thisNodePath.push(cslId);
				if (cslId === thisCslId) {
					return false;
				}
			});
			
			that.callbacks.selectNodeFromPath(thisNodePath);
		});
		this.element.find('span[cslid]').hover(this.syntaxHighlighter.hover, this.syntaxHighlighter.unhover);

		//$.each(nodePath, function (i, cslId) {
		//	that.callbacks.setupSyntaxHighlightForNode(cslId);
		//});
	};
	return CSLEDIT_NodePathView;
});



define('src/notificationBar',[],function () {
	var element, messageElement;

	return {
		init : function (_element) {
			element = _element;
			messageElement = element.find('span.message');
			
			element.find('button.dismiss').on('click', function () {
				element.slideUp();
			});
		},
		showMessage : function (message) {
			var percentage;

			element.css({'display' : 'none'});
			messageElement.html(message);

			percentage = Math.round(50 * 
				(element.parent().width() - element.width()) / element.parent().width());

			element.css({
				'left' : percentage + '%'});
			element.slideDown();
		}
	}
});

/**
 * jQuery.ScrollTo - Easy element scrolling using jQuery.
 * Copyright (c) 2007-2009 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
 * Dual licensed under MIT and GPL.
 * Date: 5/25/2009
 * @author Ariel Flesler
 * @version 1.4.2
 *
 * http://flesler.blogspot.com/2007/10/jqueryscrollto.html
 */
;(function(d){var k=d.scrollTo=function(a,i,e){d(window).scrollTo(a,i,e)};k.defaults={axis:'xy',duration:parseFloat(d.fn.jquery)>=1.3?0:1};k.window=function(a){return d(window)._scrollable()};d.fn._scrollable=function(){return this.map(function(){var a=this,i=!a.nodeName||d.inArray(a.nodeName.toLowerCase(),['iframe','#document','html','body'])!=-1;if(!i)return a;var e=(a.contentWindow||a).document||a.ownerDocument||a;return d.browser.safari||e.compatMode=='BackCompat'?e.body:e.documentElement})};d.fn.scrollTo=function(n,j,b){if(typeof j=='object'){b=j;j=0}if(typeof b=='function')b={onAfter:b};if(n=='max')n=9e9;b=d.extend({},k.defaults,b);j=j||b.speed||b.duration;b.queue=b.queue&&b.axis.length>1;if(b.queue)j/=2;b.offset=p(b.offset);b.over=p(b.over);return this._scrollable().each(function(){var q=this,r=d(q),f=n,s,g={},u=r.is('html,body');switch(typeof f){case'number':case'string':if(/^([+-]=)?\d+(\.\d+)?(px|%)?$/.test(f)){f=p(f);break}f=d(f,this);case'object':if(f.is||f.style)s=(f=d(f)).offset()}d.each(b.axis.split(''),function(a,i){var e=i=='x'?'Left':'Top',h=e.toLowerCase(),c='scroll'+e,l=q[c],m=k.max(q,i);if(s){g[c]=s[h]+(u?0:l-r.offset()[h]);if(b.margin){g[c]-=parseInt(f.css('margin'+e))||0;g[c]-=parseInt(f.css('border'+e+'Width'))||0}g[c]+=b.offset[h]||0;if(b.over[h])g[c]+=f[i=='x'?'width':'height']()*b.over[h]}else{var o=f[h];g[c]=o.slice&&o.slice(-1)=='%'?parseFloat(o)/100*m:o}if(/^\d+$/.test(g[c]))g[c]=g[c]<=0?0:Math.min(g[c],m);if(!a&&b.queue){if(l!=g[c])t(b.onAfterFirst);delete g[c]}});t(b.onAfter);function t(a){r.animate(g,j,b.easing,a&&function(){a.call(this,n,b)})}}).end()};k.max=function(a,i){var e=i=='x'?'Width':'Height',h='scroll'+e;if(!d(a).is('html,body'))return a[h]-d(a)[e.toLowerCase()]();var c='client'+e,l=a.ownerDocument.documentElement,m=a.ownerDocument.body;return Math.max(l[h],m[h])-Math.min(l[c],m[c])};function p(a){return typeof a=='object'?a:{top:a,left:a}}})(jQuery);
define("jquery.scrollTo", ["jquery"], function(){});



define('src/ViewController',
		[	'src/Titlebar',
			'src/SmartTree',
			'src/SmartTreeHeading',
			'src/propertyPanel',
			'src/NodePathView',
			'src/notificationBar',
			'src/CslNode',
			'src/Iterator',
			'src/cslData',
			'src/debug',
			'jquery.scrollTo'
		],
		function (
			CSLEDIT_Titlebar,
			CSLEDIT_SmartTree,
			CSLEDIT_SmartTreeHeading,
			CSLEDIT_propertyPanel,
			CSLEDIT_NodePathView,
			CSLEDIT_notificationBar,
			CSLEDIT_CslNode,
			CSLEDIT_Iterator,
			CSLEDIT_data,
			debug,
			jquery_scrollTo
		) {
	return function CSLEDIT_ViewController ( 
		treeView, titlebarElement, propertyPanelElement, nodePathElement,
		syntaxHighlighter) {
	
		// smartTrees display a subset of the proper CSL tree
		// and allow transformations of the data
		//
		// name : visible name
		// nodeData : displayed in property panel
		// children : displayed in tree view as children
		var smartTreeSchema = [
				{
					id : "info",
					name : "Style Info",
					headingNodePath : "",
					nodePaths : ["style/info", "style"/*, "style/locale"*/],
					macroLinks : false,
					leafNodes : ["info", "style"]
				},
				{
					id : "citations",
					name : "Inline Citations",
					headingNodePath : "style/citation",
					headingNodePossibleChildren : {
						"layout" : "one",
						"sort" : "one"
					},
					nodePaths : ["style/citation/layout", "style/citation/sort"],
					//leafNodes : ["sort"],
					macroLinks : true
				},
				{
					id : "bibliography",
					name : "Bibliography",
					headingNodePath : "style/bibliography",
					headingNodePossibleChildren : {
						"layout" : "one",
						"sort" : "one"
					},
					nodePaths : ["style/bibliography/layout", "style/bibliography/sort"],
					//leafNodes : ["sort"],
					macroLinks : true
				},
				{
					id : "macro",
					name : "Macros",
					headingNodePath : "style",
					headingNodePossibleChildren : {
						"macro" : "zeroOrMore"
					},
					headingNodeShowPropertyPanel : false,
					nodePaths : ["style/macro"],
					macroLinks : true,
				},
				{
					id : "locale",
					name : "Advanced",
					headingNodePath : "",
					macroLinks : false,
					nodePaths : ["style"]
				}
			],
			views = [],
			treesLoaded,
			treesToLoad,
			callbacks,
			selectedTree = null,
			selectedNodeId = -1,
			recentlyEditedMacro = -1,
			nodePathView,
			suppressSelectNode = false;

		var treeLoaded = function () {
			treesLoaded++;

			if (treesLoaded === treesToLoad) {
				if (selectedNode() === -1) {
					selectNode(CSLEDIT_data.getNodesFromPath('style/info')[0].cslId);
				}
				callbacks.formatCitations();
				callbacks.viewInitialised();
			}
		};

		var newStyle = function () {
			init(CSLEDIT_data.get(), callbacks);
		};

		var init = function (cslData, _callbacks) {
			var eventName,
				jsTreeData,
				citationNodeId,
				citationNodeData,
				citationTree,
				cslId,
				nodes,
				row;

			treesLoaded = 0;
			treesToLoad = 0;

			selectedNodeId = -1;
			views = [];

			views.push(new CSLEDIT_Titlebar(titlebarElement));

			callbacks = _callbacks;

			treeView.html('');
			$.each(smartTreeSchema, function (index, value) {
				row = $('');
				row = $('<div id="%1"><div class="heading"/><div class="tree"/></div>'.replace(
					'%1', value.id));
				row.appendTo(treeView);
				treeView.append($('<div class=spacer></div>'));
			});

			$.each(smartTreeSchema, function (index, value) {
				var tree, heading;
				treesToLoad++;
				
				heading = new CSLEDIT_SmartTreeHeading(
					treeView.find('#' + value.id + ' .heading'), value.headingNodePath,
					value.name, value.headingNodePossibleChildren, value.headingNodeShowPropertyPanel);
				heading.setCallbacks({
					selectNode : selectNodeInView(heading)
				});
				views.push(heading);

				tree = CSLEDIT_SmartTree(treeView.find('#' + value.id + ' .tree'), value.nodePaths, 
					value.macroLinks, value.leafNodes);

				// Use this for debugging if you're not sure the view accurately reflects the data
				//tree.setVerifyAllChanges(true);
				tree.setCallbacks({
					loaded : treeLoaded,
					selectNode : selectNodeInView(tree),
					moveNode : callbacks.moveNode,
					deleteNode : callbacks.deleteNode,
					checkMove : callbacks.checkMove
				});
				tree.createTree();
				views.push(tree);
			});

			nodePathView = new CSLEDIT_NodePathView(nodePathElement, {
				selectNodeFromPath : selectNodeFromPath
			}, syntaxHighlighter);
		};
		
		var selectedNodeChanged = function () {
			var nodeAndParent,
				node,
				parentNode,
				parentNodeName,
				possibleElements,
				element,
				possibleChildNodesDropdown,
				schemaAttributes,
				dataType,
				translatedCslId,
				translatedNodeInfo,
				translatedParentName;

			if (selectedNode() === -1) {
				// clear property panel if nothing selected
				propertyPanelElement.children().remove();
				return;
			}

			nodeAndParent = CSLEDIT_data.getNodeAndParent(selectedNode());
			node = nodeAndParent.node;
			parentNode = nodeAndParent.parent;

			// hack to stop parent of style being style
			if (node.name === "style") {
				parentNodeName = "root";
			} else if (parentNode !== false) {
				parentNodeName = parentNode.name;
			} else {
				parentNodeName = "root";
			}

			nodePathView.selectNode(getSelectedNodePath());

			if (selectedViewProperty("showPropertyPanel") === false) {
				propertyPanelElement.children().remove();
			} else {
				CSLEDIT_propertyPanel.setup(propertyPanelElement, node, parentNodeName + '/' + node.name);
			}

			syntaxHighlighter.selectedNodeChanged(node.cslId);		
		};

		var selectNodeInView = function (selectedView) {
			return function (event, ui) {
				// deselect nodes in other views
				$.each(views, function (i, view) {
					if (view !== selectedView) {
						if ("deselectAll" in view) {
							view.deselectAll();
						}
					}
				});

				selectedTree = selectedView;
				selectedNodeId = selectedView.selectedNode();
		
				selectedNodeChanged();
			};
		};

		var getSelectedNodePath = function () {
			if (selectedTree === null) {
				return "no selected tree";
			}

			return selectedTree.getSelectedNodePath();
		};

		var macroEditNotification = function (id) {
			var nodeStack = CSLEDIT_data.getNodeStack(id),
				node,
				iter,
				next,
				macroName,
				timesUsed;

			while (nodeStack.length > 0) {
				node = nodeStack.pop();
				if (node.name === "macro" && recentlyEditedMacro !== node.cslId) {
					macroName = new CSLEDIT_CslNode(node).getAttr("name");
					if (macroName === "") {
						return;
					}

					// check how many places this macro is used
					iter = new CSLEDIT_Iterator(CSLEDIT_data.get());
					timesUsed = 0;

					while (iter.hasNext()) {
						next = new CSLEDIT_CslNode(iter.next());

						if (next.name === "text" && next.getAttr("macro") === macroName) {
							timesUsed++;

							if (timesUsed > 1) {
								recentlyEditedMacro = node.cslId;
								CSLEDIT_notificationBar.showMessage(
									'You just edited a macro which is used in multiple places');
							}
						}
					}
				}
			}
		};

		var setSuppressSelectNode = function (suppress) {
			suppressSelectNode = suppress;
		};

		var addNode = function (id, position, newNode, nodesAdded) {
			macroEditNotification(id);	
			$.each(views, function (i, view) {
				if ("addNode" in view) {
					view.addNode(id, position, newNode, nodesAdded);
				}
			});
			if (!suppressSelectNode) {
				selectNode(newNode.cslId);
			}
		};

		var deleteNode = function (id, nodesDeleted) {
			macroEditNotification(id - 1);
			$.each(views, function (i, view) {
				if ("deleteNode" in view) {
					view.deleteNode(id, nodesDeleted);
				}
			});
		};

		var amendNode = function (id, amendedNode) {
			macroEditNotification(id);
			$.each(views, function (i, view) {
				if ("amendNode" in view) {
					view.amendNode(id, amendedNode);
				}
			});
			debug.log("amendNode - calling selectedNodeChanged");
			selectedNodeChanged();
		};

		var selectNode = function (id, highlightedNodes) {
			var treeNode,
				headingNode;
			
			headingNode = treeView.find('span[cslid=' + id + ']');

			if (typeof(highlightedNodes) === "undefined") {
				treeNode = treeView.find('li[cslid=' + id + '] > a');
			} else {
				treeNode = highlightedNodes.filter('li[cslid=' + id + ']').children('a');
			}

			if (headingNode.length === 0 && treeNode.length > 0) {
				clickNode(treeNode.first());
			} else {
				selectedNodeId = id;
				selectedNodeChanged();
			}
		};

		var selectNodeFromPath = function (nodePath) {
			var treeNode = treeView,
				cslId;

			debug.log("select node from path");
			$.each(nodePath, function (i, cslId) {
				treeNode = treeNode.find('li[cslId="' + cslId + '"]');
			});

			treeNode = treeNode.children('a');

			if (treeNode.length > 0) {
				clickNode(treeNode.first());
			}
		};

		var clickNode = function (node) {
			node.click();

			treeView.scrollTo(node, 200, {
				offset: {left: -treeView.width() + 80, top: -treeView.height() * 0.4}
			});
		};

		var selectedNode = function () {
			return selectedNodeId;
		};

		var selectedViewProperty = function (property) {
			if (selectedTree === null) {
				return null;
			}
			if (property in selectedTree) {
				return selectedTree[property];
			}
			return null;
		};

		var expandNode = function (id) {
			$.each(views, function (i, view) {
				if ('expandNode' in view) {
					view.expandNode(id);
				}
			});
		};

		var styleChanged = function (command, args) {
			args = args || [];
			debug.log("executing view update: " + command + "(" + args.join(", ") + ")");
			this[command].apply(null, args);
		};
		
		var collapseAll = function () {
			$.each(views, function (i, view) {
				if ('collapseAll' in view) {
					view.collapseAll();
				}
			});
		};

		// public:
		return {
			init : init,

			addNode : addNode,
			deleteNode : deleteNode,
			amendNode : amendNode,
			newStyle : newStyle,

			selectNode : selectNode,
			selectedNode : selectedNode,

			expandNode : expandNode,

			collapseAll : collapseAll,

			formatCitations : function () {
				callbacks.formatCitations();
			},
				
			styleChanged : styleChanged,

			getSelectedNodePath : getSelectedNodePath,

			selectNodeFromPath : selectNodeFromPath,

			setSuppressSelectNode : setSuppressSelectNode,

			selectedViewProperty : selectedViewProperty
		};
	};
});




define('src/SyntaxHighlighter',['src/CslNode', 'src/cslData', 'src/debug'], function (CSLEDIT_CslNode, CSLEDIT_data, debug) {
	return function (editorElement) {
		var selectedCslId = -1,
			hoveredNodeStack = [],
			highlightedCss,
			selectedCss,
			unHighlightedCss,
			highlightedTreeNodes = $(),
			highlightTimeout;

		var selectedNodeChanged = function (newSelectedCslId) {
			selectedCslId = newSelectedCslId;

			editorElement.find('span[cslid].highlighted').removeClass("highlighted");
			editorElement.find('span[cslid].selected').removeClass("selected");

			editorElement.find('span[cslid="' + selectedCslId + '"]').removeClass("highlighted");
			editorElement.find('span[cslid="' + selectedCslId + '"]').addClass("selected");
		};

		var addToHoveredNodeStack = function (target) {
			// build stack 'backwards' from the inner node outwards
			var parentNode;
			
			if (typeof target.attr("cslid") !== "undefined") {
				hoveredNodeStack.unshift(target.attr("cslid"));
			}

			parentNode = target.parent();
			if (parentNode.length > 0) {
				addToHoveredNodeStack(parentNode);
			}
		};

		var removeFromHoveredNodeStack = function (cslidElements, removeAll) {
			// pop one node, or all nodes, from hoveredNodeStack
			var poppedNode;

			if (hoveredNodeStack.length > 0) {
				poppedNode = hoveredNodeStack.pop();
				unHighlightNode(poppedNode, cslidElements);

				if (removeAll) {
					removeFromHoveredNodeStack(cslidElements, removeAll);
				}
			}
		};

		var highlightNode = function (nodeStack) {
			var cslId = nodeStack[nodeStack.length - 1];

			highlightOutput(cslId);

			// undo previous highlighting
			clearTimeout(highlightTimeout);
			highlightTimeout = setTimeout(function () {
				unHighlightTree();
				highlightTree(nodeStack, null, 0);
			}, 100);
		};

		var highlightOutput = function (cslId)
		{
			var node = editorElement.find('span[cslid="' + cslId + '"]');

			if (node.hasClass("selected"))
			{
				// leave alone - selection takes precedence
			} else {
				node.addClass("highlighted");
			}
		};

		var reverseSelectNode = function (clickedCslId) {
			var index,
				cslId = parseInt(hoveredNodeStack[hoveredNodeStack.length - 1], 10),
				selectedNode;

			if (hoveredNodeStack.length === 0) {
				cslId = clickedCslId;
			} else {
				// skip the macro definition nodes, jump to the referencing 'text' node instead
				selectedNode = CSLEDIT_data.getNode(cslId);
				if (selectedNode.name === "macro") {
				debug.assert(hoveredNodeStack.length > 1);
					cslId = hoveredNodeStack[hoveredNodeStack.length - 2];
				}
			}

			if (selectedCslId !== cslId) {
				CSLEDIT_viewController.selectNode(cslId, highlightedTreeNodes);
			}
		};

		var unHighlightTree = function () {
			var node;

			clearTimeout(highlightTimeout);
			highlightedTreeNodes.children('a').removeClass("highlighted");
		};

		var unHighlightIfNotDescendentOf = function (instanceNode) {
			var index, nodes;

			$.each(highlightedTreeNodes, function () {
				var $this = $(this);
				if (instanceNode.find($this).length === 0) {
					$this.children('a').removeClass("highlighted");
					highlightedTreeNodes = highlightedTreeNodes.not($this);
				}
			});
		};

		// highlight node and all parents, stopping at the "style" node
		var highlightTree = function (nodeStack, node, depth) {
			var nodeIndex, parentNode, parentIndex, highlightedNode;

			if (node === null) {
				nodeIndex = nodeStack.pop();
				if (typeof nodeIndex === "undefined") {
					return;
				}
				node = editorElement.find('li[cslid="' + nodeIndex + '"]');
			}

			depth++;
		debug.assert(depth < 150, "stack overflow!");

			if (node.is('li')) {
				highlightedNode = node.children('a');
				highlightedTreeNodes = highlightedTreeNodes.add(node);
				highlightedNode.addClass("highlighted");
			}

			parentNode = node.parent().closest("li[cslid]");

			if (parentNode.length !== 0) {
				parentIndex = parentNode.attr("cslid");
				if (nodeStack[nodeStack.length - 1] === parentIndex) {
					nodeStack.pop();
				}
				highlightTree(nodeStack, parentNode, depth);
			} else {
				if (nodeStack.length > 1) {
					// Look for a possible macro instance "text" node in the nodeStack,
					// if found, clear the highlighting for all macros not within this
					// instance or the definition
					var instanceNode;
					instanceNode = new CSLEDIT_CslNode(
						CSLEDIT_data.getNode(parseInt(nodeStack[nodeStack.length - 2], 10)));
					if (instanceNode.name === "text" && instanceNode.getAttr("macro") !== "") {
						unHighlightIfNotDescendentOf(editorElement.find('li[cslid=' + instanceNode.cslId + ']'));
					}
				}
				// highlight any remaining nodes in the call stack
				// (e.g. if a macro was called)
				highlightTree(nodeStack, null, depth);
			}
		};

		var unHighlightNode = function (nodeIndex, cslidElements) {
			var	node;
			if (typeof(cslidElements) === "undefined") {
				node = editorElement.find('span[cslid="' + nodeIndex + '"]');
			} else {
				node = cslidElements.filter('span[cslid="' + nodeIndex + '"]');
			}

			if (node.hasClass("selected"))
			{
				// leave alone - selection takes precedence
			} else {
				node.removeClass("highlighted");
			}
		};

		var hover = function (event) {
			var cslidElements = $('span[cslid]'),
				target = $(event.target).closest("span[cslid]");
			
			// remove all
			removeFromHoveredNodeStack(cslidElements, true);

			// populate hovered node stack
			addToHoveredNodeStack(target);

			var lastNode = hoveredNodeStack[hoveredNodeStack.length - 1];
		debug.assertEqual(lastNode, target.attr("cslid"), "applySyntax");

			if (hoveredNodeStack.length > 0) {
				highlightNode(hoveredNodeStack.slice());
			}
		};

		var unhover = function () {
			var cslidElements = $('span[cslid]');

			removeFromHoveredNodeStack(cslidElements);
			
			if (hoveredNodeStack.length > 0) {
				highlightNode(hoveredNodeStack.slice());
			} else {
				unHighlightTree();
			}
		};

		var setupEventHandlers = function () {
			editorElement.find('span[cslid]').hover(hover, unhover);

			// set up click handling
			editorElement.find('span[cslid]').click(function (event) {
				var target = $(event.target).closest("span[cslid]"),
					cslId = parseInt(target.attr('cslId'), 10);
				reverseSelectNode(cslId);
			});

			// set up hovering over tree nodes
			editorElement.find('li[cslid] > a').unbind('mouseenter mouseleave');
			editorElement.find('li[cslid] > a').hover(
				function (event) {
					var target = $(event.target).closest("li[cslid]"),
						cslId = parseInt(target.attr('cslId'), 10);
					highlightOutput(cslId);
				},
				function (event) {
					var target = $(event.target).closest("li[cslid]"),
						cslId = parseInt(target.attr('cslId'), 10);
					unHighlightNode(cslId);
				}
			);
			editorElement.find('li[cslid] > a').hover(
				function (event) {
					var target = $(event.target),
						liElement = target.closest("li[cslid]"),
						cslId = parseInt(liElement.attr('cslId'), 10),
						nodeAndParent = CSLEDIT_data.getNodeAndParent(cslId),
						documentation;
					
					if (nodeAndParent.parent === null) {
						documentation = CSLEDIT_schema.documentation('root/' + nodeAndParent.node.name);
					} else {
						documentation = CSLEDIT_schema.documentation(
							nodeAndParent.parent.name + '/' + nodeAndParent.node.name);
					}

					if (documentation !== "") {
						target.attr("title", nodeAndParent.node.name + "\n\n" + documentation);
					}
				},
				function (event) { /* no-op */ }
			);

		};

		var setupSyntaxHighlighting = function () {
			var numCslNodes = CSLEDIT_data.numCslNodes();

			// clear the hovered node stack
			hoveredNodeStack.length = 0;
			selectedCslId = -1;

			setupEventHandlers();

			// highlight the selected node if there is one
			if (CSLEDIT_viewController.selectedNode() !== -1) {
				editorElement.find(
					'span[cslid=' + CSLEDIT_viewController.selectedNode() + ']').addClass('selected');
			}
		};

		return {
			selectedNodeChanged : selectedNodeChanged,
			setupSyntaxHighlighting : setupSyntaxHighlighting,
			hover : hover,
			unhover : unhover,
			reverseSelectNode : reverseSelectNode
		};
	};
});



// use this instead of accessing CSLEDIT_exampleData
define('src/exampleCitations',
		[	'jquery',
			'src/storage',
			'src/options',
			'src/exampleData'
		],
		function (
			jq,
			CSLEDIT_storage,
			CSLEDIT_options,
			CSLEDIT_exampleData
		) {
	var suppressUpdate = false;

	var newCitation = function (citationIndex) {
		return {
			citationId: "CITATION-" + citationIndex,
			citationItems: [],
			properties: {noteIndex: 0},
			schema: "https://github.com/citation-style-language/schema/raw/master/csl-citation.json"
		};
	};

	var getCitations = function () {
		var citations;
		if (CSLEDIT_storage.getItemJson('CSLEDIT_exampleCitations') === null) {

			// create empty reference lists for each citation
			citations = [];
			$.each(CSLEDIT_options.get("exampleCitations"), function (citation) {
				citations.push(newCitation(citation));
			});
			setCitations(citations);

			// populate the reference lists
			$.each(CSLEDIT_options.get("exampleCitations"), function (citation, referenceList) {
				setReferenceIndexesForCitation(citation, referenceList);
			});
		}
		return CSLEDIT_storage.getItemJson('CSLEDIT_exampleCitations');
	};
	var setCitations = function (citations) {
		applyCitationOptions(citations, getCitationOptions());
		CSLEDIT_storage.setItem('CSLEDIT_exampleCitations', JSON.stringify(citations));
		update();
	};
	
	var getCitationOptions = function () {
		if (CSLEDIT_storage.getItemJson('CSLEDIT_exampleCitationOptions') === null) {
			return {};
		}
		return CSLEDIT_storage.getItemJson('CSLEDIT_exampleCitationOptions');
	};
	var setCitationOptions = function (citationOptions) {
		var citations = getCitations();
		CSLEDIT_storage.setItem('CSLEDIT_exampleCitationOptions', JSON.stringify(citationOptions));
		
		applyCitationOptions(citations, citationOptions);
		setCitations(citations);
	};

	var applyCitationOptions = function (citations, citationOptions) {
		// apply options
		$.each(citations, function (citationIndex, citation) {
			var index;
			for (index = 0; index < citation.citationItems.length; index++) {
				var citationItem = citation.citationItems[index],
					referenceIndex = parseInt(citationItem.id.replace("ITEM-", ""), 10) - 1,
					optionIndex = getOption(citationIndex, referenceIndex),
					options = CSLEDIT_exampleData.additionalOptions[optionIndex];
			
				// replace all options
				citationItem = { id : citationItem.id };
				$.each(options.options, function (key, value) {
					citationItem[key] = value;
				});
				citation.citationItems[index] = citationItem;
			}
		});
	};

	var setOption = function (citation, reference, option) {
		var options = getCitationOptions();
		if (option >= CSLEDIT_exampleData.additionalOptions.length) {
			option = 0;
		}
		options[citation] = options[citation] || {};
		options[citation][reference] = option;
		setCitationOptions(options);
	};

	var getOption = function (citation, reference) {
		var options = getCitationOptions(),
			option;
		if (!options.hasOwnProperty(citation)) {
			return 0;
		}
		if (!options[citation].hasOwnProperty(reference)) {
			return 0;
		}
		option = options[citation][reference];
		if (option >= CSLEDIT_exampleData.additionalOptions.length) {
			option = 0;
		}
		return option;
	};

	var getCiteprocReferences = function () {
		var citeprocReferences = {};

		$.each(getReferences(), function (i, reference) {
			var itemString = "ITEM-" + (i + 1);
			reference.id = itemString;
			citeprocReferences[itemString] = reference;
		});

		return citeprocReferences;
	};		

	var getReferences = function () {
		if (CSLEDIT_storage.getItemJson('CSLEDIT_exampleReferences') === null) {
			setReferences(CSLEDIT_options.get('exampleReferences'));
		}
		return CSLEDIT_storage.getItemJson('CSLEDIT_exampleReferences');
	};
	var setReferences = function (referenceList) {
		CSLEDIT_storage.setItem('CSLEDIT_exampleReferences', JSON.stringify(referenceList));

		suppressUpdate = true;
		$.each(getCitations(), function (i, citation) {
			limitReferenceIndexesForCitation(i);
		});
		suppressUpdate = false;

		update();
	};

	// remove out of range indexes
	var limitReferenceIndexesForCitation = function (citationIndex) {
		var newReferenceList = [],
			references = getReferences();

		$.each(getReferenceIndexesForCitation(citationIndex), function (i, referenceIndex) {
			if (referenceIndex < references.length) {
				newReferenceList.push(referenceIndex);
			}
		});
		setReferenceIndexesForCitation(citationIndex, newReferenceList);
	};

	var getReferenceIndexesForCitation = function (citationIndex) {
		var indexes = [],
			citations = getCitations();

		if (citationIndex >= citations.length) {
			return [];
		}

		$.each(citations[citationIndex].citationItems, function (i, citationItem) {
			indexes.push(parseInt(citationItem.id.replace("ITEM-", ""), 10) - 1);
		});

		return indexes;
	};

	var setReferenceIndexesForCitation = function (citationIndex, references) {
		var citations = getCitations();
		
		citations[citationIndex] = citations[citationIndex] || newCitation(citationIndex);
		citations[citationIndex].citationItems = [];

		$.each(references, function (i, referenceIndex) {
			citations[citationIndex].citationItems.push({
				id : "ITEM-" + (referenceIndex + 1)
			});
		});

		setCitations(citations);
	};
	
	var addReference = function (referenceData, citationToAddTo /* optional */ ) {
		var references = getReferences(),
			citations;
		references.push(referenceData);
		setReferences(references);

		if (typeof citationToAddTo !== "undefined") {
			citations = getCitations();
			citations[citationToAddTo].citationItems.push({
				id : "ITEM-" + references.length
			});
			setCitations(citations);
		}
	};

	var setJsonDocumentList = function (jsonDocumentList) {
		CSLEDIT_exampleData.jsonDocumentList = jsonDocumentList;

		update();
	};

	var update = function () {
		if (!suppressUpdate && typeof(CSLEDIT_viewController) !== "undefined") {
			CSLEDIT_viewController.styleChanged("formatCitations");
		}
	};

	return {
		getCitations : getCitations,
		setCitations : setCitations,

		getCitationOptions : getCitationOptions,
		setCitationOptions : setCitationOptions,

		getOption : getOption,
		setOption : setOption,

		getReferences : getReferences,
		setReferences : setReferences,

		getCiteprocReferences : getCiteprocReferences,

		getReferenceIndexesForCitation : getReferenceIndexesForCitation,
		setReferenceIndexesForCitation : setReferenceIndexesForCitation,

		addReference : addReference,

		resetToDefault : function () {
			CSLEDIT_storage.removeItem("CSLEDIT_exampleCitations");
			CSLEDIT_storage.removeItem("CSLEDIT_exampleReferences");
			CSLEDIT_storage.removeItem("CSLEDIT_exampleCitationOptions");
			update();
		}
	};
});



define('src/citationEditor',
		[	'src/exampleCitations',
			'src/exampleData',
			'src/debug',
			'jquery.ui'
		],
		function (
			CSLEDIT_exampleCitations,
			CSLEDIT_exampleData,
			debug,
			jquery_ui
		) {
	var dialog = $('<div/>'),
		advanced = $('<div/>', {id: "accordion"}).css({"padding-top": "10px", width: "100%"}),
		advancedContents = $('<div/>'),
		referencePanel = $('<div class="refrenceList" />'),
		newReferenceInput = $('<textarea class="addReference" /><br />').css({width: "100%", height: "100px"}),
		addReferenceButton = $('<button>Add new reference</button>'),
		resetReferencesButton = $('<button>Reset <strong>all</strong> citations to default</button>'),
		citation,
		initialised = false;

	dialog.append(referencePanel);
	dialog.append(resetReferencesButton);
	dialog.append(advanced);

	advanced.append('<h3><a href="#">Advanced</a></h3>');
	advanced.append(advancedContents);

	advancedContents.append("<h3>Add new reference</h3>");
	advancedContents.append("<p>Input csl-data.json here and click \"Add new Reference\"</p>");
	advancedContents.append(newReferenceInput);
	advancedContents.append(addReferenceButton);

	resetReferencesButton.on('click', function () {
		CSLEDIT_exampleCitations.resetToDefault();
		updateReferenceList();
	});

	addReferenceButton.on('click', function () {
		var jsonData,
			referenceList;
	   
		try {
			jsonData = JSON.parse(newReferenceInput.val());
		} catch (e) {
			alert("Error: Not valid JSON");
			return;
		}

		// will accept individual references or a list
		referenceList = [].concat(jsonData);
		$.each(referenceList, function (i, reference) {
			CSLEDIT_exampleCitations.addReference(reference, citation);
		});

		updateReferenceList();
		newReferenceInput.val("");
	});

	var updateReferenceList = function () {
		var table = $('<table/>');

		referencePanel.children().remove();

		$.each(CSLEDIT_exampleCitations.getReferences(), function (i, reference) {
			var row = $('<tr/>'),
				input,
				label1,
				label2,
				select;

			input = $('<input/>', {
				type : "checkbox",
				id : "citationEditorReference" + i
			});
			label1 = $('<label/>', {
				for : "citationEditorReference" + i
			}).append('<strong>' + reference.type + '</strong>');
			label2 = $('<label/>', {
				for : "citationEditorReference" + i
			}).append(reference.title);
			select = $('<select/>');
			$.each(CSLEDIT_exampleData.additionalOptions, function (i, option) {
				select.append('<option>' + option.description + '</option>');
			});
			var desc;
			desc = CSLEDIT_exampleData.additionalOptions[
				CSLEDIT_exampleCitations.getOption(citation, i)].description;
			debug.log(desc);
			select.val(desc);

			row.append($('<td/>').append(input));
			row.append($('<td/>').append(label1));
			row.append($('<td/>').append(label2));
			row.append($('<td/>').append(select));
			table.append(row);
		});
		referencePanel.append(table);

		table.find('td').css({"padding-right": "8px"});

		debug.log("checked = " +
				JSON.stringify(CSLEDIT_exampleCitations.getReferenceIndexesForCitation(citation)));

		$.each(CSLEDIT_exampleCitations.getReferenceIndexesForCitation(citation), function (i, refIndex) {
			referencePanel.find('input[type=checkbox]').eq(refIndex).attr('checked', true);
		});
		referencePanel.find('input[type=checkbox]').on('change', function () {
			updateCitations();
		});
		referencePanel.find('select').on('change', function () {
			var reference = referencePanel.find('select').index($(this)),
				optionIndex = $(this).children('option').index(
					$(this).children('option[value="' + $(this).val() + '"]'));

			CSLEDIT_exampleCitations.setOption(citation, reference, optionIndex);
		});
	};

	var updateCitations = function () {
		var citationItem,
			citationItems = [],
			checked = [],
			additionalOptions;

		referencePanel.find('input').each(function (index) {
			if ($(this).is(':checked')) {
				//citationItem = {id:"ITEM-" + (index + 1)};
				/* TODO: additional options
				additionalOptions = CSLEDIT_exampleData.additionalOptions[index];
				if (typeof additionalOptions !== "undefined") {
					// add options to citationItem
					$.each (additionalOptions.options, function (key, value) {
						citationItem[key] = value;
					});
				}
				*/
				//citationItems.push(citationItem);
				checked.push(index);
			}
		});
		
		debug.log("setting " + citation + " to " + JSON.stringify(checked));

		CSLEDIT_exampleCitations.setReferenceIndexesForCitation(citation, checked);
	};

	var editCitation = function (_citation) {
		citation = _citation;
		updateReferenceList();

		// list references
		dialog.dialog({
			title : 'Edit Citation ' + (citation + 1),
			width : 700
		});

		if (!initialised) {
			advanced.accordion({
				collapsible : true,
				active : false
			});
			initialised = true;
		}
		
		if (dialog.height() > $(window).height() - 50) {
			dialog.height($(window).height() - 50);
		}
		if (dialog.offset().top < 80) {
			dialog.dialog("option", "position", [dialog.offset().left, 80]);
		}
	};

	return {
		editCitation : editCitation 
	};
});

// Responsible for parsing a .rng file
// The file must be in XML form, not the compact notation (.rnc)
//
// (only tested with the csl.rng and it's includes)
//
// It generates properties for each element type:
//
// - data type if applicable (e.g. text, anyURI)
// - list of attributes, and thier possible values
// - list of child elements
// 
// It assumes that an element can be uniquely identified by it's name + parent's name



define('src/Schema',['src/options', 'src/storage', 'src/debug'], function (CSLEDIT_options, CSLEDIT_storage, debug) {
	var CSLEDIT_Schema = function (
			schemaOptions /* used to apply modifications appropriate to Visual Editor */ ) {
		var mainSchemaData,
			schemas = [],
			nodesParsed = 0,
			nodeProperties = {}, // The possible child elements and attributes for each
								 // node name
			defineProperties = {},
			urlsGot = 0,
			callback = null,
			initialised = false,
			refParents = {},
			lastAttributeValue = null, // needed because the documentation for an attribute value
									   // comes after, instead of within, and attribute
			mainSchemaURL = CSLEDIT_options.get("cslSchema_mainURL"),
			includeSchemaURLs = CSLEDIT_options.get("cslSchema_childURLs");

		var readSchemaFromStorage = function () {
			var mainSchema = JSON.parse(CSLEDIT_storage.getItem("CSLEDIT_mainSchema")),
				subSchemas = JSON.parse(CSLEDIT_storage.getItem("CSLEDIT_subSchemas"));

			if (mainSchema !== null) {
				$.each(mainSchema, function (name, data) {
					debug.log("WARNING: Using custom schema: " + name);
					mainSchemaData = data;
				});

				if (subSchemas !== null) {
					$.each(subSchemas, function (name, data) {
						debug.log("Adding custom sub schema: " + name);
						schemas.push(data);
					});
				}
			}
		};

		var NodeProperties = function (copySource) {
			if (typeof(copySource) === "undefined") {
				return {
					elements : {},
					attributes : {},
					refs : [],
					refQuantifiers : {},
					attributeValues : [],
					textNode : false,
					list : false,
					choices : [],
					documentation : ""
				};
			} else {
				// deep copy
				return JSON.parse(JSON.stringify(copySource));
			}
		};

		var init = function () {
			// parse the schema element by element
			var parser = new DOMParser(),
				xmlDoc;

			xmlDoc = parser.parseFromString(mainSchemaData, "application/xml");

			// This is the root node for the grammar
			nodeProperties["root"] = parseChildren(xmlDoc);

			$.each(schemas, function (i, schemaData) {
				xmlDoc = parser.parseFromString(schemaData, "application/xml");
			
				// Parse schema
				parseChildren(xmlDoc);
			});

			// Simplify schema (replace each refs with the corresponding define)
			simplify();

			if (schemaOptions && 'processNodeProperties' in schemaOptions) {
				schemaOptions.processNodeProperties(nodeProperties);
			}

			initialised = true;
			if (callback !== null) {
				callback();
			}
		};

		var simplify = function () {
			var node, defRegExp, match, originalNodes = [], newNodeName;

			for (node in nodeProperties) {
				simplifyNode(node, nodeProperties[node]);
			}

			// replace all def: references in node names with the appropriate child nodes, expanding
			// out the as neccessary
			defRegExp = new RegExp("def:([\\w-\\.]+)/(.*)$");

			for (node in nodeProperties) {
				originalNodes.push(node);
			}

			$.each(originalNodes, function (i, node) {
				match = defRegExp.exec(node);
				if (match !== null) {
					$.each(refParents[match[1]], function (i2, refParent) {
						newNodeName = refParent + "/" + match[2];
						if (newNodeName in nodeProperties) {
							joinProperties(nodeProperties[newNodeName], nodeProperties[node]);
						} else {
							nodeProperties[newNodeName] = nodeProperties[node];
						}
					});

					delete nodeProperties[node];
				}
			});
		};

		var elementName = function (elementStackString) {
			return elementStackString.replace(/^.*\//, "");
		};

		var simplifyNode = function (nodeName, node) {
			var define,
				ref,
				refQuantifier,
				attributeName,
				nodeLocalName,
				element;

			ref = node.refs.pop();
			refQuantifier = node.refQuantifiers[ref];

			if (typeof ref === "undefined") {
				for (attributeName in node.attributes) {
					// already mostly simplified, just need to dereference the attr. values
					simplifyAttributeValues(node.attributes, attributeName);
				}
				simplifyChoices(node);

				// remove general attribute if it's also a choice attribute
				// TODO: check with CSL guys if there's a bug in the schema
				//       which makes this necessary for cs:date and cs:date-part
				$.each(node.choices, function (i, choice) {
					var index;

					$.each(choice.attributes, function (attributeName) {
						if (attributeName in node.attributes) {
							debug.log("WARNING: " + attributeName +
								" in choice and general attributes for node " + nodeName);
							debug.log("Deleting the general attribute");
							delete node.attributes[attributeName];
							index--;
						}
					});
				});

				// remove refs array
				delete node.refs;
				return;
			}
			
			if (ref.name in defineProperties) {
				// deep copy so that original define won't change
				define = new NodeProperties(defineProperties[ref.name]);

				// set quantifier to all child elements within the define
				if (typeof(refQuantifier) !== "undefined") {
					for (element in define.elements) {
						define.elements[element] = refQuantifier;
					}

					// move choices to general attrs.
					removeChoices(define);
				}

				if ("defaultValue" in ref && ref.defaultValue !== null) {
					$.each(define.attributes, function (name, attribute) {
						attribute.defaultValue = ref.defaultValue;
					});
				}
				joinProperties(node, define);
				simplifyNode(nodeName, node);
			
			debug.assert(elementName(nodeName).indexOf("def:") === -1, "define parent");

				if (ref.name in refParents) {
					if (refParents[ref.name].indexOf(elementName(nodeName)) === -1) {
						refParents[ref.name].push(elementName(nodeName));
					}
				} else {
					refParents[ref.name] = [ elementName(nodeName) ];
				}
			} else {
			debug.assert(false, "Couldn't find define: " + ref.name);
			}
		};

		var simplifyAttributeValues = function (attributes, attributeName) {
			var ref,
				define;

			// note: refs may already be deleted because
			// this attribute may have referenced in a different element,
			// and it's already been simplified
			if (typeof attributes[attributeName].refs === "undefined") {
				return;
			}

			ref = attributes[attributeName].refs.pop();

			if (typeof ref === "undefined") {
				// simplified
				
				// note, that refs may already be deleted because
				// it may have been referenced somewhere else
				if (typeof attributes[attributeName].refs !== "undefined") {
					delete attributes[attributeName].refs;
				}
				return;
			}

			if (ref.name in defineProperties) {
				define = defineProperties[ref.name];
				
				arrayMerge(attributes[attributeName].values,
					define.attributeValues);
				arrayMerge(attributes[attributeName].refs,
					define.refs);

				simplifyAttributeValues(attributes, attributeName);
			} else {
			debug.assert(false, "Couldn't find attr value define: " + ref.name);
			}
		};

		var attributeNamesFromRef = function (ref) {
			var define = defineProperties[ref.name],
				attributeNames = [];

		debug.assert(typeof define !== 'undefined');

			$.each(define.refs, function (i, ref) {
				attributeNames = attributeNames.concat(attributeNamesFromRef(ref));
			});

			$.each(define.attributes, function (name, attribute) {
				attributeNames.push(name);
			});

			return attributeNames;
		};

		var simplifyChoices = function (node) {
			var index;

			$.each(node.choices, function (i, choice) {
				$.each(choice.refs, function (i2, ref) {
					var define = defineProperties[ref.name];
					attributesMerge(choice.attributes, define.attributes);
				});
				//delete choice.refs;
			});
			$.each(node.choices, function (i, choice) {
				var attributeName;
				for (attributeName in choice.attributes) {
					// already mostly simplified, just need to dereference the attr. values
					simplifyAttributeValues(choice.attributes, attributeName);
				}
			});

			// remove any choices with no attributes
			for (index = 0; index < node.choices.length; index++) {
				if (Object.keys(node.choices[index].attributes).length === 0) {
					node.choices.splice(index, 1);
					index--;
				}
			}
		};

		var arrayContains = function (array, element, equalityFunction) {
			if (typeof equalityFunction === "undefined") {
				equalityFunction = function (a, b) {return a === b; };
			}

			var index;
			for (index = 0; index < array.length; index++) {
				if (equalityFunction(array[index], element)) {
					return true;
				}
			}
			return false;
		};
		
		// merge the two arrays putting result in arrayA
		var arrayMerge = function (arrayA, arrayB, equalityFunction) {
			if (typeof arrayB === "undefined") {
				return;
			}

			$.each(arrayB, function (i, eleB) {
				if (!arrayContains(arrayA, eleB, equalityFunction)) {
					arrayA.push(eleB);
				}
			});
		};

		var parseChildren = function (node, applyToEachChild) {
			var index,
				parser,
				childNode,
				nodeProperties = new NodeProperties(),
				childResult;

			if (node.nodeName !== null) {
				nodesParsed++;
			}

			// add child results to the result list
			$.each(node.childNodes, function (i, childNode) {
				if (childNode.localName !== null) {
					if (childNode.nodeName in nodeParsers) {
						childResult = nodeParsers[childNode.nodeName](childNode);

						if (childResult !== null) {
							if (typeof applyToEachChild === "function") {
								applyToEachChild(childResult);
							}

							joinProperties(nodeProperties, childResult);
						}
					} else {
						// couldn't parse
					}
				}
			});

			return nodeProperties;
		};

		var attributeValueEquality = function (a, b) {
			return (a.type === b.type && a.value === b.value);
		};

		var attributesMerge = function (attributesA, attributesB) {
			var attribute;

			for (attribute in attributesB) {
				if (!(attribute in attributesA)) {
					attributesA[attribute] = attributesB[attribute];
				} else {
					arrayMerge(attributesA[attribute].values,
						attributesB[attribute].values, attributeValueEquality);
				
					arrayMerge(attributesA[attribute].refs,
						attributesB[attribute].refs);
				}
			}
		};

		var joinProperties = function (propertiesA, propertiesB) {
			var element,
				documentation = [];

			$.each(propertiesB.elements, function (element, quantifier) {
				if (!(element in propertiesA.elements) || propertiesA.elements[element] === "") {
					propertiesA.elements[element] = propertiesB.elements[element];
				} else {
					// propertiesA.elements[element] !== "", so keep it
				}
			});
			attributesMerge(propertiesA.attributes, propertiesB.attributes);

			arrayMerge(propertiesA.choices, propertiesB.choices, function (a, b) {
				// TODO: if this fails, should check again if a equals b using
				//       guaranteed deterministic alternative to JSON.stringify
				return JSON.stringify(a) === JSON.stringify(b);
			});

			arrayMerge(propertiesA.refs, propertiesB.refs);

			$.each(propertiesB.refQuantifiers, function (ref, quantifier) {
				if (!(ref in propertiesA.refQuantifiers) || propertiesA.refQuantifiers[ref] === "") {
					propertiesA.refQuantifiers[ref] = quantifier;
				}
			});

			arrayMerge(propertiesA.attributeValues, propertiesB.attributeValues, attributeValueEquality);

			propertiesA.textNode = propertiesA.textNode | propertiesB.textNode;
			propertiesA.list = propertiesA.list | propertiesB.list;
			
			if (propertiesA.documentation !== "") {
				documentation.push(propertiesA.documentation);
			}
			if (propertiesB.documentation !== "") {
				documentation.push(propertiesB.documentation);
			}

			propertiesA.documentation = documentation.join("\n");
		};

		var elementStack = [];
		var elementStackString = function () {
			var topTwoElements = [],
				index = elementStack.length - 1;

			while (index >= 0 && topTwoElements.length < 2) {	
				topTwoElements.splice(0, 0, elementStack[index]);
				index--;
			}

			return topTwoElements.join("/");
		};

		var applyQuantifierToChildren = function (quantifier) {
			return function (childNodeProperties) {
				var newElements = {},
					index;

				childNodeProperties.quantity = quantifier;
				$.each(childNodeProperties.elements, function (elementName, quantity) {
					newElements[elementName] = quantifier;
				});
				$.each(childNodeProperties.refs, function (i, ref) {
					childNodeProperties.refQuantifiers[ref] = quantifier;
				});
				childNodeProperties.elements = newElements;
			};
		};

		// moves the choice refs and attributes to the general node refs and attributes
		var removeChoices = function (nodeProperties) {
			$.each(nodeProperties.choices, function (i, choice) {
				attributesMerge(nodeProperties.attributes, choice.attributes);
				arrayMerge(nodeProperties.refs, choice.refs);
			});
			nodeProperties.choices = [];
		};

		// a list of functions which attempt to parse a node
		// return true if parsed, false if not
		var nodeParsers = {
			element : function (node) {
				var thisNodeProperties = new NodeProperties(),
					thisElementName = node.attributes.item("name").nodeValue,
					newProperties;

				// only want elements starting with cs:
				if ((/^cs:/).test(thisElementName)) {
					thisElementName = thisElementName.replace(/^cs:/, "");

					elementStack.push(thisElementName);
					thisNodeProperties.elements[thisElementName] = "one";

					newProperties = parseChildren(node);

					if (elementStackString() in nodeProperties) {
						joinProperties(nodeProperties[elementStackString()], newProperties);
					} else {
						nodeProperties[elementStackString()] = newProperties;
					}

					elementStack.pop();
					return thisNodeProperties;
				} else {
					// ignore non cs: elements/
				debug.assert(false);
					return null;
				}
			},
			attribute : function (node) {
				var thisNodeProperties = new NodeProperties(),
					attributeName = node.attributes.item("name").nodeValue.replace(/^xml:/, ""),
					defaultValue = node.attributes.getNamedItem("a:defaultValue"),
					values;

				lastAttributeValue = null;

				values = parseChildren(node);

				if (values.textNode) {
					// Will accept any free-form text
					thisNodeProperties.attributes[attributeName] = {
						values : [],
						refs : [],
						list : values.list,
						documentation : values.documentation
					};
				} else {
					thisNodeProperties.attributes[attributeName] = {
						values : values.attributeValues,
						refs : values.refs,
						list : values.list,
						documentation : values.documentation
					};
					if (values.attributeValues.length > 0 &&
							(values.attributeValues[0].type === "value" ||
							 (values.attributeValues[0].type === "data" &&
							  values.attributeValues[0].value === "integer")
							) &&
							schemaOptions && 'defaultDefaultAttribute' in schemaOptions) {
						// add an empty string if no default value is present
						if (defaultValue === null) {
							defaultValue = {
								value: schemaOptions.defaultDefaultAttribute.value
							};
						
							if (thisNodeProperties.attributes[attributeName].values.length > 0) {
								thisNodeProperties.attributes[attributeName].values.splice(
										0, 0, schemaOptions.defaultDefaultAttribute);
							}
						}
					}
				}

				if (defaultValue !== null) {
					thisNodeProperties.attributes[attributeName].defaultValue = defaultValue.value;
				}

				return thisNodeProperties;
			},
			group : function (node) {
				return parseChildren(node);
			},
			interleave : function (node) {
				return parseChildren(node);
			},
			choice : function (node) {
				var choices = [],
					thisNodeProperties,
					applyToEachChild = function (childNodeProperties) {
						var choice = {
								attributes : {},
								refs : []
							},
							containsChoice = false;

						// nested choices not supported
					debug.assertEqual(childNodeProperties.choices.length, 0);

						$.each(childNodeProperties.refs, function (i, choiceRef) {
							choice.refs.push(choiceRef);
							containsChoice = true;
						});

						$.each(childNodeProperties.attributes, function (attributeName, attribute) {
							choice.attributes[attributeName] = attribute;
							containsChoice = true;
						});

						if (containsChoice) {
							choices.push(choice);
						}

						childNodeProperties.attributes = {};
					};

				thisNodeProperties = parseChildren(node, applyToEachChild);
				thisNodeProperties.choices = choices;

				return thisNodeProperties;
			},
			optional : function (node) {
				return parseChildren(node, applyQuantifierToChildren("optional"));
			},
			zeroOrMore : function (node) {
				var thisNodeProperties = parseChildren(node, applyQuantifierToChildren("zeroOrMore"));

				// choices are no longer mutually exclusive
				removeChoices(thisNodeProperties);

				return thisNodeProperties;
			},
			oneOrMore : function (node) {
				var thisNodeProperties = parseChildren(node, applyQuantifierToChildren("oneOrMore"));

				// choices are no longer mutually exclusive
				removeChoices(thisNodeProperties);

				return thisNodeProperties;
			},
			list : function (node) {
				var thisNodeProperties = parseChildren(node);
				thisNodeProperties.list = true;

				return thisNodeProperties;
			},
			mixed : function (node) {
				return parseChildren(node);
			},
			ref : function (node) {
				var thisNodeProperties = new NodeProperties(),
					nodeName = node.attributes.item("name").nodeValue,
					defaultValue = node.attributes.getNamedItem("a:defaultValue"),
					ref = {};

				ref.name = nodeName;
				if (defaultValue !== null) {
					ref.defaultValue = defaultValue.value;
				}

				thisNodeProperties.refs.push(ref);
				return thisNodeProperties;
			},
			parentRef : function (node) {
				// not used in the CSL schema
			debug.assert(false, "parentRef not supported");
				return null;
			},
			empty : function (node) {
				return null;
			},
			text : function (node) {
				var thisNodeProperties = new NodeProperties();
				thisNodeProperties.textNode = true;
				return thisNodeProperties;
			},
			value : function (node) {
				var thisNodeProperties = new NodeProperties(),
					childNodes = parseChildren(node);

				lastAttributeValue = {
					type : "value",
					value : node.textContent,
					documentation : ""
				};
				thisNodeProperties.attributeValues = [lastAttributeValue];
				return thisNodeProperties;
			},
			data : function (node) {
				var thisNodeProperties = new NodeProperties();
				thisNodeProperties.attributeValues = [{
					type : "data",
					value : node.attributes.item("type").nodeValue
				}];
				return thisNodeProperties;
			},
			notAllowed : function (node) {
				// not sure what this does
				return null;
			},
			grammar : function (node) {
				return parseChildren(node);
			},
			param : function (node) {
				return null;
			},
			div : function (node) {
				// divs can be ignored for now, they are only used to group documentation nodes
				return parseChildren(node);
			},
			include : function (node) {
				// TODO!
				return null;
			},
			start : function (node) {
				return parseChildren(node);
			},
			define : function (node) {
				// create new define
				var defineName;
				defineName = node.attributes.item("name").nodeValue;
				
				elementStack.push("def:" + defineName);
				defineProperties[defineName] = parseChildren(node);
				elementStack.pop();
				return null;
			},
			"a:documentation" : function (node) {
				var thisNodeProperties,
					documentation;

				if (schemaOptions && 'documentationFilter' in schemaOptions) {
					documentation = schemaOptions.documentationFilter(node.textContent);
				}

				if (lastAttributeValue === null) {
					thisNodeProperties = new NodeProperties();
					thisNodeProperties.documentation = documentation;
					return thisNodeProperties;				
				} else {
					lastAttributeValue.documentation = documentation;
					lastAttributeValue = null;
					return null;
				}
			}
		};

		// -- initialisation code --
		
		// schema set in localStorage overrides the URLs
		readSchemaFromStorage();

		if (typeof(mainSchemaData) === "undefined") {
			$.ajax({
				url : mainSchemaURL, 
				success : function (data) {
					mainSchemaData = data;
					urlsGot++;
					if (urlsGot === includeSchemaURLs.length + 1) {
						init();
					}
				},
				error : function () {
					throw new Error("Couldn't fetch main schema from: " + mainSchemaURL);
				},
				dataType : "text"
			});

			$.each(includeSchemaURLs, function (i, url) {
				$.ajax({
					url : url,
					success : function (data) {
						schemas.push(data);
						urlsGot++;
						if (urlsGot === includeSchemaURLs.length + 1) {
							init();
						}
					},
					error : function () {
						throw new Error("Couldn't fetch sub schema from: " + url);
					},
					dataType : "text"
				});
			});
		} else {
			init();
		}

		return {
			attributes : function (element) {
				return nodeProperties[element].attributes;
			},
			childElements : function (element) {
				return nodeProperties[element].elements;
			},
			elementDataType : function (element) {
				var node = nodeProperties[element];

				if (nodeProperties[element].textNode) {
					return "text";
				}
			debug.assert(node.attributeValues.length < 2);
				if (node.attributeValues.length === 0 || node.attributeValues[0].type !== "data") {
					return null;
				} else {
					return node.attributeValues[0].value;
				}
			},
			choices : function (element) {
				return nodeProperties[element].choices;
			},
			documentation : function (element) {
				return nodeProperties[element].documentation;
			},
			allData : function () {
				return nodeProperties;
			},
			callWhenReady : function (newCallback) {
				if (initialised) {
					newCallback();
				} else {
					callback = newCallback;
				}
			},
			quantity : function (element) {
				return nodeProperties[element].quantity;
			},
			_nodeProperties : nodeProperties // for debugging
		};
	};

	return CSLEDIT_Schema;
});



/* Options for modifying the Schema for use in the CSL Editor
 */

define('src/schemaOptions',{
	defaultDefaultAttribute : {
		documentation: "No value",
		type: "novalue",
		value: ""
	},
	documentationFilter : function (documentation) {
		return documentation
			.replace(/\n/g, " ")
			.replace(/The font-formatting attributes are based on those of CSS and XSL-FO\./g, "");
	},
	processNodeProperties : function (nodeProperties) {
		// add an xmlns attribute to the style node
		nodeProperties["root/style"].attributes["xmlns"] = {
			defaultValue : "http://purl.org/net/xbiblio/csl",
			documentation : "",
			list : 0,
			values : [{
				documentation : "",
				type : "value",
				value : "http://purl.org/net/xbiblio/csl"
			}],
			alwaysOutput : true
		};

		nodeProperties["root/style"].attributes["version"].alwaysOutput = true;

		// remove empty default values from date-part choice elements
		$.each(nodeProperties["date/date-part"].choices, function (i, choice) {
			$.each(choice.attributes, function (attributeName, attribute) {
				if (attribute.values.length === 2 && attribute.values[0].type === "novalue") {
					attribute.values.splice(0, 1);
					attribute.defaultValue = attribute.values[0].value;
					attribute.alwaysOutput = true;
				}
			});
		});
		
		// change style node description
		nodeProperties["root/style"].documentation = "Set global formatting options";
		
		// add default for all delimiter attributes
		$.each(nodeProperties, function (i, node) {
			if ("delimiter" in node.attributes) {
				if (!("defaultValue" in node.attributes.delimiter)) {
					node.attributes.delimiter.defaultValue = ""; 
				}
			}
		});
	}
});

(function(){function diff_match_patch(){this.Diff_Timeout=1;this.Diff_EditCost=4;this.Match_Threshold=0.5;this.Match_Distance=1E3;this.Patch_DeleteThreshold=0.5;this.Patch_Margin=4;this.Match_MaxBits=32}
diff_match_patch.prototype.diff_main=function(a,b,c,d){"undefined"==typeof d&&(d=0>=this.Diff_Timeout?Number.MAX_VALUE:(new Date).getTime()+1E3*this.Diff_Timeout);if(null==a||null==b)throw Error("Null input. (diff_main)");if(a==b)return a?[[0,a]]:[];"undefined"==typeof c&&(c=!0);var e=c,f=this.diff_commonPrefix(a,b),c=a.substring(0,f),a=a.substring(f),b=b.substring(f),f=this.diff_commonSuffix(a,b),g=a.substring(a.length-f),a=a.substring(0,a.length-f),b=b.substring(0,b.length-f),a=this.diff_compute_(a,
b,e,d);c&&a.unshift([0,c]);g&&a.push([0,g]);this.diff_cleanupMerge(a);return a};
diff_match_patch.prototype.diff_compute_=function(a,b,c,d){if(!a)return[[1,b]];if(!b)return[[-1,a]];var e=a.length>b.length?a:b,f=a.length>b.length?b:a,g=e.indexOf(f);if(-1!=g)return c=[[1,e.substring(0,g)],[0,f],[1,e.substring(g+f.length)]],a.length>b.length&&(c[0][0]=c[2][0]=-1),c;if(1==f.length)return[[-1,a],[1,b]];return(e=this.diff_halfMatch_(a,b))?(f=e[0],a=e[1],g=e[2],b=e[3],e=e[4],f=this.diff_main(f,g,c,d),c=this.diff_main(a,b,c,d),f.concat([[0,e]],c)):c&&100<a.length&&100<b.length?this.diff_lineMode_(a,
b,d):this.diff_bisect_(a,b,d)};
diff_match_patch.prototype.diff_lineMode_=function(a,b,c){var d=this.diff_linesToChars_(a,b),a=d.chars1,b=d.chars2,d=d.lineArray,a=this.diff_main(a,b,!1,c);this.diff_charsToLines_(a,d);this.diff_cleanupSemantic(a);a.push([0,""]);for(var e=d=b=0,f="",g="";b<a.length;){switch(a[b][0]){case 1:e++;g+=a[b][1];break;case -1:d++;f+=a[b][1];break;case 0:if(1<=d&&1<=e){a.splice(b-d-e,d+e);b=b-d-e;d=this.diff_main(f,g,!1,c);for(e=d.length-1;0<=e;e--)a.splice(b,0,d[e]);b+=d.length}d=e=0;g=f=""}b++}a.pop();return a};
diff_match_patch.prototype.diff_bisect_=function(a,b,c){for(var d=a.length,e=b.length,f=Math.ceil((d+e)/2),g=f,h=2*f,j=Array(h),i=Array(h),k=0;k<h;k++)j[k]=-1,i[k]=-1;j[g+1]=0;i[g+1]=0;for(var k=d-e,p=0!=k%2,q=0,s=0,o=0,v=0,u=0;u<f&&!((new Date).getTime()>c);u++){for(var n=-u+q;n<=u-s;n+=2){var l=g+n,m;m=n==-u||n!=u&&j[l-1]<j[l+1]?j[l+1]:j[l-1]+1;for(var r=m-n;m<d&&r<e&&a.charAt(m)==b.charAt(r);)m++,r++;j[l]=m;if(m>d)s+=2;else if(r>e)q+=2;else if(p&&(l=g+k-n,0<=l&&l<h&&-1!=i[l])){var t=d-i[l];if(m>=
t)return this.diff_bisectSplit_(a,b,m,r,c)}}for(n=-u+o;n<=u-v;n+=2){l=g+n;t=n==-u||n!=u&&i[l-1]<i[l+1]?i[l+1]:i[l-1]+1;for(m=t-n;t<d&&m<e&&a.charAt(d-t-1)==b.charAt(e-m-1);)t++,m++;i[l]=t;if(t>d)v+=2;else if(m>e)o+=2;else if(!p&&(l=g+k-n,0<=l&&l<h&&-1!=j[l]&&(m=j[l],r=g+m-l,t=d-t,m>=t)))return this.diff_bisectSplit_(a,b,m,r,c)}}return[[-1,a],[1,b]]};
diff_match_patch.prototype.diff_bisectSplit_=function(a,b,c,d,e){var f=a.substring(0,c),g=b.substring(0,d),a=a.substring(c),b=b.substring(d),f=this.diff_main(f,g,!1,e),e=this.diff_main(a,b,!1,e);return f.concat(e)};
diff_match_patch.prototype.diff_linesToChars_=function(a,b){function c(a){for(var b="",c=0,f=-1,g=d.length;f<a.length-1;){f=a.indexOf("\n",c);-1==f&&(f=a.length-1);var q=a.substring(c,f+1),c=f+1;(e.hasOwnProperty?e.hasOwnProperty(q):void 0!==e[q])?b+=String.fromCharCode(e[q]):(b+=String.fromCharCode(g),e[q]=g,d[g++]=q)}return b}var d=[],e={};d[0]="";var f=c(a),g=c(b);return{chars1:f,chars2:g,lineArray:d}};
diff_match_patch.prototype.diff_charsToLines_=function(a,b){for(var c=0;c<a.length;c++){for(var d=a[c][1],e=[],f=0;f<d.length;f++)e[f]=b[d.charCodeAt(f)];a[c][1]=e.join("")}};diff_match_patch.prototype.diff_commonPrefix=function(a,b){if(!a||!b||a.charAt(0)!=b.charAt(0))return 0;for(var c=0,d=Math.min(a.length,b.length),e=d,f=0;c<e;)a.substring(f,e)==b.substring(f,e)?f=c=e:d=e,e=Math.floor((d-c)/2+c);return e};
diff_match_patch.prototype.diff_commonSuffix=function(a,b){if(!a||!b||a.charAt(a.length-1)!=b.charAt(b.length-1))return 0;for(var c=0,d=Math.min(a.length,b.length),e=d,f=0;c<e;)a.substring(a.length-e,a.length-f)==b.substring(b.length-e,b.length-f)?f=c=e:d=e,e=Math.floor((d-c)/2+c);return e};
diff_match_patch.prototype.diff_commonOverlap_=function(a,b){var c=a.length,d=b.length;if(0==c||0==d)return 0;c>d?a=a.substring(c-d):c<d&&(b=b.substring(0,c));c=Math.min(c,d);if(a==b)return c;for(var d=0,e=1;;){var f=a.substring(c-e),f=b.indexOf(f);if(-1==f)return d;e+=f;if(0==f||a.substring(c-e)==b.substring(0,e))d=e,e++}};
diff_match_patch.prototype.diff_halfMatch_=function(a,b){function c(a,b,c){for(var d=a.substring(c,c+Math.floor(a.length/4)),e=-1,g="",h,j,n,l;-1!=(e=b.indexOf(d,e+1));){var m=f.diff_commonPrefix(a.substring(c),b.substring(e)),r=f.diff_commonSuffix(a.substring(0,c),b.substring(0,e));g.length<r+m&&(g=b.substring(e-r,e)+b.substring(e,e+m),h=a.substring(0,c-r),j=a.substring(c+m),n=b.substring(0,e-r),l=b.substring(e+m))}return 2*g.length>=a.length?[h,j,n,l,g]:null}if(0>=this.Diff_Timeout)return null;
var d=a.length>b.length?a:b,e=a.length>b.length?b:a;if(4>d.length||2*e.length<d.length)return null;var f=this,g=c(d,e,Math.ceil(d.length/4)),d=c(d,e,Math.ceil(d.length/2)),h;if(!g&&!d)return null;h=d?g?g[4].length>d[4].length?g:d:d:g;var j;a.length>b.length?(g=h[0],d=h[1],e=h[2],j=h[3]):(e=h[0],j=h[1],g=h[2],d=h[3]);h=h[4];return[g,d,e,j,h]};
diff_match_patch.prototype.diff_cleanupSemantic=function(a){for(var b=!1,c=[],d=0,e=null,f=0,g=0,h=0,j=0,i=0;f<a.length;)0==a[f][0]?(c[d++]=f,g=j,h=i,i=j=0,e=a[f][1]):(1==a[f][0]?j+=a[f][1].length:i+=a[f][1].length,e&&e.length<=Math.max(g,h)&&e.length<=Math.max(j,i)&&(a.splice(c[d-1],0,[-1,e]),a[c[d-1]+1][0]=1,d--,d--,f=0<d?c[d-1]:-1,i=j=h=g=0,e=null,b=!0)),f++;b&&this.diff_cleanupMerge(a);this.diff_cleanupSemanticLossless(a);for(f=1;f<a.length;){if(-1==a[f-1][0]&&1==a[f][0]){b=a[f-1][1];c=a[f][1];
d=this.diff_commonOverlap_(b,c);e=this.diff_commonOverlap_(c,b);if(d>=e){if(d>=b.length/2||d>=c.length/2)a.splice(f,0,[0,c.substring(0,d)]),a[f-1][1]=b.substring(0,b.length-d),a[f+1][1]=c.substring(d),f++}else if(e>=b.length/2||e>=c.length/2)a.splice(f,0,[0,b.substring(0,e)]),a[f-1][0]=1,a[f-1][1]=c.substring(0,c.length-e),a[f+1][0]=-1,a[f+1][1]=b.substring(e),f++;f++}f++}};
diff_match_patch.prototype.diff_cleanupSemanticLossless=function(a){function b(a,b){if(!a||!b)return 6;var c=a.charAt(a.length-1),d=b.charAt(0),e=c.match(diff_match_patch.nonAlphaNumericRegex_),f=d.match(diff_match_patch.nonAlphaNumericRegex_),g=e&&c.match(diff_match_patch.whitespaceRegex_),h=f&&d.match(diff_match_patch.whitespaceRegex_),c=g&&c.match(diff_match_patch.linebreakRegex_),d=h&&d.match(diff_match_patch.linebreakRegex_),i=c&&a.match(diff_match_patch.blanklineEndRegex_),j=d&&b.match(diff_match_patch.blanklineStartRegex_);
return i||j?5:c||d?4:e&&!g&&h?3:g||h?2:e||f?1:0}for(var c=1;c<a.length-1;){if(0==a[c-1][0]&&0==a[c+1][0]){var d=a[c-1][1],e=a[c][1],f=a[c+1][1],g=this.diff_commonSuffix(d,e);if(g)var h=e.substring(e.length-g),d=d.substring(0,d.length-g),e=h+e.substring(0,e.length-g),f=h+f;for(var g=d,h=e,j=f,i=b(d,e)+b(e,f);e.charAt(0)===f.charAt(0);){var d=d+e.charAt(0),e=e.substring(1)+f.charAt(0),f=f.substring(1),k=b(d,e)+b(e,f);k>=i&&(i=k,g=d,h=e,j=f)}a[c-1][1]!=g&&(g?a[c-1][1]=g:(a.splice(c-1,1),c--),a[c][1]=
h,j?a[c+1][1]=j:(a.splice(c+1,1),c--))}c++}};diff_match_patch.nonAlphaNumericRegex_=/[^a-zA-Z0-9]/;diff_match_patch.whitespaceRegex_=/\s/;diff_match_patch.linebreakRegex_=/[\r\n]/;diff_match_patch.blanklineEndRegex_=/\n\r?\n$/;diff_match_patch.blanklineStartRegex_=/^\r?\n\r?\n/;
diff_match_patch.prototype.diff_cleanupEfficiency=function(a){for(var b=!1,c=[],d=0,e=null,f=0,g=!1,h=!1,j=!1,i=!1;f<a.length;){if(0==a[f][0])a[f][1].length<this.Diff_EditCost&&(j||i)?(c[d++]=f,g=j,h=i,e=a[f][1]):(d=0,e=null),j=i=!1;else if(-1==a[f][0]?i=!0:j=!0,e&&(g&&h&&j&&i||e.length<this.Diff_EditCost/2&&3==g+h+j+i))a.splice(c[d-1],0,[-1,e]),a[c[d-1]+1][0]=1,d--,e=null,g&&h?(j=i=!0,d=0):(d--,f=0<d?c[d-1]:-1,j=i=!1),b=!0;f++}b&&this.diff_cleanupMerge(a)};
diff_match_patch.prototype.diff_cleanupMerge=function(a){a.push([0,""]);for(var b=0,c=0,d=0,e="",f="",g;b<a.length;)switch(a[b][0]){case 1:d++;f+=a[b][1];b++;break;case -1:c++;e+=a[b][1];b++;break;case 0:1<c+d?(0!==c&&0!==d&&(g=this.diff_commonPrefix(f,e),0!==g&&(0<b-c-d&&0==a[b-c-d-1][0]?a[b-c-d-1][1]+=f.substring(0,g):(a.splice(0,0,[0,f.substring(0,g)]),b++),f=f.substring(g),e=e.substring(g)),g=this.diff_commonSuffix(f,e),0!==g&&(a[b][1]=f.substring(f.length-g)+a[b][1],f=f.substring(0,f.length-
g),e=e.substring(0,e.length-g))),0===c?a.splice(b-d,c+d,[1,f]):0===d?a.splice(b-c,c+d,[-1,e]):a.splice(b-c-d,c+d,[-1,e],[1,f]),b=b-c-d+(c?1:0)+(d?1:0)+1):0!==b&&0==a[b-1][0]?(a[b-1][1]+=a[b][1],a.splice(b,1)):b++,c=d=0,f=e=""}""===a[a.length-1][1]&&a.pop();c=!1;for(b=1;b<a.length-1;)0==a[b-1][0]&&0==a[b+1][0]&&(a[b][1].substring(a[b][1].length-a[b-1][1].length)==a[b-1][1]?(a[b][1]=a[b-1][1]+a[b][1].substring(0,a[b][1].length-a[b-1][1].length),a[b+1][1]=a[b-1][1]+a[b+1][1],a.splice(b-1,1),c=!0):a[b][1].substring(0,
a[b+1][1].length)==a[b+1][1]&&(a[b-1][1]+=a[b+1][1],a[b][1]=a[b][1].substring(a[b+1][1].length)+a[b+1][1],a.splice(b+1,1),c=!0)),b++;c&&this.diff_cleanupMerge(a)};diff_match_patch.prototype.diff_xIndex=function(a,b){var c=0,d=0,e=0,f=0,g;for(g=0;g<a.length;g++){1!==a[g][0]&&(c+=a[g][1].length);-1!==a[g][0]&&(d+=a[g][1].length);if(c>b)break;e=c;f=d}return a.length!=g&&-1===a[g][0]?f:f+(b-e)};
diff_match_patch.prototype.diff_prettyHtml=function(a){for(var b=[],c=/&/g,d=/</g,e=/>/g,f=/\n/g,g=0;g<a.length;g++){var h=a[g][0],j=a[g][1],j=j.replace(c,"&amp;").replace(d,"&lt;").replace(e,"&gt;").replace(f,"&para;<br>");switch(h){case 1:b[g]='<ins style="background:#e6ffe6;">'+j+"</ins>";break;case -1:b[g]='<del style="background:#ffe6e6;">'+j+"</del>";break;case 0:b[g]="<span>"+j+"</span>"}}return b.join("")};
diff_match_patch.prototype.diff_text1=function(a){for(var b=[],c=0;c<a.length;c++)1!==a[c][0]&&(b[c]=a[c][1]);return b.join("")};diff_match_patch.prototype.diff_text2=function(a){for(var b=[],c=0;c<a.length;c++)-1!==a[c][0]&&(b[c]=a[c][1]);return b.join("")};diff_match_patch.prototype.diff_levenshtein=function(a){for(var b=0,c=0,d=0,e=0;e<a.length;e++){var f=a[e][0],g=a[e][1];switch(f){case 1:c+=g.length;break;case -1:d+=g.length;break;case 0:b+=Math.max(c,d),d=c=0}}return b+=Math.max(c,d)};
diff_match_patch.prototype.diff_toDelta=function(a){for(var b=[],c=0;c<a.length;c++)switch(a[c][0]){case 1:b[c]="+"+encodeURI(a[c][1]);break;case -1:b[c]="-"+a[c][1].length;break;case 0:b[c]="="+a[c][1].length}return b.join("\t").replace(/%20/g," ")};
diff_match_patch.prototype.diff_fromDelta=function(a,b){for(var c=[],d=0,e=0,f=b.split(/\t/g),g=0;g<f.length;g++){var h=f[g].substring(1);switch(f[g].charAt(0)){case "+":try{c[d++]=[1,decodeURI(h)]}catch(j){throw Error("Illegal escape in diff_fromDelta: "+h);}break;case "-":case "=":var i=parseInt(h,10);if(isNaN(i)||0>i)throw Error("Invalid number in diff_fromDelta: "+h);h=a.substring(e,e+=i);"="==f[g].charAt(0)?c[d++]=[0,h]:c[d++]=[-1,h];break;default:if(f[g])throw Error("Invalid diff operation in diff_fromDelta: "+
f[g]);}}if(e!=a.length)throw Error("Delta length ("+e+") does not equal source text length ("+a.length+").");return c};diff_match_patch.prototype.match_main=function(a,b,c){if(null==a||null==b||null==c)throw Error("Null input. (match_main)");c=Math.max(0,Math.min(c,a.length));return a==b?0:a.length?a.substring(c,c+b.length)==b?c:this.match_bitap_(a,b,c):-1};
diff_match_patch.prototype.match_bitap_=function(a,b,c){function d(a,d){var e=a/b.length,g=Math.abs(c-d);return!f.Match_Distance?g?1:e:e+g/f.Match_Distance}if(b.length>this.Match_MaxBits)throw Error("Pattern too long for this browser.");var e=this.match_alphabet_(b),f=this,g=this.Match_Threshold,h=a.indexOf(b,c);-1!=h&&(g=Math.min(d(0,h),g),h=a.lastIndexOf(b,c+b.length),-1!=h&&(g=Math.min(d(0,h),g)));for(var j=1<<b.length-1,h=-1,i,k,p=b.length+a.length,q,s=0;s<b.length;s++){i=0;for(k=p;i<k;)d(s,c+
k)<=g?i=k:p=k,k=Math.floor((p-i)/2+i);p=k;i=Math.max(1,c-k+1);var o=Math.min(c+k,a.length)+b.length;k=Array(o+2);for(k[o+1]=(1<<s)-1;o>=i;o--){var v=e[a.charAt(o-1)];k[o]=0===s?(k[o+1]<<1|1)&v:(k[o+1]<<1|1)&v|(q[o+1]|q[o])<<1|1|q[o+1];if(k[o]&j&&(v=d(s,o-1),v<=g))if(g=v,h=o-1,h>c)i=Math.max(1,2*c-h);else break}if(d(s+1,c)>g)break;q=k}return h};
diff_match_patch.prototype.match_alphabet_=function(a){for(var b={},c=0;c<a.length;c++)b[a.charAt(c)]=0;for(c=0;c<a.length;c++)b[a.charAt(c)]|=1<<a.length-c-1;return b};
diff_match_patch.prototype.patch_addContext_=function(a,b){if(0!=b.length){for(var c=b.substring(a.start2,a.start2+a.length1),d=0;b.indexOf(c)!=b.lastIndexOf(c)&&c.length<this.Match_MaxBits-this.Patch_Margin-this.Patch_Margin;)d+=this.Patch_Margin,c=b.substring(a.start2-d,a.start2+a.length1+d);d+=this.Patch_Margin;(c=b.substring(a.start2-d,a.start2))&&a.diffs.unshift([0,c]);(d=b.substring(a.start2+a.length1,a.start2+a.length1+d))&&a.diffs.push([0,d]);a.start1-=c.length;a.start2-=c.length;a.length1+=
c.length+d.length;a.length2+=c.length+d.length}};
diff_match_patch.prototype.patch_make=function(a,b,c){var d;if("string"==typeof a&&"string"==typeof b&&"undefined"==typeof c)d=a,b=this.diff_main(d,b,!0),2<b.length&&(this.diff_cleanupSemantic(b),this.diff_cleanupEfficiency(b));else if(a&&"object"==typeof a&&"undefined"==typeof b&&"undefined"==typeof c)b=a,d=this.diff_text1(b);else if("string"==typeof a&&b&&"object"==typeof b&&"undefined"==typeof c)d=a;else if("string"==typeof a&&"string"==typeof b&&c&&"object"==typeof c)d=a,b=c;else throw Error("Unknown call format to patch_make.");
if(0===b.length)return[];for(var c=[],a=new diff_match_patch.patch_obj,e=0,f=0,g=0,h=d,j=0;j<b.length;j++){var i=b[j][0],k=b[j][1];if(!e&&0!==i)a.start1=f,a.start2=g;switch(i){case 1:a.diffs[e++]=b[j];a.length2+=k.length;d=d.substring(0,g)+k+d.substring(g);break;case -1:a.length1+=k.length;a.diffs[e++]=b[j];d=d.substring(0,g)+d.substring(g+k.length);break;case 0:k.length<=2*this.Patch_Margin&&e&&b.length!=j+1?(a.diffs[e++]=b[j],a.length1+=k.length,a.length2+=k.length):k.length>=2*this.Patch_Margin&&
e&&(this.patch_addContext_(a,h),c.push(a),a=new diff_match_patch.patch_obj,e=0,h=d,f=g)}1!==i&&(f+=k.length);-1!==i&&(g+=k.length)}e&&(this.patch_addContext_(a,h),c.push(a));return c};diff_match_patch.prototype.patch_deepCopy=function(a){for(var b=[],c=0;c<a.length;c++){var d=a[c],e=new diff_match_patch.patch_obj;e.diffs=[];for(var f=0;f<d.diffs.length;f++)e.diffs[f]=d.diffs[f].slice();e.start1=d.start1;e.start2=d.start2;e.length1=d.length1;e.length2=d.length2;b[c]=e}return b};
diff_match_patch.prototype.patch_apply=function(a,b){if(0==a.length)return[b,[]];var a=this.patch_deepCopy(a),c=this.patch_addPadding(a),b=c+b+c;this.patch_splitMax(a);for(var d=0,e=[],f=0;f<a.length;f++){var g=a[f].start2+d,h=this.diff_text1(a[f].diffs),j,i=-1;if(h.length>this.Match_MaxBits){if(j=this.match_main(b,h.substring(0,this.Match_MaxBits),g),-1!=j&&(i=this.match_main(b,h.substring(h.length-this.Match_MaxBits),g+h.length-this.Match_MaxBits),-1==i||j>=i))j=-1}else j=this.match_main(b,h,g);
if(-1==j)e[f]=!1,d-=a[f].length2-a[f].length1;else if(e[f]=!0,d=j-g,g=-1==i?b.substring(j,j+h.length):b.substring(j,i+this.Match_MaxBits),h==g)b=b.substring(0,j)+this.diff_text2(a[f].diffs)+b.substring(j+h.length);else if(g=this.diff_main(h,g,!1),h.length>this.Match_MaxBits&&this.diff_levenshtein(g)/h.length>this.Patch_DeleteThreshold)e[f]=!1;else{this.diff_cleanupSemanticLossless(g);for(var h=0,k,i=0;i<a[f].diffs.length;i++){var p=a[f].diffs[i];0!==p[0]&&(k=this.diff_xIndex(g,h));1===p[0]?b=b.substring(0,
j+k)+p[1]+b.substring(j+k):-1===p[0]&&(b=b.substring(0,j+k)+b.substring(j+this.diff_xIndex(g,h+p[1].length)));-1!==p[0]&&(h+=p[1].length)}}}b=b.substring(c.length,b.length-c.length);return[b,e]};
diff_match_patch.prototype.patch_addPadding=function(a){for(var b=this.Patch_Margin,c="",d=1;d<=b;d++)c+=String.fromCharCode(d);for(d=0;d<a.length;d++)a[d].start1+=b,a[d].start2+=b;var d=a[0],e=d.diffs;if(0==e.length||0!=e[0][0])e.unshift([0,c]),d.start1-=b,d.start2-=b,d.length1+=b,d.length2+=b;else if(b>e[0][1].length){var f=b-e[0][1].length;e[0][1]=c.substring(e[0][1].length)+e[0][1];d.start1-=f;d.start2-=f;d.length1+=f;d.length2+=f}d=a[a.length-1];e=d.diffs;0==e.length||0!=e[e.length-1][0]?(e.push([0,
c]),d.length1+=b,d.length2+=b):b>e[e.length-1][1].length&&(f=b-e[e.length-1][1].length,e[e.length-1][1]+=c.substring(0,f),d.length1+=f,d.length2+=f);return c};
diff_match_patch.prototype.patch_splitMax=function(a){for(var b=this.Match_MaxBits,c=0;c<a.length;c++)if(!(a[c].length1<=b)){var d=a[c];a.splice(c--,1);for(var e=d.start1,f=d.start2,g="";0!==d.diffs.length;){var h=new diff_match_patch.patch_obj,j=!0;h.start1=e-g.length;h.start2=f-g.length;if(""!==g)h.length1=h.length2=g.length,h.diffs.push([0,g]);for(;0!==d.diffs.length&&h.length1<b-this.Patch_Margin;){var g=d.diffs[0][0],i=d.diffs[0][1];1===g?(h.length2+=i.length,f+=i.length,h.diffs.push(d.diffs.shift()),
j=!1):-1===g&&1==h.diffs.length&&0==h.diffs[0][0]&&i.length>2*b?(h.length1+=i.length,e+=i.length,j=!1,h.diffs.push([g,i]),d.diffs.shift()):(i=i.substring(0,b-h.length1-this.Patch_Margin),h.length1+=i.length,e+=i.length,0===g?(h.length2+=i.length,f+=i.length):j=!1,h.diffs.push([g,i]),i==d.diffs[0][1]?d.diffs.shift():d.diffs[0][1]=d.diffs[0][1].substring(i.length))}g=this.diff_text2(h.diffs);g=g.substring(g.length-this.Patch_Margin);i=this.diff_text1(d.diffs).substring(0,this.Patch_Margin);""!==i&&
(h.length1+=i.length,h.length2+=i.length,0!==h.diffs.length&&0===h.diffs[h.diffs.length-1][0]?h.diffs[h.diffs.length-1][1]+=i:h.diffs.push([0,i]));j||a.splice(++c,0,h)}}};diff_match_patch.prototype.patch_toText=function(a){for(var b=[],c=0;c<a.length;c++)b[c]=a[c];return b.join("")};
diff_match_patch.prototype.patch_fromText=function(a){var b=[];if(!a)return b;for(var a=a.split("\n"),c=0,d=/^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;c<a.length;){var e=a[c].match(d);if(!e)throw Error("Invalid patch string: "+a[c]);var f=new diff_match_patch.patch_obj;b.push(f);f.start1=parseInt(e[1],10);""===e[2]?(f.start1--,f.length1=1):"0"==e[2]?f.length1=0:(f.start1--,f.length1=parseInt(e[2],10));f.start2=parseInt(e[3],10);""===e[4]?(f.start2--,f.length2=1):"0"==e[4]?f.length2=0:(f.start2--,f.length2=
parseInt(e[4],10));for(c++;c<a.length;){e=a[c].charAt(0);try{var g=decodeURI(a[c].substring(1))}catch(h){throw Error("Illegal escape in patch_fromText: "+g);}if("-"==e)f.diffs.push([-1,g]);else if("+"==e)f.diffs.push([1,g]);else if(" "==e)f.diffs.push([0,g]);else if("@"==e)break;else if(""!==e)throw Error('Invalid patch mode "'+e+'" in: '+g);c++}}return b};diff_match_patch.patch_obj=function(){this.diffs=[];this.start2=this.start1=null;this.length2=this.length1=0};
diff_match_patch.patch_obj.prototype.toString=function(){var a,b;a=0===this.length1?this.start1+",0":1==this.length1?this.start1+1:this.start1+1+","+this.length1;b=0===this.length2?this.start2+",0":1==this.length2?this.start2+1:this.start2+1+","+this.length2;a=["@@ -"+a+" +"+b+" @@\n"];var c;for(b=0;b<this.diffs.length;b++){switch(this.diffs[b][0]){case 1:c="+";break;case -1:c="-";break;case 0:c=" "}a[b+1]=c+encodeURI(this.diffs[b][1])+"\n"}return a.join("").replace(/%20/g," ")};
this.diff_match_patch=diff_match_patch;this.DIFF_DELETE=-1;this.DIFF_INSERT=1;this.DIFF_EQUAL=0;})()
;
define("external/diff-match-patch/diff_match_patch", (function (global) {
    return function () {
        return global.diff_match_patch;
    }
}(this)));



/*global diff_match_patch:true, DIFF_INSERT:true, DIFF_DELETE:true, DIFF_EQUAL:true */
/*jshint newcap:false */

define('src/diff',['external/diff-match-patch/diff_match_patch'], function (diff_match_patch) {
	var dmp = new diff_match_patch();

	dmp.Diff_Timeout = 0.003; // Very low, increase if too inaccurate.
	                          // Unfortunately I couldn't find a way
	                          // to do this which was determinitic,
	                          // this method could produce different
	                          // results depending on the machine speed.
	
	/**
	 * Modified version of the diff-match-patch function which
	 * doesn't escape the original HTML tags
	 * (There's a risk now of mangling the tags, but it's a risk I'm willing to take)
	 *  
	 * Convert a diff array into a pretty HTML report.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @return {string} HTML representation.
	 */
	var prettyHtml = function (diffs) {
		var html = [];
		var pattern_amp = /&/g;
		var pattern_lt = /</g;
		var pattern_gt = />/g;
		var pattern_para = /\n/g;
		var x = 0;

		for (x = 0; x < diffs.length; x++) {
			var op = diffs[x][0];    // Operation (insert, delete, equal)
			var data = diffs[x][1];  // Text of change.
			var text = data;//.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;').replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
			switch (op) {
			case DIFF_INSERT:
				html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
				break;
			case DIFF_DELETE:
				html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
				break;
			case DIFF_EQUAL:
				html[x] = '<span>' + text + '</span>';
				break;
			}
		}
		return html.join('');
	};

	var prettyHtmlDiff = function (oldString, newString) {
		var diffs = dmp.diff_main(oldString, newString);
		dmp.diff_cleanupSemantic(diffs);
		return prettyHtml(diffs);
	};

	var customEditDistance = function (oldString, newString) {
		var diffs;
		console.time("diffs");
		diffs = dmp.diff_main(oldString, newString);
		console.timeEnd("diffs");
		return dmp.diff_levenshtein(diffs);
	};

	// human friendly value from 0 to 100 to use as a match percentage
	var matchQuality = function (oldString, newString) {
		var editDistance = customEditDistance(oldString, newString),
			matchQuality = Math.max(0, Math.floor(100 * (1.0 - editDistance /
				Math.max(oldString.length, newString.length))));

		return matchQuality;
	};

	/**
	 * Like levenshtein but gives much more weight to deletions.
	 * 
	 * Generally when searching you want everything you've typed to appear
	 * in the results.
	 *
	 * Note: no longer using this
	 */
	var weightedLevenshtein = function (diffs) {
		var levenshtein = 0;
		var insertions = 0;
		var deletions = 0;

		var deletionWeight = 5;

		for (var x = 0; x < diffs.length; x++) {
			var op = diffs[x][0];
			var data = diffs[x][1];
			switch (op) {
			case DIFF_INSERT:
				insertions += data.length;
				break;
			case DIFF_DELETE:
				deletions += data.length;
				break;
			case DIFF_EQUAL:
				// A deletion and an insertion is one substitution.
				levenshtein += Math.max(insertions, deletions * deletionWeight);
				insertions = 0;
				deletions = 0;
				break;
			}
		}
		levenshtein += Math.max(insertions, deletions * deletionWeight);
		return levenshtein;
	};

	return {
		prettyHtml : prettyHtml,
		prettyHtmlDiff : prettyHtmlDiff,
		customEditDistance : customEditDistance,
		matchQuality : matchQuality,
		weightedLevenshtein : weightedLevenshtein
	};
});

/*
 * Copyright (c) 2009, 2010 and 2011 Frank G. Bennett, Jr. All Rights
 * Reserved.
 *
 * The contents of this file are subject to the Common Public
 * Attribution License Version 1.0 (the “License”); you may not use
 * this file except in compliance with the License. You may obtain a
 * copy of the License at:
 *
 * http://bitbucket.org/fbennett/citeproc-js/src/tip/LICENSE.
 *
 * The License is based on the Mozilla Public License Version 1.1 but
 * Sections 14 and 15 have been added to cover use of software over a
 * computer network and provide for limited attribution for the
 * Original Developer. In addition, Exhibit A has been modified to be
 * consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an “AS IS”
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the citation formatting software known as
 * "citeproc-js" (an implementation of the Citation Style Language
 * [CSL]), including the original test fixtures and software located
 * under the ./std subdirectory of the distribution archive.
 *
 * The Original Developer is not the Initial Developer and is
 * __________. If left blank, the Original Developer is the Initial
 * Developer.
 *
 * The Initial Developer of the Original Code is Frank G. Bennett,
 * Jr. All portions of the code written by Frank G. Bennett, Jr. are
 * Copyright (c) 2009, 2010 and 2011 Frank G. Bennett, Jr. All Rights Reserved.
 *
 * Alternatively, the contents of this file may be used under the
 * terms of the GNU Affero General Public License (the [AGPLv3]
 * License), in which case the provisions of [AGPLv3] License are
 * applicable instead of those above. If you wish to allow use of your
 * version of this file only under the terms of the [AGPLv3] License
 * and not to allow others to use your version of this file under the
 * CPAL, indicate your decision by deleting the provisions above and
 * replace them with the notice and other provisions required by the
 * [AGPLv3] License. If you do not delete the provisions above, a
 * recipient may use your version of this file under either the CPAL
 * or the [AGPLv3] License.”
 */
var CSL_IS_IE;
var CSL_CHROME = function () {
    if ("undefined" == typeof DOMParser || CSL_IS_IE) {
        CSL_IS_IE = true;
        DOMParser = function() {};
        DOMParser.prototype.parseFromString = function(str, contentType) {
            if ("undefined" != typeof ActiveXObject) {
                var xmldata = new ActiveXObject('MSXML.DomDocument');
                xmldata.async = false;
                xmldata.loadXML(str);
                return xmldata;
            } else if ("undefined" != typeof XMLHttpRequest) {
                var xmldata = new XMLHttpRequest;
                if (!contentType) {
                    contentType = 'text/xml';
                }
                xmldata.open('GET', 'data:' + contentType + ';charset=utf-8,' + encodeURIComponent(str), false);
                if(xmldata.overrideMimeType) {
                    xmldata.overrideMimeType(contentType);
                }
                xmldata.send(null);
                return xmldata.responseXML;
            }
        };
        this.hasAttributes = function (node) {
            var ret;
            if (node.attributes && node.attributes.length) {
                ret = true;
            } else {
                ret = false;
            }
            return ret;
        };
    } else {
        this.hasAttributes = function (node) {
            var ret;
            if (node.attributes && node.attributes.length) {
                ret = true;
            } else {
                ret = false;
            }
            return ret;
        };
    }
    this.importNode = function (doc, srcElement) {
        if ("undefined" == typeof doc.importNode) {
            var ret = this._importNode(doc, srcElement, true);
        } else {
            var ret = doc.importNode(srcElement, true);
        }
        return ret;
    };
    this._importNode = function(doc, node, allChildren) {
        switch (node.nodeType) {
            case 1:
                var newNode = doc.createElement(node.nodeName);
                if (node.attributes && node.attributes.length > 0)
                    for (var i = 0, il = node.attributes.length; i < il;)
                        newNode.setAttribute(node.attributes[i].nodeName, node.getAttribute(node.attributes[i++].nodeName));
                    if (allChildren && node.childNodes && node.childNodes.length > 0)
                        for (var i = 0, il = node.childNodes.length; i < il;)
                            newNode.appendChild(this._importNode(doc, node.childNodes[i++], allChildren));
                return newNode;
                break;
            case 3:
            case 4:
            case 8:
        }
    };
    this.parser = new DOMParser();
    var str = "<docco><institution institution-parts=\"long\" delimiter=\", \" substitute-use-first=\"1\" use-last=\"1\"><institution-part name=\"long\"/></institution></docco>";
    var inst_doc = this.parser.parseFromString(str, "text/xml");
    var inst_node = inst_doc.getElementsByTagName("institution");
    this.institution = inst_node.item(0);
    var inst_part_node = inst_doc.getElementsByTagName("institution-part");
    this.institutionpart = inst_part_node.item(0);
    this.ns = "http://purl.org/net/xbiblio/csl";
};
CSL_CHROME.prototype.clean = function (xml) {
    xml = xml.replace(/<\?[^?]+\?>/g, "");
    xml = xml.replace(/<![^>]+>/g, "");
    xml = xml.replace(/^\s+/, "");
    xml = xml.replace(/\s+$/, "");
    xml = xml.replace(/^\n*/, "");
    return xml;
};
CSL_CHROME.prototype.getStyleId = function (myxml) {
    var text = "";
    var node = myxml.getElementsByTagName("id");
    if (node && node.length) {
        node = node.item(0);
    }
    if (node) {
        text = node.textContent;
    }
    if (!text) {
        text = node.innerText;
    }
    if (!text) {
        text = node.innerHTML;
    }
    return text;
};
CSL_CHROME.prototype.children = function (myxml) {
    var children, pos, len, ret;
    if (myxml) {
        ret = [];
        children = myxml.childNodes;
        for (pos = 0, len = children.length; pos < len; pos += 1) {
            if (children[pos].nodeName != "#text") {
                ret.push(children[pos]);
            }
        }
        return ret;
    } else {
        return [];
    }
};
CSL_CHROME.prototype.nodename = function (myxml) {
    var ret = myxml.nodeName;
    return ret;
};
CSL_CHROME.prototype.attributes = function (myxml) {
    var ret, attrs, attr, key, xml, pos, len;
    ret = new Object();
    if (myxml && this.hasAttributes(myxml)) {
        attrs = myxml.attributes;
        for (pos = 0, len=attrs.length; pos < len; pos += 1) {
            attr = attrs[pos];
            ret["@" + attr.name] = attr.value;
        }
    }
    return ret;
};
CSL_CHROME.prototype.content = function (myxml) {
    var ret;
    if ("undefined" != typeof myxml.textContent) {
        ret = myxml.textContent;
    } else if ("undefined" != typeof myxml.innerText) {
        ret = myxml.innerText;
    } else {
        ret = myxml.txt;
    }
    return ret;
};
CSL_CHROME.prototype.namespace = {
    "xml":"http://www.w3.org/XML/1998/namespace"
}
CSL_CHROME.prototype.numberofnodes = function (myxml) {
    if (myxml) {
        return myxml.length;
    } else {
        return 0;
    }
};
CSL_CHROME.prototype.getAttributeName = function (attr) {
    var ret = attr.name;
    return ret;
}
CSL_CHROME.prototype.getAttributeValue = function (myxml,name,namespace) {
    var ret = "";
    if (myxml && this.hasAttributes(myxml) && myxml.getAttribute(name)) {
        ret = myxml.getAttribute(name);
    }
    return ret;
}
CSL_CHROME.prototype.getNodeValue = function (myxml,name) {
    var ret = "";
    if (name){
        var vals = myxml.getElementsByTagName(name);
        if (vals.length > 0) {
            if ("undefined" != typeof vals[0].textContent) {
                ret = vals[0].textContent;
            } else if ("undefined" != typeof vals[0].innerText) {
                ret = vals[0].innerText;
            } else {
                ret = vals[0].text;
            }
        }
    } else {
        ret = myxml;
    }
    if (ret && ret.childNodes && (ret.childNodes.length == 0 || (ret.childNodes.length == 1 && ret.firstChild.nodeName == "#text"))) {
        if ("undefined" != typeof ret.textContent) {
            ret = ret.textContent;
        } else if ("undefined" != typeof ret.innerText) {
            ret = ret.innerText;
        } else {
            ret = ret.text;
        }
    }
    return ret;
}
CSL_CHROME.prototype.setAttributeOnNodeIdentifiedByNameAttribute = function (myxml,nodename,partname,attrname,val) {
    var pos, len, xml, nodes, node;
    if (attrname.slice(0,1) === '@'){
        attrname = attrname.slice(1);
    }
    nodes = myxml.getElementsByTagName(nodename);
    for (pos = 0, len = nodes.length; pos < len; pos += 1) {
        node = nodes[pos];
        if (node.getAttribute("name") != partname) {
            continue;
        }
        node.setAttribute(attrname, val);
    }
}
CSL_CHROME.prototype.deleteNodeByNameAttribute = function (myxml,val) {
    var pos, len, node, nodes;
    nodes = myxml.childNodes;
    for (pos = 0, len = nodes.length; pos < len; pos += 1) {
        node = nodes[pos];
        if (!node || node.nodeType == node.TEXT_NODE) {
            continue;
        }
        if (this.hasAttributes(node) && node.getAttribute("name") == val) {
            myxml.removeChild(nodes[pos]);
        }
    }
}
CSL_CHROME.prototype.deleteAttribute = function (myxml,attr) {
    myxml.removeAttribute(attr);
}
CSL_CHROME.prototype.setAttribute = function (myxml,attr,val) {
    var attribute;
    if (!myxml.ownerDocument) {
        myxml = myxml.firstChild;
    }
    attribute = myxml.ownerDocument.createAttribute(attr);
    myxml.setAttribute(attr, val);
    return false;
}
CSL_CHROME.prototype.nodeCopy = function (myxml) {
    var cloned_node = myxml.cloneNode(true);
    return cloned_node;
}
CSL_CHROME.prototype.getNodesByName = function (myxml,name,nameattrval) {
    var ret, nodes, node, pos, len;
    ret = [];
    nodes = myxml.getElementsByTagName(name);
    for (pos = 0, len = nodes.length; pos < len; pos += 1) {
        node = nodes.item(pos);
        if (nameattrval && !(this.hasAttributes(node) && node.getAttribute("name") == nameattrval)) {
            continue;
        }
        ret.push(node);
    }
    return ret;
}
CSL_CHROME.prototype.nodeNameIs = function (myxml,name) {
    if (name == myxml.nodeName) {
        return true;
    }
    return false;
}
CSL_CHROME.prototype.makeXml = function (myxml) {
    var ret, topnode;
    if (!myxml) {
        myxml = "<docco><bogus/></docco>";
    }
    myxml = myxml.replace(/\s*<\?[^>]*\?>\s*\n*/g, "");
    var nodetree = this.parser.parseFromString(myxml, "application/xml");
    return nodetree.firstChild;
};
CSL_CHROME.prototype.insertChildNodeAfter = function (parent,node,pos,datexml) {
    var myxml, xml;
    myxml = this.importNode(node.ownerDocument, datexml);
    parent.replaceChild(myxml, node);
     return parent;
};
CSL_CHROME.prototype.insertPublisherAndPlace = function(myxml) {
    var group = myxml.getElementsByTagName("group");
    for (var i = 0, ilen = group.length; i < ilen; i += 1) {
        var node = group.item(i);
        var skippers = [];
        for (var j = 0, jlen = node.childNodes.length; j < jlen; j += 1) {
            if (node.childNodes.item(j).nodeType !== 1) {
                skippers.push(j);
            }
        }
        if (node.childNodes.length - skippers.length === 2) {
            var twovars = [];
            for (var j = 0, jlen = 2; j < jlen; j += 1) {
                if (skippers.indexOf(j) > -1) {
                    continue;
                }
                var child = node.childNodes.item(j);                    
                var subskippers = [];
                for (var k = 0, klen = child.childNodes.length; k < klen; k += 1) {
                    if (child.childNodes.item(k).nodeType !== 1) {
                        subskippers.push(k);
                    }
                }
                if (child.childNodes.length - subskippers.length === 0) {
                    twovars.push(child.getAttribute('variable'));
                    if (child.getAttribute('suffix')
                        || child.getAttribute('prefix')) {
                        twovars = [];
                        break;
                    }
                }
            }
            if (twovars.indexOf("publisher") > -1 && twovars.indexOf("publisher-place") > -1) {
                node.setAttribute('has-publisher-and-publisher-place', true);
            }
        }
    }
};
CSL_CHROME.prototype.addMissingNameNodes = function(myxml) {
    var nameslist = myxml.getElementsByTagName("names");
    for (var i = 0, ilen = nameslist.length; i < ilen; i += 1) {
        var names = nameslist.item(i);
        var namelist = names.getElementsByTagName("name");
        if ((!namelist || namelist.length === 0)
            && names.parentNode.tagName.toLowerCase() !== "substitute") {
            var doc = names.ownerDocument;
            var name = doc.createElement("name");
            names.appendChild(name);
        }
    }
};
CSL_CHROME.prototype.addInstitutionNodes = function(myxml) {
    var names, thenames, institution, theinstitution, name, thename, xml, pos, len;
    names = myxml.getElementsByTagName("names");
    for (pos = 0, len = names.length; pos < len; pos += 1) {
        thenames = names.item(pos);
        name = thenames.getElementsByTagName("name");
        if (name.length == 0) {
            continue;
        }
        institution = thenames.getElementsByTagName("institution");
        if (institution.length == 0) {
            theinstitution = this.importNode(myxml.ownerDocument, this.institution);
            theinstitutionpart = theinstitution.getElementsByTagName("institution-part").item(0);
            thename = name.item(0);
            thenames.insertBefore(theinstitution, thename.nextSibling);
            for (var j = 0, jlen = CSL.INSTITUTION_KEYS.length; j < jlen; j += 1) {
                var attrname = CSL.INSTITUTION_KEYS[j];
                var attrval = thename.getAttribute(attrname);
                if (attrval) {
                    theinstitutionpart.setAttribute(attrname, attrval);
                }
            }
            var nameparts = thename.getElementsByTagName("name-part");
            for (var j = 0, jlen = nameparts.length; j < jlen; j += 1) {
                if ('family' === nameparts[j].getAttribute('name')) {
                    for (var k = 0, klen = CSL.INSTITUTION_KEYS.length; k < klen; k += 1) {
                        var attrname = CSL.INSTITUTION_KEYS[k];
                        var attrval = nameparts[j].getAttribute(attrname);
                        if (attrval) {
                            theinstitutionpart.setAttribute(attrname, attrval);
                        }
                    }
                }
            }
        }
    }
};
CSL_CHROME.prototype.flagDateMacros = function(myxml) {
    var pos, len, thenode, thedate;
    nodes = myxml.getElementsByTagName("macro");
    for (pos = 0, len = nodes.length; pos < len; pos += 1) {
        thenode = nodes.item(pos);
        thedate = thenode.getElementsByTagName("date");
        if (thedate.length) {
            thenode.setAttribute('macro-has-date', 'true');
        }
    }
};

this.CSL_CHROME = CSL_CHROME;

define("external/citeproc/xmldom", (function (global) {
    return function () {
        return global.CSL_CHROME;
    }
}(this)));



define('src/citeprocLoadSys',[	'src/options',
			'src/debug'
		],
		function (
			CSLEDIT_options,
			debug
		) {

	var Sys = function () {
		this.locale = {}; // lazily fetched from server
		this.abbreviations = {}; // no journal abbreviations at the moment
								// see demo/loadabbres.js in citeproc-js repo for an example
	};

	Sys.prototype.retrieveLocale = function (lang) {
		var that = this,
			locale = this.locale[lang],
			localePath;

		if (typeof(locale) === "undefined") {
			localePath = CSLEDIT_options.getUrl("external/locales/locales-" + lang + ".xml");

			// try to fetch from server
			$.ajax({
				url : localePath,
				success : function (data) {
					debug.log("fetched locale data for " + lang);
					that.locale[lang] = data;
					locale = data;
				},
				error : function (jqXHR, textStatus) {
					debug.log("ERROR retrieving locale data for " + lang);
					debug.log("Falling back to en-US");

					locale = that.retrieveLocale("en-US");
				},
				dataType : "text",
				async : false
			});
		}
		
		return locale;
	};

	Sys.prototype.setAbbreviations = function (abbreviations) {
		this.abbreviations = abbreviations;
	};

	Sys.prototype.setJsonDocuments = function (jsonDocuments) {
		this.jsonDocuments = jsonDocuments;
	};

	Sys.prototype.retrieveItem = function (id) {
		return this.jsonDocuments[id];
	};

	Sys.prototype.getAbbreviations = function (name, vartype) {
		return this.abbreviations[name][vartype];
	};

	return new Sys();
});

/*
 * Copyright (c) 2009, 2010 and 2011 Frank G. Bennett, Jr. All Rights
 * Reserved.
 *
 * The contents of this file are subject to the Common Public
 * Attribution License Version 1.0 (the “License”); you may not use
 * this file except in compliance with the License. You may obtain a
 * copy of the License at:
 *
 * http://bitbucket.org/fbennett/citeproc-js/src/tip/LICENSE.
 *
 * The License is based on the Mozilla Public License Version 1.1 but
 * Sections 14 and 15 have been added to cover use of software over a
 * computer network and provide for limited attribution for the
 * Original Developer. In addition, Exhibit A has been modified to be
 * consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an “AS IS”
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the citation formatting software known as
 * "citeproc-js" (an implementation of the Citation Style Language
 * [CSL]), including the original test fixtures and software located
 * under the ./std subdirectory of the distribution archive.
 *
 * The Original Developer is not the Initial Developer and is
 * __________. If left blank, the Original Developer is the Initial
 * Developer.
 *
 * The Initial Developer of the Original Code is Frank G. Bennett,
 * Jr. All portions of the code written by Frank G. Bennett, Jr. are
 * Copyright (c) 2009, 2010 and 2011 Frank G. Bennett, Jr. All Rights Reserved.
 *
 * Alternatively, the contents of this file may be used under the
 * terms of the GNU Affero General Public License (the [AGPLv3]
 * License), in which case the provisions of [AGPLv3] License are
 * applicable instead of those above. If you wish to allow use of your
 * version of this file only under the terms of the [AGPLv3] License
 * and not to allow others to use your version of this file under the
 * CPAL, indicate your decision by deleting the provisions above and
 * replace them with the notice and other provisions required by the
 * [AGPLv3] License. If you do not delete the provisions above, a
 * recipient may use your version of this file under either the CPAL
 * or the [AGPLv3] License.”
 */
if (!Array.indexOf) {
    Array.prototype.indexOf = function (obj) {
        var i, len;
        for (i = 0, len = this.length; i < len; i += 1) {
            if (this[i] === obj) {
                return i;
            }
        }
        return -1;
    };
}
var CSL = {
    STATUTE_SUBDIV_GROUPED_REGEX: /((?:^| )(?:art|ch|Ch|subch|p|pp|para|subpara|pt|r|sec|subsec|Sec|sch|tit)\.)/g,
    STATUTE_SUBDIV_PLAIN_REGEX: /(?:(?:^| )(?:art|ch|Ch|subch|p|pp|para|subpara|pt|r|sec|subsec|Sec|sch|tit)\.)/,
    STATUTE_SUBDIV_STRINGS: {
        "art.": "article",
        "ch.": "chapter",
        "Ch.": "Chapter",
        "subch.": "subchapter",
        "p.": "page",
        "pp.": "page",
        "para.": "paragraph",
        "subpara.": "subparagraph",
        "pt.": "part",
        "r.": "rule",
        "sec.": "section",
        "subsec.": "subsection",
        "Sec.": "Section",
        "sch.": "schedule",
        "tit.": "title"
    },
    STATUTE_SUBDIV_STRINGS_REVERSE: {
        "article": "art.",
        "chapter": "ch.",
        "Chapter": "Ch.",
        "subchapter": "subch.",
        //"page": "p.",
        "page": "pp.",
        "paragraph": "para.",
        "subparagraph": "subpara.",
        "part": "pt.",
        "rule": "r.",
        "section": "sec.",
        "subsection": "subsec.",
        "Section": "Sec.",
        "schedule": "sch.",
        "title": "tit."
    },
    NestedBraces: [
        ["(", "["],
        [")", "]"]
    ],
    checkNestedBraceOpen: new RegExp(".*\\("),
    checkNestedBraceClose: new RegExp(".*\\)"),
    LangPrefsMap: {
        "title":"titles",
        "title-short":"titles",
        "container-title":"titles",
        "collection-title":"titles",
        "publisher":"publishers",
        "authority":"publishers",
        "publisher-place": "places",
        "event-place": "places"
    },
    AbbreviationSegments: function () {
        this["container-title"] = {};
        this["collection-title"] = {};
        this["institution-entire"] = {};
        this["institution-part"] = {};
        this["nickname"] = {};
        this["number"] = {};
        this["title"] = {};
        this["place"] = {};
        this["hereinafter"] = {};
        this["classic"] = {};
        this["container-phrase"] = {};
        this["title-phrase"] = {};
    },
    GENDERS: ["masculine", "feminine"],
    ERROR_NO_RENDERED_FORM: 1,
    PREVIEW: "Just for laughs.",
    ASSUME_ALL_ITEMS_REGISTERED: 2,
    START: 0,
    END: 1,
    SINGLETON: 2,
    SEEN: 6,
    SUCCESSOR: 3,
    SUCCESSOR_OF_SUCCESSOR: 4,
    SUPPRESS: 5,
    SINGULAR: 0,
    PLURAL: 1,
    LITERAL: true,
    BEFORE: 1,
    AFTER: 2,
    DESCENDING: 1,
    ASCENDING: 2,
    ONLY_FIRST: 1,
    ALWAYS: 2,
    ONLY_LAST: 3,
    FINISH: 1,
    POSITION_FIRST: 0,
    POSITION_SUBSEQUENT: 1,
    POSITION_IBID: 2,
    POSITION_IBID_WITH_LOCATOR: 3,
    MARK_TRAILING_NAMES: true,
    POSITION_TEST_VARS: ["position", "first-reference-note-number", "near-note"],
    AREAS: ["citation", "citation_sort", "bibliography", "bibliography_sort"],
    MULTI_FIELDS: ["event", "publisher", "publisher-place", "event-place", "title", "container-title", "collection-title", "authority","edition","genre","title-short","medium","jurisdiction"],
    CITE_FIELDS: ["first-reference-note-number", "locator", "locator-revision"],
    MINIMAL_NAME_FIELDS: ["literal", "family"],
    SWAPPING_PUNCTUATION: [".", "!", "?", ":",","],
    TERMINAL_PUNCTUATION: [":", ".", ";", "!", "?", " "],
    NONE: 0,
    NUMERIC: 1,
    POSITION: 2,
    COLLAPSE_VALUES: ["citation-number", "year", "year-suffix"],
    DATE_PARTS: ["year", "month", "day"],
    DATE_PARTS_ALL: ["year", "month", "day", "season"],
    DATE_PARTS_INTERNAL: ["year", "month", "day", "year_end", "month_end", "day_end"],
    NAME_PARTS: ["family", "given", "dropping-particle", "non-dropping-particle", "suffix", "literal"],
    DECORABLE_NAME_PARTS: ["given", "family", "suffix"],
    DISAMBIGUATE_OPTIONS: [
        "disambiguate-add-names",
        "disambiguate-add-givenname",
        "disambiguate-add-year-suffix"
    ],
    GIVENNAME_DISAMBIGUATION_RULES: [
        "all-names",
        "all-names-with-initials",
        "primary-name",
        "primary-name-with-initials",
        "by-cite"
    ],
    NAME_ATTRIBUTES: [
        "and",
        "delimiter-precedes-last",
        "delimiter-precedes-et-al",
        "initialize-with",
        "initialize",
        "name-as-sort-order",
        "sort-separator",
        "et-al-min",
        "et-al-use-first",
        "et-al-subsequent-min",
        "et-al-subsequent-use-first",
        "form",
        "prefix",
        "suffix",
        "delimiter"
    ],
    PARALLEL_MATCH_VARS: ["container-title"],
    PARALLEL_TYPES: ["bill","gazette","legislation","legal_case","treaty"],
    PARALLEL_COLLAPSING_MID_VARSET: ["volume", "issue", "container-title", "section", "collection-number"],
    LOOSE: 0,
    STRICT: 1,
    TOLERANT: 2,
    PREFIX_PUNCTUATION: /[.;:]\s*$/,
    SUFFIX_PUNCTUATION: /^\s*[.;:,\(\)]/,
    NUMBER_REGEXP: /(?:^\d+|\d+$)/,
    NAME_INITIAL_REGEXP: /^([A-Z\u0080-\u017f\u0400-\u042f\u0600-\u06ff])([a-zA-Z\u0080-\u017f\u0400-\u052f\u0600-\u06ff]*|)/,
    ROMANESQUE_REGEXP: /[a-zA-Z\u0080-\u017f\u0400-\u052f\u0386-\u03fb\u1f00-\u1ffe\u0600-\u06ff\u200c\u200d\u200e\u202a-\u202e]/,
    ROMANESQUE_NOT_REGEXP: /[^a-zA-Z\u0080-\u017f\u0400-\u052f\u0386-\u03fb\u1f00-\u1ffe\u0600-\u06ff\u200c\u200d\u200e\u202a-\u202e]/g,
    STARTSWITH_ROMANESQUE_REGEXP: /^[&a-zA-Z\u0080-\u017f\u0400-\u052f\u0386-\u03fb\u1f00-\u1ffe\u0600-\u06ff\u200c\u200d\u200e\u202a-\u202e]/,
    ENDSWITH_ROMANESQUE_REGEXP: /[.;:&a-zA-Z\u0080-\u017f\u0400-\u052f\u0386-\u03fb\u1f00-\u1ffe\u0600-\u06ff\u200c\u200d\u200e\u202a-\u202e]$/,
    ALL_ROMANESQUE_REGEXP: /^[a-zA-Z\u0080-\u017f\u0400-\u052f\u0386-\u03fb\u1f00-\u1ffe\u0600-\u06ff\u200c\u200d\u200e\u202a-\u202e]+$/,
    VIETNAMESE_SPECIALS: /[\u00c0-\u00c3\u00c8-\u00ca\u00cc\u00cd\u00d2-\u00d5\u00d9\u00da\u00dd\u00e0-\u00e3\u00e8-\u00ea\u00ec\u00ed\u00f2-\u00f5\u00f9\u00fa\u00fd\u0101\u0103\u0110\u0111\u0128\u0129\u0168\u0169\u01a0\u01a1\u01af\u01b0\u1ea0-\u1ef9]/,
    VIETNAMESE_NAMES: /^(?:(?:[.AaBbCcDdEeGgHhIiKkLlMmNnOoPpQqRrSsTtUuVvXxYy \u00c0-\u00c3\u00c8-\u00ca\u00cc\u00cd\u00d2-\u00d5\u00d9\u00da\u00dd\u00e0-\u00e3\u00e8-\u00ea\u00ec\u00ed\u00f2-\u00f5\u00f9\u00fa\u00fd\u0101\u0103\u0110\u0111\u0128\u0129\u0168\u0169\u01a0\u01a1\u01af\u01b0\u1ea0-\u1ef9]{2,6})(\s+|$))+$/,
    NOTE_FIELDS_REGEXP: /\{:[\-_a-z]+:[^\}]+\}/g,
    NOTE_FIELD_REGEXP: /\{:([\-_a-z]+):\s*([^\}]+)\}/,
    DISPLAY_CLASSES: ["block", "left-margin", "right-inline", "indent"],
    NAME_VARIABLES: [
        "author",
        "editor",
        "translator",
        "contributor",
        "collection-editor",
        "composer",
        "container-author",
        "director",
        "editorial-director",
        "interviewer",
        "original-author",
        "recipient"
    ],
    NUMERIC_VARIABLES: [
        "chapter-number",
        "collection-number",
        "edition",
        "issue",
        "locator",
        "number",
        "number-of-pages",
        "number-of-volumes",
        "volume",
        "citation-number"
    ],
    DATE_VARIABLES: ["locator-date", "issued", "event-date", "accessed", "container", "original-date"],
    TAG_ESCAPE: function (str) {
        var mx, lst, len, pos, m, buf1, buf2, idx, ret, myret;
        mx = str.match(/(\"|\'|<span\s+class=\"no(?:case|decor)\">.*?<\/span>|<\/?(?:i|sc|b)>|<\/span>)/g);
        lst = str.split(/(?:\"|\'|<span\s+class=\"no(?:case|decor)\">.*?<\/span>|<\/?(?:i|sc|b)>|<\/span>)/g);
        myret = [lst[0]];
        for (pos = 1, len = lst.length; pos < len; pos += 1) {
            myret.push(mx[pos - 1]);
            myret.push(lst[pos]);
        }
        lst = myret.slice();
        return lst;
    },
    TAG_USEALL: function (str) {
        var ret, open, close, end;
        ret = [""];
        open = str.indexOf("<");
        close = str.indexOf(">");
        while (open > -1 && close > -1) {
            if (open > close) {
                end = open + 1;
            } else {
                end = close + 1;
            }
            if (open < close && str.slice(open + 1, close).indexOf("<") === -1) {
                ret[ret.length - 1] += str.slice(0, open);
                ret.push(str.slice(open, close + 1));
                ret.push("");
                str = str.slice(end);
            } else {
                ret[ret.length - 1] += str.slice(0, close + 1);
                str = str.slice(end);
            }
            open = str.indexOf("<");
            close = str.indexOf(">");
        }
        ret[ret.length - 1] += str;
        return ret;
    },
    SKIP_WORDS: ["but", "or", "yet", "so", "for", "and", "nor", "a", "an", "the", "at", "by", "from", "in", "into", "of", "on", "to", "with", "up", "down", "as", "via", "onto", "over", "till"],
    FORMAT_KEY_SEQUENCE: [
        "@strip-periods",
        "@font-style",
        "@font-variant",
        "@font-weight",
        "@text-decoration",
        "@vertical-align",
        "@quotes"
    ],
    INSTITUTION_KEYS: [
        "font-style",
        "font-variant",
        "font-weight",
        "text-decoration",
        "text-case"
    ],
    SUFFIX_CHARS: "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z",
    ROMAN_NUMERALS: [
        [ "", "i", "ii", "iii", "iv", "v", "vi", "vii", "viii", "ix" ],
        [ "", "x", "xx", "xxx", "xl", "l", "lx", "lxx", "lxxx", "xc" ],
        [ "", "c", "cc", "ccc", "cd", "d", "dc", "dcc", "dccc", "cm" ],
        [ "", "m", "mm", "mmm", "mmmm", "mmmmm"]
    ],
    CREATORS: [
        "author",
        "editor",
        "contributor",
        "translator",
        "recipient",
        "interviewer",
        "composer",
        "original-author",
        "container-author",
        "collection-editor"
    ],
    LANG_BASES: {
        af: "af_ZA",
        ar: "ar_AR",
        bg: "bg_BG",
        ca: "ca_AD",
        cs: "cs_CZ",
        da: "da_DK",
        de: "de_DE",
        el: "el_GR",
        en: "en_US",
        es: "es_ES",
        et: "et_EE",
        eu: "eu",
        fa: "fa_IR",
        fi: "fi_FI",
        fr: "fr_FR",
        he: "he_IL",
        hu: "hu_HU",
        is: "is_IS",
        it: "it_IT",
        ja: "ja_JP",
        km: "km_KH",
        ko: "ko_KR",
        mn: "mn_MN",
        nb: "nb_NO",
        nl: "nl_NL",
        nn: "nn-NO",
        pl: "pl_PL",
        pt: "pt_PT",
        ro: "ro_RO",
        ru: "ru_RU",
        sk: "sk_SK",
        sl: "sl_SI",
        sr: "sr_RS",
        sv: "sv_SE",
        th: "th_TH",
        tr: "tr_TR",
        uk: "uk_UA",
        vi: "vi_VN",
        zh: "zh_CN"
    },
    SUPERSCRIPTS: {
        "\u00AA": "\u0061",
        "\u00B2": "\u0032",
        "\u00B3": "\u0033",
        "\u00B9": "\u0031",
        "\u00BA": "\u006F",
        "\u02B0": "\u0068",
        "\u02B1": "\u0266",
        "\u02B2": "\u006A",
        "\u02B3": "\u0072",
        "\u02B4": "\u0279",
        "\u02B5": "\u027B",
        "\u02B6": "\u0281",
        "\u02B7": "\u0077",
        "\u02B8": "\u0079",
        "\u02E0": "\u0263",
        "\u02E1": "\u006C",
        "\u02E2": "\u0073",
        "\u02E3": "\u0078",
        "\u02E4": "\u0295",
        "\u1D2C": "\u0041",
        "\u1D2D": "\u00C6",
        "\u1D2E": "\u0042",
        "\u1D30": "\u0044",
        "\u1D31": "\u0045",
        "\u1D32": "\u018E",
        "\u1D33": "\u0047",
        "\u1D34": "\u0048",
        "\u1D35": "\u0049",
        "\u1D36": "\u004A",
        "\u1D37": "\u004B",
        "\u1D38": "\u004C",
        "\u1D39": "\u004D",
        "\u1D3A": "\u004E",
        "\u1D3C": "\u004F",
        "\u1D3D": "\u0222",
        "\u1D3E": "\u0050",
        "\u1D3F": "\u0052",
        "\u1D40": "\u0054",
        "\u1D41": "\u0055",
        "\u1D42": "\u0057",
        "\u1D43": "\u0061",
        "\u1D44": "\u0250",
        "\u1D45": "\u0251",
        "\u1D46": "\u1D02",
        "\u1D47": "\u0062",
        "\u1D48": "\u0064",
        "\u1D49": "\u0065",
        "\u1D4A": "\u0259",
        "\u1D4B": "\u025B",
        "\u1D4C": "\u025C",
        "\u1D4D": "\u0067",
        "\u1D4F": "\u006B",
        "\u1D50": "\u006D",
        "\u1D51": "\u014B",
        "\u1D52": "\u006F",
        "\u1D53": "\u0254",
        "\u1D54": "\u1D16",
        "\u1D55": "\u1D17",
        "\u1D56": "\u0070",
        "\u1D57": "\u0074",
        "\u1D58": "\u0075",
        "\u1D59": "\u1D1D",
        "\u1D5A": "\u026F",
        "\u1D5B": "\u0076",
        "\u1D5C": "\u1D25",
        "\u1D5D": "\u03B2",
        "\u1D5E": "\u03B3",
        "\u1D5F": "\u03B4",
        "\u1D60": "\u03C6",
        "\u1D61": "\u03C7",
        "\u2070": "\u0030",
        "\u2071": "\u0069",
        "\u2074": "\u0034",
        "\u2075": "\u0035",
        "\u2076": "\u0036",
        "\u2077": "\u0037",
        "\u2078": "\u0038",
        "\u2079": "\u0039",
        "\u207A": "\u002B",
        "\u207B": "\u2212",
        "\u207C": "\u003D",
        "\u207D": "\u0028",
        "\u207E": "\u0029",
        "\u207F": "\u006E",
        "\u2120": "\u0053\u004D",
        "\u2122": "\u0054\u004D",
        "\u3192": "\u4E00",
        "\u3193": "\u4E8C",
        "\u3194": "\u4E09",
        "\u3195": "\u56DB",
        "\u3196": "\u4E0A",
        "\u3197": "\u4E2D",
        "\u3198": "\u4E0B",
        "\u3199": "\u7532",
        "\u319A": "\u4E59",
        "\u319B": "\u4E19",
        "\u319C": "\u4E01",
        "\u319D": "\u5929",
        "\u319E": "\u5730",
        "\u319F": "\u4EBA",
        "\u02C0": "\u0294",
        "\u02C1": "\u0295",
        "\u06E5": "\u0648",
        "\u06E6": "\u064A"
    },
    LOCATOR_LABELS_REGEXP: new RegExp("^((art|ch|Ch|subch|col|fig|l|n|no|op|p|pp|para|subpara|pt|r|sec|subsec|Sec|sv|sch|tit|vrs|vol)\\.)\\s+(.*)"),
    LOCATOR_LABELS_MAP: {
        "art": "article",
        "ch": "chapter",
        "Ch": "Chapter",
        "subch": "subchapter",
        "col": "column",
        "fig": "figure",
        "l": "line",
        "n": "note",
        "no": "issue",
        "op": "opus",
        "p": "page",
        "pp": "page",
        "para": "paragraph",
        "subpara": "subparagraph",
        "pt": "part",
        "r": "rule",
		"sec": "section",
		"subsec": "subsection",
        "Sec": "Section",
		"sv": "sub-verbo",
        "sch": "schedule",
        "tit": "title",
        "vrs": "verse",
        "vol": "volume"
    },
    SUPERSCRIPTS_REGEXP: new RegExp("[\u00AA\u00B2\u00B3\u00B9\u00BA\u02B0\u02B1\u02B2\u02B3\u02B4\u02B5\u02B6\u02B7\u02B8\u02E0\u02E1\u02E2\u02E3\u02E4\u1D2C\u1D2D\u1D2E\u1D30\u1D31\u1D32\u1D33\u1D34\u1D35\u1D36\u1D37\u1D38\u1D39\u1D3A\u1D3C\u1D3D\u1D3E\u1D3F\u1D40\u1D41\u1D42\u1D43\u1D44\u1D45\u1D46\u1D47\u1D48\u1D49\u1D4A\u1D4B\u1D4C\u1D4D\u1D4F\u1D50\u1D51\u1D52\u1D53\u1D54\u1D55\u1D56\u1D57\u1D58\u1D59\u1D5A\u1D5B\u1D5C\u1D5D\u1D5E\u1D5F\u1D60\u1D61\u2070\u2071\u2074\u2075\u2076\u2077\u2078\u2079\u207A\u207B\u207C\u207D\u207E\u207F\u2120\u2122\u3192\u3193\u3194\u3195\u3196\u3197\u3198\u3199\u319A\u319B\u319C\u319D\u319E\u319F\u02C0\u02C1\u06E5\u06E6]", "g"),
    locale: {},
    locale_opts: {},
    locale_dates: {}
};
if (typeof require !== "undefined" && typeof module !== 'undefined' && "exports" in module) {
    var CSL_IS_NODEJS = true;
    var CSL_NODEJS = require("./csl_nodejs_jsdom").CSL_NODEJS_JSDOM;
    exports.CSL = CSL;
}
CSL.TERMINAL_PUNCTUATION_REGEXP = new RegExp("^([" + CSL.TERMINAL_PUNCTUATION.slice(0, -1).join("") + "])(.*)");
CSL.CLOSURES = new RegExp(".*[\\]\\)]");
if ("object" === typeof console && "function" === typeof console.log) {
    CSL.debug = function (str) {
        console.log("CSL: " + str);
    };
    CSL.error = function (str) {
        console.log("CSL error: " + str);
    };
} else {
    CSL.debug = function () {};
    CSL.error = function (str) {
        throw "CSL error: " + str;
    };
}
CSL.getSortCompare = function () {
    var strcmp;
    try {
        var localeService = Components.classes["@mozilla.org/intl/nslocaleservice;1"]
            .getService(Components.interfaces.nsILocaleService);
        var collationFactory = Components.classes["@mozilla.org/intl/collation-factory;1"]
            .getService(Components.interfaces.nsICollationFactory);
        var collation = collationFactory.CreateCollation(localeService.getApplicationLocale());
        strcmp = function(a, b) {
            return collation.compareString(1, a, b);
        };
        CSL.debug("Using collation sort");
    } catch (e) {
        strcmp = function (a, b) {
            return a.localeCompare(b);
        };
    }
    var isKana = /^[\u3040-\u309f\u30a0-\u30ff]/;
    var sortCompare = function (a, b) {
        var ak = isKana.exec(a);
        var bk = isKana.exec(b);
        if (ak || bk) {
            if (!ak) {
                return -1;
            } else if (!bk) {
                return 1;
            } else if (a < b) {
                return -1;
            } else if (a > b) {
                return 1;
            } else {
                return 0;
            }
        } else {
            return strcmp(a, b);
        }
    };
    return sortCompare;
};
CSL.Output = {};
CSL.Output.Queue = function (state) {
    this.levelname = ["top"];
    this.state = state;
    this.queue = [];
    this.empty = new CSL.Token("empty");
    var tokenstore = {};
    tokenstore.empty = this.empty;
    this.formats = new CSL.Stack(tokenstore);
    this.current = new CSL.Stack(this.queue);
};
CSL.Output.Queue.prototype.pop = function () {
    var drip = this.current.value();
    if (drip.length) {
        return drip.pop();
    } else {
        return drip.blobs.pop();
    }
};
CSL.Output.Queue.prototype.getToken = function (name) {
    var ret = this.formats.value()[name];
    return ret;
};
CSL.Output.Queue.prototype.mergeTokenStrings = function (base, modifier) {
    var base_token, modifier_token, ret, key;
    base_token = this.formats.value()[base];
    modifier_token = this.formats.value()[modifier];
    ret = base_token;
    if (modifier_token) {
        if (!base_token) {
            base_token = new CSL.Token(base, CSL.SINGLETON);
            base_token.decorations = [];
        }
        ret = new CSL.Token(base, CSL.SINGLETON);
        key = "";
        for (key in base_token.strings) {
            if (base_token.strings.hasOwnProperty(key)) {
                ret.strings[key] = base_token.strings[key];
            }
        }
        for (key in modifier_token.strings) {
            if (modifier_token.strings.hasOwnProperty(key)) {
                ret.strings[key] = modifier_token.strings[key];
            }
        }
        ret.decorations = base_token.decorations.concat(modifier_token.decorations);
    }
    return ret;
};
CSL.Output.Queue.prototype.addToken = function (name, modifier, token) {
    var newtok, attr;
    newtok = new CSL.Token("output");
    if ("string" === typeof token) {
        token = this.formats.value()[token];
    }
    if (token && token.strings) {
        for (attr in token.strings) {
            if (token.strings.hasOwnProperty(attr)) {
                newtok.strings[attr] = token.strings[attr];
            }
        }
        newtok.decorations = token.decorations;
    }
    if ("string" === typeof modifier) {
        newtok.strings.delimiter = modifier;
    }
    this.formats.value()[name] = newtok;
};
CSL.Output.Queue.prototype.pushFormats = function (tokenstore) {
    if (!tokenstore) {
        tokenstore = {};
    }
    tokenstore.empty = this.empty;
    this.formats.push(tokenstore);
};
CSL.Output.Queue.prototype.popFormats = function (tokenstore) {
    this.formats.pop();
};
CSL.Output.Queue.prototype.startTag = function (name, token) {
    var tokenstore = {};
    if (this.state.tmp["doing-macro-with-date"] && this.state.tmp.extension) {
        token = this.empty;
        name = "empty";
    }
    tokenstore[name] = token;
    this.pushFormats(tokenstore);
    this.openLevel(name);
};
CSL.Output.Queue.prototype.endTag = function (name) {
    this.closeLevel();
    this.popFormats();
};
CSL.Output.Queue.prototype.openLevel = function (token, ephemeral) {
    var blob, curr, x, has_ephemeral;
    if ("object" === typeof token) {
        blob = new CSL.Blob(undefined, token);
    } else if ("undefined" === typeof token) {
        blob = new CSL.Blob(undefined, this.formats.value().empty, "empty");
    } else {
        if (!this.formats.value() || !this.formats.value()[token]) {
            throw "CSL processor error: call to nonexistent format token \"" + token + "\"";
        }
        blob = new CSL.Blob(undefined, this.formats.value()[token], token);
    }
    if (this.nestedBraces) {
        blob.strings.prefix = blob.strings.prefix.replace(this.nestedBraces[0][0], this.nestedBraces[0][1]);
        blob.strings.prefix = blob.strings.prefix.replace(this.nestedBraces[1][0], this.nestedBraces[1][1]);
        blob.strings.suffix = blob.strings.suffix.replace(this.nestedBraces[0][0], this.nestedBraces[0][1]);
        blob.strings.suffix = blob.strings.suffix.replace(this.nestedBraces[1][0], this.nestedBraces[1][1]);
    }
    curr = this.current.value();
    curr.push(blob);
    this.current.push(blob);
};
CSL.Output.Queue.prototype.closeLevel = function (name) {
    if (name && name !== this.current.value().levelname) {
        CSL.error("Level mismatch error:  wanted " + name + " but found " + this.current.value().levelname);
    }
    this.current.pop();
};
CSL.Output.Queue.prototype.append = function (str, tokname, notSerious, ignorePredecessor, noStripPeriods) {
    var token, blob, curr;
    var useblob = true;
    if (this.state.tmp["doing-macro-with-date"]) {
        if (tokname !== "macro-with-date") {
            return false;
        }
        if (tokname === "macro-with-date") {
            tokname = "empty";
        }
    }
    if ("undefined" === typeof str) {
        return false;
    }
    if ("number" === typeof str) {
        str = "" + str;
    }
    if (!notSerious 
        && this.state.tmp.element_trace 
        && this.state.tmp.element_trace.value() === "suppress-me") {
        return false;
    }
    blob = false;
    if (!tokname) {
        token = this.formats.value().empty;
    } else if (tokname === "literal") {
        token = true;
        useblob = false;
    } else if ("string" === typeof tokname) {
        token = this.formats.value()[tokname];
    } else {
        token = tokname;
    }
    if (!token) {
        throw "CSL processor error: unknown format token name: " + tokname;
    }
    if (token.strings && "undefined" === typeof token.strings.delimiter) {
        token.strings.delimiter = "";
    }
    if ("string" === typeof str && str.length) {
        str = str.replace(/ ([:;?!\u00bb])/g, "\u202f$1").replace(/\u00ab /g, "\u00ab\u202f");
        this.last_char_rendered = str.slice(-1);
        str = str.replace(/\s+'/g, "  \'").replace(/^'/g, " \'");
        if (!ignorePredecessor) {
            this.state.tmp.term_predecessor = true;
        }
    }
    blob = new CSL.Blob(str, token);
    if (this.nestedBraces) {
        blob.strings.prefix = blob.strings.prefix.replace(this.nestedBraces[0][0], this.nestedBraces[0][1]);
        blob.strings.prefix = blob.strings.prefix.replace(this.nestedBraces[1][0], this.nestedBraces[1][1]);
        blob.strings.suffix = blob.strings.suffix.replace(this.nestedBraces[0][0], this.nestedBraces[0][1]);
        blob.strings.suffix = blob.strings.suffix.replace(this.nestedBraces[1][0], this.nestedBraces[1][1]);
    }
    curr = this.current.value();
    if ("undefined" === typeof curr && this.current.mystack.length === 0) {
        this.current.mystack.push([]);
        curr = this.current.value();
    }
    if ("string" === typeof blob.blobs) {
        if (!ignorePredecessor) {
            this.state.tmp.term_predecessor = true;
        }
    }
    if (!notSerious) {
        this.state.parallel.AppendBlobPointer(curr);
    }
    if ("string" === typeof str) {
        curr.push(blob);
        if (blob.strings["text-case"]) {
            blob.blobs = CSL.Output.Formatters[blob.strings["text-case"]](this.state, str);
        }
        if (this.state.tmp.strip_periods && !noStripPeriods) {
            blob.blobs = blob.blobs.replace(/\.([^a-z]|$)/g, "$1");
        }
        this.state.fun.flipflopper.init(str, blob);
        this.state.fun.flipflopper.processTags();
    } else if (useblob) {
        curr.push(blob);
    } else {
        curr.push(str);
    }
    return true;
};
CSL.Output.Queue.prototype.string = function (state, myblobs, blob) {
    var i, ilen, j, jlen, b;
    var txt_esc = CSL.getSafeEscape(this.state);
    var blobs = myblobs.slice();
    var ret = [];
    if (blobs.length === 0) {
        return ret;
    }
    var blob_delimiter = "";
    if (blob) {
        blob_delimiter = blob.strings.delimiter;
    } else {
        state.tmp.count_offset_characters = false;
        state.tmp.offset_characters = 0;
    }
    if (blob && blob.new_locale) {
        blob.old_locale = state.opt.lang;
        state.opt.lang = blob.new_locale;
    }
    var blobjr, use_suffix, use_prefix, params;
    for (i = 0, ilen = blobs.length; i < ilen; i += 1) {
        blobjr = blobs[i];
        if (blobjr.strings.first_blob) {
            state.tmp.count_offset_characters = blobjr.strings.first_blob;
        }
        if ("string" === typeof blobjr.blobs) {
            if ("number" === typeof blobjr.num) {
                ret.push(blobjr);
            } else if (blobjr.blobs) {
                b = txt_esc(blobjr.blobs);
                var blen = b.length;
                if (!state.tmp.suppress_decorations) {
                    for (j = 0, jlen = blobjr.decorations.length; j < jlen; j += 1) {
                        params = blobjr.decorations[j];
                        if (params[0] === "@showid") {
                            continue;
                        }
                        if (state.normalDecorIsOrphan(blobjr, params)) {
                            continue;
                        }
                        b = state.fun.decorate[params[0]][params[1]](state, b, params[2]);
                    }
                }
                if (b && b.length) {
                    b = txt_esc(blobjr.strings.prefix, state.tmp.nestedBraces) + b + txt_esc(blobjr.strings.suffix, state.tmp.nestedBraces);
                    if (state.opt.development_extensions.csl_reverse_lookup_support && !state.tmp.suppress_decorations) {
                        for (j = 0, jlen = blobjr.decorations.length; j < jlen; j += 1) {
                            params = blobjr.decorations[j];
                            if (params[0] === "@showid") {
                                b = state.fun.decorate[params[0]][params[1]](state, b, params[2]);
                            }
                        }
                    }
                    ret.push(b);
                    if (state.tmp.count_offset_characters) {
                        state.tmp.offset_characters += (blen + blobjr.strings.suffix.length + blobjr.strings.prefix.length);
                    }
                }
            }
        } else if (blobjr.blobs.length) {
            var addtoret = state.output.string(state, blobjr.blobs, blobjr);
            ret = ret.concat(addtoret);
        }
        if (blobjr.strings.first_blob) {
            state.registry.registry[blobjr.strings.first_blob].offset = state.tmp.offset_characters;
            state.tmp.count_offset_characters = false;
        }
    }
    var span_split = 0;
    for (i = 0, ilen = ret.length; i < ilen; i += 1) {
        if ("string" === typeof ret[i]) {
            span_split = (parseInt(i, 10) + 1);
            if (i < ret.length - 1  && "object" === typeof ret[i + 1]) {
                if (blob_delimiter && !ret[i + 1].UGLY_DELIMITER_SUPPRESS_HACK) {
                    ret[i] += txt_esc(blob_delimiter);
                } else {
                }
                ret[i + 1].UGLY_DELIMITER_SUPPRESS_HACK = true;
            }
        }
    }
    if (blob && (blob.decorations.length || blob.strings.suffix || blob.strings.prefix)) {
        span_split = ret.length;
    }
    var blobs_start = state.output.renderBlobs(ret.slice(0, span_split), blob_delimiter);
    if (blobs_start && blob && (blob.decorations.length || blob.strings.suffix || blob.strings.prefix)) {
        if (!state.tmp.suppress_decorations) {
            for (i = 0, ilen = blob.decorations.length; i < ilen; i += 1) {
                params = blob.decorations[i];
                if (["@bibliography", "@display", "@showid"].indexOf(params[0]) > -1) {
                    continue;
                }
                if (state.normalDecorIsOrphan(blobjr, params)) {
                    continue;
                }
                blobs_start = state.fun.decorate[params[0]][params[1]](state, blobs_start, params[2]);
            }
        }
        b = blobs_start;
        use_suffix = blob.strings.suffix;
        if (b && b.length) {
            use_prefix = blob.strings.prefix;
            b = txt_esc(use_prefix, state.tmp.nestedBraces) + b + txt_esc(use_suffix, state.tmp.nestedBraces);
            if (state.tmp.count_offset_characters) {
                state.tmp.offset_characters += (use_prefix.length + use_suffix.length);
            }
        }
        blobs_start = b;
        if (!state.tmp.suppress_decorations) {
            for (i = 0, ilen = blob.decorations.length; i < ilen; i += 1) {
                params = blob.decorations[i];
                if (["@bibliography", "@display", "@showid"].indexOf(params[0]) === -1) {
                    continue;
                }
                blobs_start = state.fun.decorate[params[0]][params[1]].call(blob, state, blobs_start, params[2]);
            }
        }
    }
    var blobs_end = ret.slice(span_split, ret.length);
    if (!blobs_end.length && blobs_start) {
        ret = [blobs_start];
    } else if (blobs_end.length && !blobs_start) {
        ret = blobs_end;
    } else if (blobs_start && blobs_end.length) {
        ret = [blobs_start].concat(blobs_end);
    }
    if ("undefined" === typeof blob) {
        this.queue = [];
        this.current.mystack = [];
        this.current.mystack.push(this.queue);
        if (state.tmp.suppress_decorations) {
            ret = state.output.renderBlobs(ret);
        }
    } else if ("boolean" === typeof blob) {
        ret = state.output.renderBlobs(ret);
    }
    if (blob && blob.new_locale) {
        state.opt.lang = blob.old_locale;
    }
    if (blob) {
        return ret;
    } else {
        return ret;
    }
};
CSL.Output.Queue.prototype.clearlevel = function () {
    var blob, pos, len;
    blob = this.current.value();
    len = blob.blobs.length;
    for (pos = 0; pos < len; pos += 1) {
        blob.blobs.pop();
    }
};
CSL.Output.Queue.prototype.renderBlobs = function (blobs, delim, has_more) {
    var state, ret, ret_last_char, use_delim, i, blob, pos, len, ppos, llen, pppos, lllen, res, str, params, txt_esc;
    txt_esc = CSL.getSafeEscape(this.state);
    if (!delim) {
        delim = "";
    }
    state = this.state;
    ret = "";
    ret_last_char = [];
    use_delim = "";
    len = blobs.length;
    for (pos = 0; pos < len; pos += 1) {
        if (blobs[pos].checkNext) {
            blobs[pos].checkNext(blobs[(pos + 1)]);
        }
    }
    var doit = true;
    for (pos = blobs.length - 1; pos > 0; pos += -1) {
        if (blobs[pos].checkLast) {
        if (doit && blobs[pos].checkLast(blobs[pos - 1])) {
            doit = false;
        }
        } else {
        doit = true;
        }
    }
    len = blobs.length;
    for (pos = 0; pos < len; pos += 1) {
        blob = blobs[pos];
        if (ret) {
            use_delim = delim;
        }
        if (blob && "string" === typeof blob) {
            ret += txt_esc(use_delim);
            ret += blob;
            if (state.tmp.count_offset_characters) {
                state.tmp.offset_characters += (use_delim.length);
            }
        } else if (blob.status !== CSL.SUPPRESS) {
            str = blob.formatter.format(blob.num, blob.gender);
            var strlen = str.replace(/<[^>]*>/g, "").length;
            this.append(str, "empty", true);
            var str_blob = this.pop();
            var count_offset_characters = state.tmp.count_offset_characters;
            str = this.string(state, [str_blob], false);
            state.tmp.count_offset_characters = count_offset_characters;
            if (blob.strings["text-case"]) {
                str = CSL.Output.Formatters[blob.strings["text-case"]](this.state, str);
            }
            if (str && this.state.tmp.strip_periods && !noStripPeriods) {
                str = str.replace(/\.([^a-z]|$)/g, "$1");
            }
            if (!state.tmp.suppress_decorations) {
                llen = blob.decorations.length;
                for (ppos = 0; ppos < llen; ppos += 1) {
                    params = blob.decorations[ppos];
                    if (state.normalDecorIsOrphan(blob, params)) {
                        continue;
                    }
                    str = state.fun.decorate[params[0]][params[1]](state, str, params[2]);
                }
            }
            str = blob.strings.prefix + str + blob.strings.suffix;
            var addme = "";
            if (blob.status === CSL.END) {
                addme = txt_esc(blob.range_prefix);
            } else if (blob.status === CSL.SUCCESSOR) {
                addme = txt_esc(blob.successor_prefix);
            } else if (blob.status === CSL.START) {
                addme = "";
            } else if (blob.status === CSL.SEEN) {
                addme = txt_esc(blob.splice_prefix);
            }
            ret += addme;
            ret += str;
            if (state.tmp.count_offset_characters) {
                state.tmp.offset_characters += (addme.length + blob.strings.prefix.length + strlen + blob.strings.suffix.length);
            }
        }
    }
    return ret;
};
CSL.Output.Queue.purgeEmptyBlobs = function (myblobs, endOnly) {
    var res, i, ilen, j, jlen, tmpblobs;
    if ("string" === typeof myblobs || !myblobs.length) {
        return;
    }
    for (i = myblobs.length - 1; i > -1; i += -1) {
        CSL.Output.Queue.purgeEmptyBlobs(myblobs[i].blobs, endOnly);
    }
    for (i = myblobs.length - 1; i > -1; i += -1) {
        if (!myblobs[i].blobs.length) {
            tmpblobs = myblobs.slice(i + 1);
            for (j = i, jlen = myblobs.length; j < jlen; j += 1) {
                myblobs.pop();
            }
            for (j = 0, jlen = tmpblobs.length; j < jlen; j += 1) {
                myblobs.push(tmpblobs[j]);
            }
        }
        if (endOnly) {
            break;
        }
    }
};
CSL.Output.Queue.purgeNearsidePrefixChars = function(myblob, chr) {
    if (!chr) {
        return;
    }
    if ("object" === typeof myblob) {
        if ((CSL.TERMINAL_PUNCTUATION.indexOf(chr) > -1 && 
             CSL.TERMINAL_PUNCTUATION.slice(0, -1).indexOf(myblob.strings.prefix.slice(0, 1)) > -1)) {
            myblob.strings.prefix = myblob.strings.prefix.slice(1);
        } else if ("object" === typeof myblob.blobs) {
            CSL.Output.Queue.purgeNearsidePrefixChars(myblob.blobs[0], chr);
        }
    }
};
CSL.Output.Queue.purgeNearsidePrefixSpaces = function(myblob, chr) {
    if ("object" === typeof myblob) {
        if (" " === chr && " " === myblob.strings.prefix.slice(0, 1)) {
            myblob.strings.prefix = myblob.strings.prefix.slice(1);
        } else if ("object" === typeof myblob.blobs) {
            CSL.Output.Queue.purgeNearsidePrefixSpaces(myblob.blobs[0], chr);
        }
    }
};
CSL.Output.Queue.purgeNearsideSuffixSpaces = function(myblob, chr) {
    if ("object" === typeof myblob) {
        if (" " === chr && " " === myblob.strings.suffix.slice(-1)) {
            myblob.strings.suffix = myblob.strings.suffix.slice(0, -1);
        } else if ("object" === typeof myblob.blobs) {
            if (!chr) {
                chr = myblob.strings.suffix.slice(-1);
            }
            chr = CSL.Output.Queue.purgeNearsideSuffixSpaces(myblob.blobs[myblob.blobs.length - 1], chr);
        } else {
            chr = myblob.strings.suffix.slice(-1);
        }
    }
    return chr;
};
CSL.Output.Queue.adjustPunctuation = function (state, myblobs, stk, finish) {
    var chr, suffix, dpref, blob, delimiter, suffixX, dprefX, blobX, delimiterX, prefix, prefixX, dsuffX, dsuff, slast, dsufff, dsufffX, lastchr, firstchr, exposed_suffixes, exposed, j, jlen, i, ilen;
    var TERMS = CSL.TERMINAL_PUNCTUATION.slice(0, -1);
    var TERM_OR_SPACE = CSL.TERMINAL_PUNCTUATION;
    var SWAPS = CSL.SWAPPING_PUNCTUATION;
    if (!stk) {
        stk = [{suffix: "", delimiter: ""}];
    }
    slast = stk.length - 1;
    delimiter = stk[slast].delimiter;
    dpref = stk[slast].dpref;
    dsuff = stk[slast].dsuff;
    dsufff = stk[slast].dsufff;
    prefix = stk[slast].prefix;
    suffix = stk[slast].suffix;
    blob = stk[slast].blob;
    if ("string" === typeof myblobs) {
        if (suffix) {
            if (blob && 
                TERMS.indexOf(myblobs.slice(-1)) > -1 &&
                TERMS.slice(1).indexOf(suffix) > -1 &&
                blob.strings.suffix !== " ") {
                    blob.strings.suffix = blob.strings.suffix.slice(1);
            }
        }
        lastchr = myblobs.slice(-1);
        firstchr = myblobs.slice(0,1);
    } else {
        if (dpref) {
            for (j = 0, jlen = myblobs.length - 1; j < jlen; j += 1) {
                var t = myblobs[j].strings.suffix.slice(-1);
                if (TERMS.indexOf(t) === -1 ||
                    TERMS.indexOf(dpref) === -1) {
                    if (dpref !== " " || dpref !== myblobs[j].strings.suffix.slice(-1)) {
                        myblobs[j].strings.suffix += dpref;                        
                    }
                }
            }
        }
        if (suffix === " ") {
            CSL.Output.Queue.purgeNearsideSuffixSpaces(myblobs[myblobs.length - 1], " ");
        }
        var lst = [];
        var doblob;
        for (i = 0, ilen = myblobs.length - 1; i < ilen; i += 1) {
            doblob = myblobs[i];
            var following_prefix = myblobs[i + 1].strings.prefix;
            chr = false;
            var ret = CSL.Output.Queue.purgeNearsideSuffixSpaces(doblob, chr);
            if (!dsuff) {
                lst.push(ret);
            } else {
                lst.push(false);
            }
        }
        chr = false;
        for (i = 1, ilen = myblobs.length; i < ilen; i += 1) {
            doblob = myblobs[i];
            chr = "";
            var preceding_suffix = myblobs[i - 1].strings.suffix;
            if (dsuff === " ") {
                chr = dsuff;
            } else if (preceding_suffix) {
                chr = preceding_suffix.slice(-1);
            } else if (lst[i - 1]) {
                chr = lst[i - 1];
            }
            CSL.Output.Queue.purgeNearsidePrefixSpaces(doblob, chr);
        }
        if (dsufff) {
            CSL.Output.Queue.purgeNearsidePrefixSpaces(myblobs[0], " ");
        } else if (prefix === " ") {
            CSL.Output.Queue.purgeNearsidePrefixSpaces(myblobs[0], " ");
        }
        for (i = 0, ilen = myblobs.length; i < ilen; i += 1) {
            doblob = myblobs[i];
            CSL.Output.Queue.purgeNearsidePrefixChars(doblob, lastchr);
            if (i === 0) {
                if (prefix) {
                    if (doblob.strings.prefix.slice(0, 1) === " ") {
                    }
                }
            }
            if (dsufff) {
                if (doblob.strings.prefix) {
                    if (i === 0) {
                        if (doblob.strings.prefix.slice(0, 1) === " ") {
                        }
                    }
                }
            }
            if (dsuff) {
                if (i > 0) {
                    if (doblob.strings.prefix.slice(0, 1) === " ") {
                    }
                }
            }
            if (i < (myblobs.length - 1)) {
                var nextprefix = myblobs[i + 1].strings.prefix;
                if (!delimiter) {
                    if (nextprefix) {
                        var nxtchr = nextprefix.slice(0, 1);
                        if (SWAPS.indexOf(nxtchr) > -1) {
                            myblobs[i + 1].strings.prefix = nextprefix.slice(1);
                            if (TERMS.indexOf(nxtchr) === -1 ||
                                (TERMS.indexOf(nxtchr) > -1 &&
                                 TERMS.indexOf(doblob.strings.suffix.slice(-1)) === -1)) {
                                     doblob.strings.suffix += nxtchr;
                            }
                        } else if (nxtchr === " " &&
                                    doblob.strings.suffix.slice(-1) === " ") {
                            doblob.strings.suffix = doblob.strings.suffix.slice(0, -1);
                        }
                    }
                }
            }
            if (i === (myblobs.length - 1)) {
                if (suffix) {
                    if (doblob.strings.suffix && 
                        (TERMS.slice(1).indexOf(suffix) > -1 &&
                          TERMS.indexOf(doblob.strings.suffix.slice(-1)) > -1)) {
                            blob.strings.suffix = blob.strings.suffix.slice(1);
                    }
                }
            }
            if (state.getOpt('punctuation-in-quote')) {
                var decorations = doblob.decorations;
                for (j = 0, jlen = decorations.length; j < jlen; j += 1) {
                    if (decorations[j][0] === '@quotes' && decorations[j][1] === 'true') {
                        var swapchar = doblob.strings.suffix.slice(0, 1);
                        var swapblob = false;
                        if (SWAPS.indexOf(swapchar) > -1) {
                            swapblob = doblob;
                        } else if (SWAPS.indexOf(suffix) > -1 && i === (myblobs.length - 1)) {
                            swapchar = suffix;
                            swapblob = blob;
                        } else {
                            swapchar = false;
                        }
                        if (swapchar) {
                            if ("string" === typeof doblob.blobs) {
                                if (SWAPS.indexOf(doblob.blobs.slice(-1)) === -1 ||
                                   (TERMS.indexOf(doblob.blobs.slice(-1)) > -1 &&
                                    SWAPS.indexOf(swapchar) > -1 &&
                                    TERMS.indexOf(swapchar) === -1)) {
                                        doblob.blobs += swapchar;
                                }
                            } else {
                                if (SWAPS.indexOf(doblob.blobs.slice(-1)[0].strings.suffix.slice(-1)) === -1 ||
                                    (TERMS.indexOf(doblob.blobs.slice(-1)[0].strings.suffix.slice(-1)) > -1 &&
                                     SWAPS.indexOf(swapchar) > -1 &&
                                     TERMS.indexOf(swapchar) === -1)) {
                                         doblob.blobs.slice(-1)[0].strings.suffix += swapchar;
                                }
                            }
                            swapblob.strings.suffix = swapblob.strings.suffix.slice(1);
                        }
                    }
                }
            }
            if (i === (myblobs.length - 1)) {
                if (doblob.strings.suffix) {
                    suffixX = doblob.strings.suffix.slice(0, 1);
                    blobX = doblob;
                } else {
                    suffixX = stk[stk.length - 1].suffix;
                    blobX = stk[stk.length - 1].blob;
                }
            } else {
                if (doblob.strings.suffix) {
                    suffixX = doblob.strings.suffix.slice(0, 1);
                    blobX = doblob;
                } else {
                    suffixX = "";
                    blobX = false;
                }
            }
            if (SWAPS.concat([" "]).indexOf(suffixX) === -1) {
                suffixX = "";
                blobX = false;
            }
            if (doblob.strings.delimiter && 
                doblob.blobs.length > 1) {
                dprefX = doblob.strings.delimiter.slice(0, 1);
                if (SWAPS.concat([" "]).indexOf(dprefX) > -1) {
                    doblob.strings.delimiter = doblob.strings.delimiter.slice(1);
                } else {
                    dprefX = "";
                }
            } else {
                dprefX = "";
            }
            if (doblob.strings.prefix) {
                if (doblob.strings.prefix.slice(-1) === " ") {
                    prefixX = " ";
                } else {
                    prefixX = "";
                }
            } else {
                if (i === 0) {
                    prefixX = prefix;                    
                } else {
                    prefixX = "";
                }
            }
            if (dsuff) {
                dsufffX = dsuff;
            } else {
                if (i === 0) {
                    dsufffX = dsufff;                    
                } else {
                    dsufffX = "";
                }
            }
            if (doblob.strings.delimiter) {
                if (doblob.strings.delimiter.slice(-1) === " " &&
                    "object" === typeof doblob.blobs && doblob.blobs.length > 1) {
                       dsuffX = doblob.strings.delimiter.slice(-1);
                } else {
                    dsuffX = "";                        
                }
            } else {
                dsuffX = "";                    
            }
            delimiterX = doblob.strings.delimiter;
            stk.push({suffix: suffixX, dsuff:dsuffX, blob:blobX, delimiter:delimiterX, prefix:prefixX, dpref: dprefX, dsufff: dsufffX});
            lastchr = CSL.Output.Queue.adjustPunctuation(state, doblob.blobs, stk);
        }
        if (myblobs && myblobs.length) {
            var last_suffix = myblobs[myblobs.length - 1].strings.suffix;
            if (last_suffix) {
                lastchr = last_suffix.slice(-1);
            }
        }
    }
    if (stk.length > 1) {
        stk.pop();
    }
    state.tmp.last_chr = lastchr;
    return lastchr;
};
CSL.ambigConfigDiff = function(a, b) {
    var ret, pos, len, ppos, llen;
    if (a.names.length !== b.names.length) {
        return 1;
    } else {
        for (pos = 0, len = a.names.length; pos < len; pos += 1) {
            if (a.names[pos] !== b.names[pos]) {
                return 1;
            } else {
                for (ppos = 0, llen = a.givens[pos]; ppos < llen; ppos += 1) {
                    if (a.givens[pos][ppos] !== b.givens[pos][ppos]) {
                        return 1;
                    }
                }
            }
        }
    }
    if (a.disambiguate != b.disambiguate) {
        return 1;
    }
    if (a.year_suffix !== b.year_suffix) {
        return 1;
    }
    return 0;
};
CSL.cloneAmbigConfig = function (config, oldconfig, tainters) {
    var i, ilen, j, jlen, k, klen, param;
    var ret = {};
    ret.names = [];
    ret.givens = [];
    ret.year_suffix = false;
    ret.disambiguate = false;
    for (i = 0, ilen = config.names.length; i < ilen; i += 1) {
        param = config.names[i];
        ret.names[i] = param;
    }
    for (i  = 0, ilen = config.givens.length; i < ilen; i += 1) {
        param = [];
        for (j = 0, jlen = config.givens[i].length; j < jlen; j += 1) {
            param.push(config.givens[i][j]);
        }
        ret.givens.push(param);
    }
    if (oldconfig) {
        ret.year_suffix = oldconfig.year_suffix;
        ret.disambiguate = oldconfig.disambiguate;
    } else {
        ret.year_suffix = config.year_suffix;
        ret.disambiguate = config.disambiguate;
    }
    return ret;
};
CSL.getAmbigConfig = function () {
    var config, ret;
    config = this.tmp.disambig_request;
    if (!config) {
        config = this.tmp.disambig_settings;
    }
    ret = CSL.cloneAmbigConfig(config);
    return ret;
};
CSL.getMaxVals = function () {
    return this.tmp.names_max.mystack.slice();
};
CSL.getMinVal = function () {
    return this.tmp["et-al-min"];
};
CSL.tokenExec = function (token, Item, item) {
    var next, maybenext, exec, pos, len, debug;
    debug = false;
    next = token.next;
    maybenext = false;
    if (token.evaluator) {
        next = token.evaluator(token, this, Item, item);
    }
    len = token.execs.length;
    for (pos = 0; pos < len; pos += 1) {
        exec = token.execs[pos];
        maybenext = exec.call(token, this, Item, item);
        if (maybenext) {
            next = maybenext;
        }
    }
    return next;
};
CSL.expandMacro = function (macro_key_token) {
    var mkey, start_token, key, end_token, navi, macro_nodes, newoutput, mergeoutput, end_of_macro, func;
    mkey = macro_key_token.postponed_macro;
    if (this.build.macro_stack.indexOf(mkey) > -1) {
        throw "CSL processor error: call to macro \"" + mkey + "\" would cause an infinite loop";
    } else {
        this.build.macro_stack.push(mkey);
    }
    var hasDate = false;
    var macroid = false;
    macro_nodes = this.sys.xml.getNodesByName(this.cslXml, 'macro', mkey);
    if (macro_nodes.length) {
        macroid = this.sys.xml.getAttributeValue(macro_nodes[0],'cslid');
        hasDate = this.sys.xml.getAttributeValue(macro_nodes[0], "macro-has-date");
    }
    if (hasDate) {
        func = function (state, Item) {
            if (state.tmp.extension) {
                state.tmp["doing-macro-with-date"] = true;
            }
        };
        macro_key_token.execs.push(func);
    }
    macro_key_token.tokentype = CSL.START;
    macro_key_token.cslid = macroid;
    CSL.Node.group.build.call(macro_key_token, this, this[this.build.area].tokens, true);
    if (!this.sys.xml.getNodeValue(macro_nodes)) {
        throw "CSL style error: undefined macro \"" + mkey + "\"";
    }
    navi = new this.getNavi(this, macro_nodes);
    CSL.buildStyle.call(this, navi);
    end_of_macro = new CSL.Token("group", CSL.END);
	if (macro_key_token.decorations) {
		end_of_macro.decorations = macro_key_token.decorations.slice();
    }
    if (hasDate) {
        func = function (state, Item) {
            if (state.tmp.extension) {
                state.tmp["doing-macro-with-date"] = false;
            }
        };
        end_of_macro.execs.push(func);
    }
    CSL.Node.group.build.call(end_of_macro, this, this[this.build.area].tokens, true);
    this.build.macro_stack.pop();
};
CSL.XmlToToken = function (state, tokentype) {
    var name, txt, attrfuncs, attributes, decorations, token, key, target;
    name = state.sys.xml.nodename(this);
    if (state.build.skip && state.build.skip !== name) {
        return;
    }
    if (!name) {
        txt = state.sys.xml.content(this);
        if (txt) {
            state.build.text = txt;
        }
        return;
    }
    if (!CSL.Node[state.sys.xml.nodename(this)]) {
        throw "Undefined node name \"" + name + "\".";
    }
    attrfuncs = [];
    attributes = state.sys.xml.attributes(this);
    decorations = CSL.setDecorations.call(this, state, attributes);
    token = new CSL.Token(name, tokentype);
    if (tokentype !== CSL.END || name === "if" || name === "else-if" || name === "layout") {
        for (key in attributes) {
            if (attributes.hasOwnProperty(key)) {
                if (tokentype === CSL.END && key !== "@language" && key !== "@locale") {
                    continue;
                }
                if (attributes.hasOwnProperty(key)) {
                    try {
                        CSL.Attributes[key].call(token, state, "" + attributes[key]);
                    } catch (e) {
                        if (e === "TypeError: Cannot call method \"call\" of undefined") {
                            throw "Unknown attribute \"" + key + "\" in node \"" + name + "\" while processing CSL file";
                        } else {
                            throw "CSL processor error, " + key + " attribute: " + e;
                        }
                    }
                }
            }
        }
        token.decorations = decorations;
    }
    target = state[state.build.area].tokens;
    CSL.Node[name].build.call(token, state, target);
};
CSL.DateParser = function () {
    var jiy_list, jiy, jiysplitter, jy, jmd, jr, pos, key, val, yearlast, yearfirst, number, rangesep, fuzzychar, chars, rex, rexdash, rexdashslash, rexslashdash, seasonstrs, seasonrexes, seasonstr, monthstrs, monthstr, mrexes, seasonrex, len, jiymatchstring, jiymatcher;
    jiy_list = [
        ["\u660E\u6CBB", 1867],
        ["\u5927\u6B63", 1911],
        ["\u662D\u548C", 1925],
        ["\u5E73\u6210", 1988]
    ];
    jiy = {};
    len = jiy_list.length;
    for (pos = 0; pos < len; pos += 1) {
        key = jiy_list[pos][0];
        val = jiy_list[pos][1];
        jiy[key] = val;
    }
    jiymatchstring = [];
    for (pos = 0; pos < len; pos += 1) {
        val = jiy_list[pos][0];
        jiymatchstring.push(val);
    }
    jiymatchstring = jiymatchstring.join("|");
    jiysplitter = "(?:" + jiymatchstring + ")(?:[0-9]+)";
    jiysplitter = new RegExp(jiysplitter);
    jiymatcher = "(?:" + jiymatchstring + ")(?:[0-9]+)";
    jiymatcher = new RegExp(jiymatcher, "g");
    jmd = /(\u6708|\u5E74)/g;
    jy = /\u65E5/;
    jr = /\u301c/g;
    yearlast = "(?:[?0-9]{1,2}%%NUMD%%){0,2}[?0-9]{4}(?![0-9])";
    yearfirst = "[?0-9]{4}(?:%%NUMD%%[?0-9]{1,2}){0,2}(?![0-9])";
    number = "[?0-9]{1,3}";
    rangesep = "[%%DATED%%]";
    fuzzychar = "[?~]";
    chars = "[a-zA-Z]+";
    rex = "(" + yearfirst + "|" + yearlast + "|" + number + "|" + rangesep + "|" + fuzzychar + "|" + chars + ")";
    rexdash = new RegExp(rex.replace(/%%NUMD%%/g, "-").replace(/%%DATED%%/g, "-"));
    rexdashslash = new RegExp(rex.replace(/%%NUMD%%/g, "-").replace(/%%DATED%%/g, "\/"));
    rexslashdash = new RegExp(rex.replace(/%%NUMD%%/g, "\/").replace(/%%DATED%%/g, "-"));
    seasonstrs = [];
    seasonrexes = [];
    len = seasonstrs.length;
    for (pos = 0; pos < len; pos += 1) {
        seasonrex = new RegExp(seasonstrs[pos] + ".*");
        seasonrexes.push(seasonrex);
    }
    this.mstrings = "january february march april may june july august september october november december spring summer fall winter spring summer";
    this.mstrings = this.mstrings.split(" ");
    this.setOrderDayMonth = function() {
        this.monthguess = 1;
        this.dayguess = 0;
    };
    this.setOrderMonthDay = function() {
        this.monthguess = 0;
        this.dayguess = 1;
    };
    this.setOrderMonthDay();
    this.resetMonths = function() {
        var i, ilen, j, jlen;
        this.msets = [];
        for (i = 0, ilen = this.mstrings.length; i < ilen; i += 1) {
            this.msets.push([this.mstrings[i]]);
        }
        this.mabbrevs = [];
        for (i = 0, ilen = this.msets.length; i < ilen; i += 1) {
            this.mabbrevs.push([]);
            for (j = 0, jlen = this.msets[i].length; j < jlen; j += 1) {
                this.mabbrevs[i].push(this.msets[i][0].slice(0, 3));
            }
        }
        this.mrexes = [];
        for (i = 0, ilen = this.mabbrevs.length; i < ilen; i += 1) {
            this.mrexes.push(new RegExp("(?:" + this.mabbrevs[i].join("|") + ")"));
        }
    };
    this.resetMonths();
    this.addMonths = function(lst) {
        var i, ilen, j, jlen, k, klen, jkey, kkey;
        if ("string" === typeof lst) {
            lst = lst.split(/\s+/);
        }
        if (lst.length !== 12 && lst.length !== 16) {
            CSL.debug("month [+season] list of "+lst.length+", expected 12 or 16. Ignoring.");
            return;
        }
        var othermatch = [];
        var thismatch = [];
        for (i = 0, ilen = lst.length; i < ilen; i += 1) {
            var abbrevlen = false;
            var skip = false;
            var insert = 3;
            var extend = {};
            for (j = 0, jlen = this.mabbrevs.length; j < jlen; j += 1) {
                extend[j] = {};
                if (j === i) {
                    for (k = 0, klen = this.mabbrevs[i].length; k < klen; k += 1) {
                        if (this.mabbrevs[i][k] === lst[i].slice(0, this.mabbrevs[i][k].length)) {
                            skip = true;
                            break;
                        }
                    }
                } else {
                    for (k = 0, klen = this.mabbrevs[j].length; k < klen; k += 1) {
                        abbrevlen = this.mabbrevs[j][k].length;
                        if (this.mabbrevs[j][k] === lst[i].slice(0, abbrevlen)) {
                            while (this.msets[j][k].slice(0, abbrevlen) === lst[i].slice(0, abbrevlen)) {
                                if (abbrevlen > lst[i].length || abbrevlen > this.msets[j][k].length) {
                                    CSL.debug("unable to disambiguate month string in date parser: "+lst[i]);
                                    break;
                                } else {
                                    abbrevlen += 1;
                                }
                            }
                            insert = abbrevlen;
                            extend[j][k] = abbrevlen;
                        }
                    }
                }
                for (jkey in extend) {
                    if (extend.hasOwnProperty(jkey)) {
                        for (kkey in extend[jkey]) {
                            if (extend[jkey].hasOwnProperty(kkey)) {
                                abbrevlen = extend[jkey][kkey];
                                jkey = parseInt(jkey, 10);
                                kkey = parseInt(kkey, 10);
                                this.mabbrevs[jkey][kkey] = this.msets[jkey][kkey].slice(0, abbrevlen);
                            }
                        }
                    }
                }
            }
            if (!skip) {
                this.msets[i].push(lst[i]);
                this.mabbrevs[i].push(lst[i].slice(0, insert));
            }
        }
        this.mrexes = [];
        for (i = 0, ilen = this.mabbrevs.length; i < ilen; i += 1) {
            this.mrexes.push(new RegExp("(?:" + this.mabbrevs[i].join("|") + ")"));
        }
    };
    this.parse = function (txt) {
        var slash, dash, lst, l, m, number, note, thedate, slashcount, range_delim, date_delim, ret, delim_pos, delims, isrange, suff, date, breakme, item, delim, element, mm, slst, mmpos, i, ilen, j, jlen, k, klen;
        m = txt.match(jmd);
        if (m) {
            txt = txt.replace(/\s+/, "", "g");
            txt = txt.replace(jy, "", "g");
            txt = txt.replace(jmd, "-", "g");
            txt = txt.replace(jr, "/", "g");
            txt = txt.replace("-/", "/", "g");
            txt = txt.replace(/-$/,"", "g");
            slst = txt.split(jiysplitter);
            lst = [];
            mm = txt.match(jiymatcher);
            var mmx = [];
            for (pos = 0, len = mm.length; pos < len; pos += 1) {
                mmx = mmx.concat(mm[pos].match(/([^0-9]+)([0-9]+)/).slice(1));
            }
            for (pos = 0, len = slst.length; pos < len; pos += 1) {
                lst.push(slst[pos]);
                if (pos !== (len - 1)) {
                    mmpos = (pos * 2);
                    lst.push(mmx[mmpos]);
                    lst.push(mmx[mmpos + 1]);
                }
            }
            l = lst.length;
            for    (pos = 1; pos < l; pos += 3) {
                lst[pos + 1] = jiy[lst[pos]] + parseInt(lst[pos + 1], 10);
                lst[pos] = "";
            }
            txt = lst.join("");
            txt = txt.replace(/\s*-\s*$/, "").replace(/\s*-\s*\//, "/");
            txt = txt.replace(/\.\s*$/, "");
            txt = txt.replace(/\.(?! )/, "");
            slash = txt.indexOf("/");
            dash = txt.indexOf("-");
        }
        txt = txt.replace(/([A-Za-z])\./g, "$1");
        number = "";
        note = "";
        thedate = {};
        if (txt.slice(0, 1) === "\"" && txt.slice(-1) === "\"") {
            thedate.literal = txt.slice(1, -1);
            return thedate;
        }
        if (slash > -1 && dash > -1) {
            slashcount = txt.split("/");
            if (slashcount.length > 3) {
                range_delim = "-";
                date_delim = "/";
                lst = txt.split(rexslashdash);
            } else {
                range_delim = "/";
                date_delim = "-";
                lst = txt.split(rexdashslash);
            }
        } else {
            txt = txt.replace("/", "-");
            range_delim = "-";
            date_delim = "-";
            lst = txt.split(rexdash);
        }
        ret = [];
        len = lst.length;
        for (pos = 0; pos < len; pos += 1) {
            item = lst[pos];
            m = item.match(/^\s*([\-\/]|[a-zA-Z]+|[\-~?0-9]+)\s*$/);
            if (m) {
                ret.push(m[1]);
            }
        }
        delim_pos = ret.indexOf(range_delim);
        delims = [];
        isrange = false;
        if (delim_pos > -1) {
            delims.push([0, delim_pos]);
            delims.push([(delim_pos + 1), ret.length]);
            isrange = true;
        } else {
            delims.push([0, ret.length]);
        }
        suff = "";
        for (i = 0, ilen = delims.length; i < ilen; i += 1) {
            delim = delims[i];
            date = ret.slice(delim[0], delim[1]);
            for (j = 0, jlen = date.length; j < jlen; j += 1) {
                element = date[j];
                if (element.indexOf(date_delim) > -1) {
                    this.parseNumericDate(thedate, date_delim, suff, element);
                    continue;
                }
                if (element.match(/[0-9]{4}/)) {
                    thedate[("year" + suff)] = element.replace(/^0*/, "");
                    continue;
                }
                breakme = false;
                for (k = 0, klen = this.mrexes.length; k < klen; k += 1) {
                    if (element.toLocaleLowerCase().match(this.mrexes[k])) {
                        thedate[("month" + suff)] = "" + (parseInt(k, 10) + 1);
                        breakme = true;
                        break;
                    }
                    if (breakme) {
                        continue;
                    }
                    if (element.match(/^[0-9]+$/)) {
                        number = parseInt(element, 10);
                    }
                    if (element.toLocaleLowerCase().match(/^bc/) && number) {
                        thedate[("year" + suff)] = "" + (number * -1);
                        number = "";
                        continue;
                    }
                    if (element.toLocaleLowerCase().match(/^ad/) && number) {
                        thedate[("year" + suff)] = "" + number;
                        number = "";
                        continue;
                    }
                }
                breakme = false;
                for (k = 0, klen = seasonrexes.length; k < klen; k += 1) {
                    if (element.toLocaleLowerCase().match(seasonrexes[k])) {
                        thedate[("season" + suff)] = "" + (parseInt(k, 10) + 1);
                        breakme = true;
                        break;
                    }
                }
                if (breakme) {
                    continue;
                }
                if (element === "~" || element === "?" || element === "c" || element.match(/^cir/)) {
                    thedate.circa = "" + 1;
                    continue;
                }
                if (element.toLocaleLowerCase().match(/(?:mic|tri|hil|eas)/) && !thedate[("season" + suff)]) {
                    note = element;
                    continue;
                }
            }
            if (number) {
                thedate[("day" + suff)] = number;
                number = "";
            }
            if (note && !thedate[("season" + suff)]) {
                thedate[("season" + suff)] = note;
                note = "";
            }
            suff = "_end";
        }
        if (isrange) {
            for (j = 0, jlen = CSL.DATE_PARTS_ALL.length; j < jlen; j += 1) {
                item = CSL.DATE_PARTS_ALL[j];
                if (thedate[item] && !thedate[(item + "_end")]) {
                    thedate[(item + "_end")] = thedate[item];
                } else if (!thedate[item] && thedate[(item + "_end")]) {
                    thedate[item] = thedate[(item + "_end")];
                }
            }
        }
        if (!thedate.year) {
            thedate = { "literal": txt };
        }
        if (this.use_array) {
            this.toArray(thedate);            
        }
        return thedate;
    };
    this.returnAsArray = function () {
        this.use_array = true;
    };
    this.returnAsKeys = function () {
        this.use_array = false;
    };
    this.toArray = function (thedate) {
        var i, ilen, part;
        thedate["date-parts"] = [];
        thedate["date-parts"].push([]);
        var slicelen = 0;
        for (i = 0, ilen = 3; i < ilen; i += 1) {
            part = ["year", "month", "day"][i];
            if (!thedate[part]) {
                break;
            }
            slicelen += 1;
            thedate["date-parts"][0].push(thedate[part]);
            delete thedate[part];
        }
        for (i = 0, ilen = slicelen; i < ilen; i += 1) {
            part = ["year_end", "month_end", "day_end"][i];
            if (thedate[part] && thedate["date-parts"].length === 1) {
                thedate["date-parts"].push([]);
            }
            thedate["date-parts"][1].push(thedate[part]);
            delete thedate[part];
        }
    };
    this.parseNumericDate = function (ret, delim, suff, txt) {
        var lst, i, ilen;
        lst = txt.split(delim);
        for (i = 0, ilen = lst.length; i < ilen; i += 1) {
            if (lst[i].length === 4) {
                ret[("year" + suff)] = lst[i].replace(/^0*/, "");
                if (!i) {
                    lst = lst.slice(1);
                } else {
                    lst = lst.slice(0, i);
                }
                break;
            }
        }
        for (i = 0, ilen = lst.length; i < ilen; i += 1) {
            lst[i] = parseInt(lst[i], 10);
        }
        if (lst.length === 1) {
            ret[("month" + suff)] = "" + lst[0];
        } else if (lst.length === 2) {
            if (lst[this.monthguess] > 12) {
                ret[("month" + suff)] = "" + lst[this.dayguess];
                ret[("day" + suff)] = "" + lst[this.monthguess];
            } else {
                ret[("month" + suff)] = "" + lst[this.monthguess];
                ret[("day" + suff)] = "" + lst[this.dayguess];
            }
        }
    };
};
CSL.Engine = function (sys, style, lang, forceLang) {
    var attrs, langspec, localexml, locale;
    this.processor_version = "1.0.336";
    this.csl_version = "1.0";
    this.sys = sys;
    this.sys.xml = new CSL.System.Xml.Parsing();
    if ("string" !== typeof style) {
        style = "";
    }
    if (CSL.getAbbreviation) {
        this.sys.getAbbreviation = CSL.getAbbreviation;
    }
    this.sys.AbbreviationSegments = CSL.AbbreviationSegments;
    this.parallel = new CSL.Parallel(this);
    this.transform = new CSL.Transform(this);
    this.setParseNames = function (val) {
        this.opt['parse-names'] = val;
    };
    this.opt = new CSL.Engine.Opt();
    this.tmp = new CSL.Engine.Tmp();
    this.build = new CSL.Engine.Build();
    this.fun = new CSL.Engine.Fun();
    this.configure = new CSL.Engine.Configure();
    this.citation_sort = new CSL.Engine.CitationSort();
    this.bibliography_sort = new CSL.Engine.BibliographySort();
    this.citation = new CSL.Engine.Citation(this);
    this.bibliography = new CSL.Engine.Bibliography();
    this.output = new CSL.Output.Queue(this);
    this.dateput = new CSL.Output.Queue(this);
    this.cslXml = this.sys.xml.makeXml(style);
    if (this.opt.development_extensions.csl_reverse_lookup_support) {
        this.build.cslNodeId = 0;
        this.setCslNodeIds = function(myxml, nodename) {
            var children = this.sys.xml.children(myxml);
            this.sys.xml.setAttribute(myxml, 'cslid', this.build.cslNodeId);
            this.opt.nodenames.push(nodename);
            this.build.cslNodeId += 1;
            for (var i = 0, ilen = this.sys.xml.numberofnodes(children); i < ilen; i += 1) {
                nodename = this.sys.xml.nodename(children[i]);
                if (nodename) {
                    this.setCslNodeIds(children[i], nodename);
                }
            }
        }
        this.setCslNodeIds(this.cslXml, "style");
    }
    this.sys.xml.addMissingNameNodes(this.cslXml);
    this.sys.xml.addInstitutionNodes(this.cslXml);
    this.sys.xml.insertPublisherAndPlace(this.cslXml);
    this.sys.xml.flagDateMacros(this.cslXml);
    attrs = this.sys.xml.attributes(this.cslXml);
    if ("undefined" === typeof attrs["@sort-separator"]) {
        this.sys.xml.setAttribute(this.cslXml, "sort-separator", ", ");
    }
    this.opt["initialize-with-hyphen"] = true;
    this.setStyleAttributes();
    this.opt.xclass = sys.xml.getAttributeValue(this.cslXml, "class");
    this.opt.styleID = this.sys.xml.getStyleId(this.cslXml);
    if (lang) {
        lang = lang.replace("_", "-");
    }
    if (this.opt["default-locale"][0]) {
        this.opt["default-locale"][0] = this.opt["default-locale"][0].replace("_", "-");
    }
    if (lang && forceLang) {
        this.opt["default-locale"] = [lang];
    }
    if (lang && !forceLang && this.opt["default-locale"][0]) {
        lang = this.opt["default-locale"][0];
    }
    if (this.opt["default-locale"].length === 0) {
        if (!lang) {
            lang = "en-US";
        }
        this.opt["default-locale"].push("en-US");
    }
    if (!lang) {
        lang = this.opt["default-locale"][0];
    }
    langspec = CSL.localeResolve(lang);
    this.opt.lang = langspec.best;
    this.opt["default-locale"][0] = langspec.best;
    this.locale = {};
    this.localeConfigure(langspec);
    this.registry = new CSL.Registry(this);
    this.buildTokenLists("citation");
    this.buildTokenLists("bibliography");
    this.configureTokenLists();
    this.disambiguate = new CSL.Disambiguation(this);
    this.splice_delimiter = false;
    this.fun.dateparser = new CSL.DateParser();
    this.fun.flipflopper = new CSL.Util.FlipFlopper(this);
    this.setCloseQuotesArray();
    this.fun.ordinalizer.init(this);
    this.fun.long_ordinalizer.init(this);
    this.fun.page_mangler = CSL.Util.PageRangeMangler.getFunction(this, "page");
    this.fun.year_mangler = CSL.Util.PageRangeMangler.getFunction(this, "year");
    this.setOutputFormat("html");
};
CSL.Engine.prototype.setCloseQuotesArray = function () {
    var ret;
    ret = [];
    ret.push(this.getTerm("close-quote"));
    ret.push(this.getTerm("close-inner-quote"));
    ret.push('"');
    ret.push("'");
    this.opt.close_quotes_array = ret;
};
CSL.Engine.prototype.buildTokenLists = function (area) {
    var area_nodes, navi;
    area_nodes = this.sys.xml.getNodesByName(this.cslXml, area);
    if (!this.sys.xml.getNodeValue(area_nodes)) {
        return;
    }
    navi = new this.getNavi(this, area_nodes);
    this.build.area = area;
    CSL.buildStyle.call(this, navi);
};
CSL.Engine.prototype.setStyleAttributes = function () {
    var dummy, attr, key, attributes, attrname;
    dummy = {};
    dummy.name = this.sys.xml.nodename(this.cslXml);
    attributes = this.sys.xml.attributes(this.cslXml);
    for (attrname in attributes) {
        if (attributes.hasOwnProperty(attrname)) {
            CSL.Attributes[attrname].call(dummy, this, attributes[attrname]);
        }
    }
};
CSL.buildStyle  = function (navi) {
    if (navi.getkids()) {
        CSL.buildStyle.call(this, navi);
    } else {
        if (navi.getbro()) {
            CSL.buildStyle.call(this, navi);
        } else {
            while (navi.nodeList.length > 1) {
                if (navi.remember()) {
                    CSL.buildStyle.call(this, navi);
                }
            }
        }
    }
};
CSL.Engine.prototype.getNavi = function (state, myxml) {
    this.sys = state.sys;
    this.state = state;
    this.nodeList = [];
    this.nodeList.push([0, myxml]);
    this.depth = 0;
};
CSL.Engine.prototype.getNavi.prototype.remember = function () {
    var node;
    this.depth += -1;
    this.nodeList.pop();
    node = this.nodeList[this.depth][1][(this.nodeList[this.depth][0])];
    CSL.XmlToToken.call(node, this.state, CSL.END);
    return this.getbro();
};
CSL.Engine.prototype.getNavi.prototype.getbro = function () {
    var sneakpeek;
    sneakpeek = this.nodeList[this.depth][1][(this.nodeList[this.depth][0] + 1)];
    if (sneakpeek) {
        this.nodeList[this.depth][0] += 1;
        return true;
    } else {
        return false;
    }
};
CSL.Engine.prototype.getNavi.prototype.getkids = function () {
    var currnode, sneakpeek, pos, node, len;
    currnode = this.nodeList[this.depth][1][this.nodeList[this.depth][0]];
    sneakpeek = this.sys.xml.children(currnode);
    if (this.sys.xml.numberofnodes(sneakpeek) === 0) {
        CSL.XmlToToken.call(currnode, this.state, CSL.SINGLETON);
        return false;
    } else {
        for (pos in sneakpeek) {
            if (true) {
                node = sneakpeek[pos];
                if ("date" === this.sys.xml.nodename(node)) {
                    currnode = CSL.Util.fixDateNode.call(this, currnode, pos, node);
                    sneakpeek = this.sys.xml.children(currnode);
                }
            }
        }
        CSL.XmlToToken.call(currnode, this.state, CSL.START);
        this.depth += 1;
        this.nodeList.push([0, sneakpeek]);
        return true;
    }
};
CSL.Engine.prototype.getNavi.prototype.getNodeListValue = function () {
    return this.nodeList[this.depth][1];
};
CSL.Engine.prototype.getTerm = function (term, form, plural, gender, mode) {
    if (term && term.match(/[A-Z]/) && term === term.toUpperCase()) {
        CSL.debug("Warning: term key is in uppercase form: "+term);
        term = term.toLowerCase();
    }
    var ret = CSL.Engine.getField(CSL.LOOSE, this.locale[this.opt.lang].terms, term, form, plural, gender);
    if (!ret && term === "range-delimiter") {
        ret = "\u2013";
    }
    if (typeof ret === "undefined") {
        if (mode === CSL.STRICT) {
            throw "Error in getTerm: term \"" + term + "\" does not exist.";
        } else if (mode === CSL.TOLERANT) {
            ret = "";
        }
    }
    if (ret) {
        this.tmp.cite_renders_content = true;
    }
    return ret;
};
CSL.Engine.prototype.getDate = function (form) {
    if (this.locale[this.opt.lang].dates[form]) {
        return this.locale[this.opt.lang].dates[form];
    } else {
        return false;
    }
};
CSL.Engine.prototype.getOpt = function (arg) {
    if ("undefined" !== typeof this.locale[this.opt.lang].opts[arg]) {
        return this.locale[this.opt.lang].opts[arg];
    } else {
        return this.locale[this.opt.lang].opts[arg];
    }
};
CSL.Engine.prototype.getVariable = function (Item, varname, form, plural) {
    return CSL.Engine.getField(CSL.LOOSE, Item, varname, form, plural);
};
CSL.Engine.prototype.getDateNum = function (ItemField, partname) {
    if ("undefined" === typeof ItemField) {
        return 0;
    } else {
        return ItemField[partname];
    }
};
CSL.Engine.getField = function (mode, hash, term, form, plural, gender) {
    var ret, forms, f, pos, len, hashterm;
    ret = "";
    if ("undefined" === typeof hash[term]) {
        if (mode === CSL.STRICT) {
            throw "Error in getField: term \"" + term + "\" does not exist.";
        } else {
            return undefined;
        }
    }
    if (gender && hash[term][gender]) {
        hashterm = hash[term][gender];
    } else {
        hashterm = hash[term];
    }
    forms = [];
    if (form === "symbol") {
        forms = ["symbol", "short"];
    } else if (form === "verb-short") {
        forms = ["verb-short", "verb"];
    } else if (form !== "long") {
        forms = [form];
    }
    forms = forms.concat(["long"]);
    len = forms.length;
    for (pos = 0; pos < len; pos += 1) {
        f = forms[pos];
        if ("string" === typeof hashterm || "number" === typeof hashterm) {
            ret = hashterm;
        } else if ("undefined" !== typeof hashterm[f]) {
            if ("string" === typeof hashterm[f] || "number" === typeof hashterm[f]) {
                ret = hashterm[f];
            } else {
                if ("number" === typeof plural) {
                    ret = hashterm[f][plural];
                } else {
                    ret = hashterm[f][0];
                }
            }
            break;
        }
    }
    return ret;
};
CSL.Engine.prototype.configureTokenLists = function () {
    var dateparts_master, area, pos, token, dateparts, part, ppos, pppos, len, llen, lllen;
    dateparts_master = ["year", "month", "day"];
    len = CSL.AREAS.length;
    for (pos = 0; pos < len; pos += 1) {
        area = CSL.AREAS[pos];
        llen = this[area].tokens.length - 1;
        for (ppos = llen; ppos > -1; ppos += -1) {
            token = this[area].tokens[ppos];
            if ("date" === token.name && CSL.END === token.tokentype) {
                dateparts = [];
            }
            if ("date-part" === token.name && token.strings.name) {
                lllen = dateparts_master.length;
                for (pppos = 0; pppos < lllen; pppos += 1) {
                    part = dateparts_master[pppos];
                    if (part === token.strings.name) {
                        dateparts.push(token.strings.name);
                    }
                }
            }
            if ("date" === token.name && CSL.START === token.tokentype) {
                dateparts.reverse();
                token.dateparts = dateparts;
            }
            token.next = (ppos + 1);
            if (token.name && CSL.Node[token.name].configure) {
                CSL.Node[token.name].configure.call(token, this, ppos);
            }
        }
    }
    this.version = CSL.version;
    return this.state;
};
CSL.Engine.prototype.retrieveItems = function (ids) {
    var ret, pos, len;
    ret = [];
    for (var i = 0, ilen = ids.length; i < ilen; i += 1) {
        ret.push(this.retrieveItem("" + ids[i]));
    }
    return ret;
};
CSL.ITERATION = 0;
CSL.Engine.prototype.retrieveItem = function (id) {
    var Item, m, pos, len, mm;
    CSL.ITERATION += 1;
    if (this.registry.generate.genIDs["" + id]) {
        Item = this.registry.generate.items["" + id];
    } else {
        Item = this.sys.retrieveItem("" + id);
    }
    if (Item.page) {
        Item["page-first"] = Item.page;
        var num = "" + Item.page;
        m = num.split(/\s*(?:&|,|-)\s*/);
        if (m[0].slice(-1) !== "\\") {
            Item["page-first"] = m[0];
        }
    }
    if (this.opt.development_extensions.field_hack && Item.note) {
        m = Item.note.match(CSL.NOTE_FIELDS_REGEXP);
        if (m) {
            var names = {};
            for (pos = 0, len = m.length; pos < len; pos += 1) {
                mm = m[pos].match(CSL.NOTE_FIELD_REGEXP);
                if (!Item[mm[1]] && CSL.DATE_VARIABLES.indexOf(mm[1]) > -1) {
                    Item[mm[1]] = {raw:mm[2]};
                } else if (!Item[mm[1]] && CSL.NAME_VARIABLES.indexOf(mm[1]) > -1) {
                    if (!Item[mm[1]]) {
                        Item[mm[1]] = []
                    }
                    var lst = mm[2].split(/\s*\|\|\s*/)
                    if (lst.length === 1) {
                        Item[mm[1]].push({family:lst[0],isInstitution:true});
                    } else if (lst.length === 2) {
                        Item[mm[1]].push({family:lst[0],given:lst[1]});
                    }
                } else if (!Item[mm[1]] || mm[1] === "type") {
                    Item[mm[1]] = mm[2].replace(/^\s+/, "").replace(/\s+$/, "");
                }
                Item.note.replace(CSL.NOTE_FIELD_REGEXP, "")
            }
        }
    }
    for (var i = 1, ilen = CSL.DATE_VARIABLES.length; i < ilen; i += 1) {
        var dateobj = Item[CSL.DATE_VARIABLES[i]];
        if (dateobj) {
            if (this.opt.development_extensions.raw_date_parsing) {
                if (dateobj.raw) {
                    dateobj = this.fun.dateparser.parse(dateobj.raw);
                }
            }
            Item[CSL.DATE_VARIABLES[i]] = this.dateParseArray(dateobj);
        }
    }
    if (this.opt.development_extensions.static_statute_locator) {
        if (Item.type && ["bill","gazette","legislation","treaty"].indexOf(Item.type) > -1) {
            var elements = ["type", "title", "jurisdiction", "genre", "volume", "container-title"];
            var legislation_id = [];
            for (var i = 0, ilen = elements.length; i < ilen; i += 1) {
                var varname = elements[i];
				if (Item[varname]) {
					legislation_id.push(Item[varname]);
				}
			}
			for (var i = 0, ilen = 2; i < ilen; i += 1) {
				if (["original-date", "issued"].indexOf(varname) > -1) {
					if (Item[varname] && Item[varname].year) {
						value = Item[varname].year;
						legislation_id.push(value);
						break;
					}
				}
			}
			Item.legislation_id = legislation_id.join("::");
        }
    }
    return Item;
};
CSL.Engine.prototype.setOpt = function (token, name, value) {
    if (token.name === "style" || token.name === "cslstyle") {
        this.opt[name] = value;
    } else if (["citation", "bibliography"].indexOf(token.name) > -1) {
        this[token.name].opt[name] = value;
    } else if (["name-form", "name-delimiter", "names-delimiter"].indexOf(name) === -1) {
        token.strings[name] = value;
    }
};
CSL.Engine.prototype.fixOpt = function (token, name, localname) {
    if (["citation", "bibliography"].indexOf(token.name) > -1) {
        if (! this[token.name].opt[name] && "undefined" !== typeof this.opt[name]) {
            this[token.name].opt[name] = this.opt[name];
        }
    }
    if ("name" === token.name || "names" === token.name) {
        if ("undefined" === typeof token.strings[localname] && "undefined" !== typeof this[this.build.root].opt[name]) {
            token.strings[localname] = this[this.build.root].opt[name];
        }
    }
};
CSL.Engine.prototype.remapSectionVariable = function (inputList) {
    for (var i = 0, ilen = inputList.length; i < ilen; i += 1) {
        var Item = inputList[i][0];
        var item = inputList[i][1];
        var section_label_count = 0;
        var later_label = false;
        var value = false;
        if (["bill","gazette","legislation","treaty"].indexOf(Item.type) > -1) {
            if (!Item.section
                && this.opt.development_extensions.clobber_locator_if_no_statute_section) {
                item.locator = undefined;
                item.label = undefined;
            } else if (Item.section
                       && item
                       && this.opt.development_extensions.static_statute_locator) {
                value = "" + Item.section;
                later_label = item.label;
                if (value) {
                    var splt = value.split(/\s+/);
                    if (CSL.STATUTE_SUBDIV_STRINGS[splt[0]]) {
                        item.label = CSL.STATUTE_SUBDIV_STRINGS[splt[0]];
                    } else {
					    item.label = "section";
                        value = "sec. " + value;
                    }
                }
            } else if (item
                      && item.locator
                      &&  this.opt.development_extensions.static_statute_locator) {
                var splt = item.locator.split(/\s+/);
                if (CSL.STATUTE_SUBDIV_STRINGS[splt[0]]) {
                    item.label = CSL.STATUTE_SUBDIV_STRINGS[splt[0]];
                    item.locator = splt.slice(1).join(" ");
                }
                if ((!item.label || item.label === "page") && item.locator && item.locator.match(/^[0-9].*/)) {
                    item.locator = ", " + item.locator;
                }
            }
            if (value) {
			    if (!later_label) {
				    later_label = item.label;
			    }
                var m = value.match(CSL.STATUTE_SUBDIV_GROUPED_REGEX);
                item.section_label_count = m.length;
                var locator = "";
                var labelstr = "";
                if (item.locator) {
                    locator = item.locator;
                    var firstword = item.locator.split(/\s/)[0];
                    if (item.label === later_label && firstword && firstword.match(/^[0-9]/)) {
                        labelstr = ", " + CSL.STATUTE_SUBDIV_STRINGS_REVERSE[later_label];
                    } else if (item.label !== later_label && firstword && firstword.match(/^[0-9]/)) {
                        labelstr = " " + CSL.STATUTE_SUBDIV_STRINGS_REVERSE[later_label] + " ";
                    } else if (CSL.STATUTE_SUBDIV_STRINGS[firstword]) {
                        labelstr = " ";
                    }
                    locator = labelstr + locator;
                    if (locator.slice(0,1) === "&") {
                        locator = " " + locator;
                    }
                    value = value + locator;
                }
                var m = value.match(CSL.STATUTE_SUBDIV_GROUPED_REGEX);
                if (m) {
                    var splt = value.split(CSL.STATUTE_SUBDIV_PLAIN_REGEX);
                    if (splt.length > 1) {
                        var lst = [];
                        lst.push(splt[1].replace(/\s*$/, "").replace(/^\s*/, ""));
                        var has_repeat_label = false;
                        var has_sublabel = false;
                        for (var j=2, jlen=splt.length; j < jlen; j += 1) {
                            var subdiv = m[j - 1].replace(/^\s*/, "");
                            var fullsubdiv = CSL.STATUTE_SUBDIV_STRINGS[subdiv];
                            if (fullsubdiv === item.label) {
                                has_repeat_label = true;
                            } else {
                                has_sublabel = true;
                            }
                            lst.push(subdiv);
                            lst.push(splt[j].replace(/\s*$/, "").replace(/^\s*/, ""));
                        }
                        for (var j=lst.length - 2; j > 0; j += -2) {
                            if (!has_sublabel) {
                                lst = lst.slice(0,j).concat(lst.slice(j + 1));
                            }
                        }
                        value = lst.join(" ");
                        if (!has_sublabel && has_repeat_label) {
                            item.force_pluralism = 1;
                        } else {
                            item.force_pluralism = 0;
                        }
                    }
                }
                item.locator = value;
            }
        }
    }
}
CSL.Engine.prototype.setNumberLabels = function (Item) {
    if (Item.number
        && ["bill", "gazette", "legislation", "treaty"].indexOf(Item.type) > -1
        && this.opt.development_extensions.static_statute_locator
        && !this.tmp.shadow_numbers["number"]) {
        this.tmp.shadow_numbers["number"] = {};
        this.tmp.shadow_numbers["number"].values = [];
        this.tmp.shadow_numbers["number"].plural = 0;
        this.tmp.shadow_numbers["number"].numeric = false;
        this.tmp.shadow_numbers["number"].label = false;
        var value = "" + Item.number;
        value = value.replace("\\", "", "g");
        var firstword = value.split(/\s/)[0];
        var firstlabel = CSL.STATUTE_SUBDIV_STRINGS[firstword];
        if (firstlabel) {
            var m = value.match(CSL.STATUTE_SUBDIV_GROUPED_REGEX);
            var splt = value.split(CSL.STATUTE_SUBDIV_PLAIN_REGEX);
            if (splt.length > 1) {
                var lst = [];
                for (var j=1, jlen=splt.length; j < jlen; j += 1) {
                    var subdiv = m[j - 1].replace(/^\s*/, "");
                    lst.push(subdiv.replace("sec.", "Sec.").replace("ch.", "Ch."));
                    lst.push(splt[j].replace(/\s*$/, "").replace(/^\s*/, ""));
                }
                value = lst.join(" ");
            } else {
                value = splt[0];
            }
            this.tmp.shadow_numbers["number"].values.push(["Blob", value, false]);
            this.tmp.shadow_numbers["number"].numeric = false;
        } else {
            this.tmp.shadow_numbers["number"].values.push(["Blob", value, false]);
            this.tmp.shadow_numbers["number"].numeric = true;
        }
    }
}
CSL.substituteOne = function (template) {
    return function (state, list) {
        if (!list) {
            return "";
        } else {
            return template.replace("%%STRING%%", list);
        }
    };
};
CSL.substituteTwo = function (template) {
    return function (param) {
        var template2 = template.replace("%%PARAM%%", param);
        return function (state, list) {
            if (!list) {
                return "";
            } else {
                return template2.replace("%%STRING%%", list);
            }
        };
    };
};
CSL.Mode = function (mode) {
    var decorations, params, param, func, val, args;
    decorations = {};
    params = CSL.Output.Formats[mode];
    for (param in params) {
        if (true) {
            if ("@" !== param.slice(0, 1)) {
                decorations[param] = params[param];
                continue;
            }
            func = false;
            val = params[param];
            args = param.split('/');
            if (typeof val === "string" && val.indexOf("%%STRING%%") > -1)  {
                if (val.indexOf("%%PARAM%%") > -1) {
                    func = CSL.substituteTwo(val);
                } else {
                    func = CSL.substituteOne(val);
                }
            } else if (typeof val === "boolean" && !val) {
                func = CSL.Output.Formatters.passthrough;
            } else if (typeof val === "function") {
                func = val;
            } else {
                throw "CSL.Compiler: Bad " + mode + " config entry for " + param + ": " + val;
            }
            if (args.length === 1) {
                decorations[args[0]] = func;
            } else if (args.length === 2) {
                if (!decorations[args[0]]) {
                    decorations[args[0]] = {};
                }
                decorations[args[0]][args[1]] = func;
            }
        }
    }
    return decorations;
};
CSL.setDecorations = function (state, attributes) {
    var ret, key, pos;
    ret = [];
    for (pos in CSL.FORMAT_KEY_SEQUENCE) {
        if (true) {
            key = CSL.FORMAT_KEY_SEQUENCE[pos];
            if (attributes[key]) {
                ret.push([key, attributes[key]]);
                delete attributes[key];
            }
        }
    }
    return ret;
};
CSL.Engine.prototype.normalDecorIsOrphan = function (blob, params) {
    if (params[1] === "normal") {
        var use_param = false;
        var all_the_decor;
        if (this.tmp.area === "citation") {
            all_the_decor = [this.citation.opt.layout_decorations].concat(blob.alldecor);
        } else {
            all_the_decor = blob.alldecor;
        }
        for (var k = all_the_decor.length - 1; k > -1; k += -1) {
            for (var n = all_the_decor[k].length - 1; n > -1; n += -1) {
                if (all_the_decor[k][n][0] === params[0]) {
                    if (all_the_decor[k][n][1] !== "normal") {
                        use_param = true;
                    }
                }
            }
        }
        if (!use_param) {
            return true;
        }
    }
    return false;
};
CSL.Engine.prototype.setOutputFormat = function (mode) {
    this.opt.mode = mode;
    this.fun.decorate = CSL.Mode(mode);
    if (!this.output[mode]) {
        this.output[mode] = {};
        this.output[mode].tmp = {};
    }
};
CSL.Engine.prototype.setLangTagsForCslSort = function (tags) {
    var i, ilen;
    this.opt['locale-sort'] = [];
    for (i = 0, ilen = tags.length; i < ilen; i += 1) {
        this.opt['locale-sort'].push(tags[i]);
    }
};
CSL.Engine.prototype.setLangTagsForCslTransliteration = function (tags) {
    var i, ilen;
    this.opt['locale-translit'] = [];    
    for (i = 0, ilen = tags.length; i < ilen; i += 1) {
        this.opt['locale-translit'].push(tags[i]);
    }
};
CSL.Engine.prototype.setLangTagsForCslTranslation = function (tags) {
    var i, ilen;
    this.opt['locale-translat'] = [];
    for (i = 0, ilen = tags.length; i < ilen; i += 1) {
        this.opt['locale-translat'].push(tags[i]);
    }
};
CSL.Engine.prototype.setLangPrefsForCites = function (params) {
	var opt = this.opt['cite-lang-prefs'];
	for (var segment in params) {
        var supplements = [];
        while (params[segment].length > 1) {
            supplements.push(params[segment].pop());
        }
        var sortval = {orig:1,translit:2,translat:3};
        if (supplements.length === 2 && sortval[supplements[0]] < sortval[supplements[1]]) {
            supplements.reverse();
        }
        while (supplements.length) {
            params[segment].push(supplements.pop());
        }
		var lst = opt[segment];
		while (lst.length) {
			lst.pop();
		}
		for (var i = 0, ilen = params[segment].length; i < ilen; i += 1) {
			lst.push(params[segment][i]);
		}
	}
};
CSL.Engine.prototype.setAutoVietnameseNamesOption = function (arg) {
    if (arg) {
        this.opt["auto-vietnamese-names"] = true;
    } else {
        this.opt["auto-vietnamese-names"] = false;
    }
};
CSL.Engine.prototype.setAbbreviations = function (arg) {
	if (this.sys.setAbbreviations) {
		this.sys.setAbbreviations(arg);
	}
};
CSL.Engine.prototype.setEnglishLocaleEscapes = function (arg) {
    if ("string" === typeof arg) {
        arg = arg.split(/\s+,\s+/);
    }
    if (!arg || !arg.length) {
        arg = [];
    }
    for (var i = 0, ilen = arg.length; i < ilen; i += 1) {
	    if (this.opt.english_locale_escapes.indexOf(arg[i]) === -1) {
            this.opt.english_locale_escapes.push(arg[i]);
        }
    }
};
CSL.Engine.Opt = function () {
    this.has_disambiguate = false;
    this.mode = "html";
    this.dates = {};
    this["locale-sort"] = [];
    this["locale-translit"] = [];
    this["locale-translat"] = [];
    this["default-locale"] = [];
    this["noun-genders"] = {};
    this.update_mode = CSL.NONE;
    this.bib_mode = CSL.NONE;
    this.sort_citations = false;
    this["et-al-min"] = 0;
    this["et-al-use-first"] = 1;
    this["et-al-use-last"] = false;
    this["et-al-subsequent-min"] = false;
    this["et-al-subsequent-use-first"] = false;
    this["demote-non-dropping-particle"] = "display-and-sort";
    this["parse-names"] = true;
    this.citation_number_slug = false;
    this.max_number_of_names = 0;
    this.trigraph = "Aaaa00:AaAa00:AaAA00:AAAA00";
    this.english_locale_escapes = [];
    this.development_extensions = {};
    this.development_extensions.field_hack = true;
    this.development_extensions.locator_date_and_revision = true;
    this.development_extensions.locator_parsing_for_plurals = true;
    this.development_extensions.locator_label_parse = true;
    this.development_extensions.raw_date_parsing = true;
    this.development_extensions.clean_up_csl_flaws = true;
    this.development_extensions.flip_parentheses_to_braces = true;
    this.development_extensions.jurisdiction_subfield = true;
    this.development_extensions.static_statute_locator = false;
    this.development_extensions.csl_reverse_lookup_support = true;
    this.development_extensions.clobber_locator_if_no_statute_section = false;
    this.development_extensions.wrap_url_and_doi = false;
    this.nodenames = [];
    this.gender = {};
	this['cite-lang-prefs'] = {
		persons:['orig'],
		institutions:['orig'],
		titles:['orig','translat'],
		publishers:['orig'],
		places:['orig']
	}
};
CSL.Engine.Tmp = function () {
    this.names_max = new CSL.Stack();
    this.names_base = new CSL.Stack();
    this.givens_base = new CSL.Stack();
    this.value = [];
    this.namepart_decorations = {};
    this.namepart_type = false;
    this.area = "citation";
    this.root = "citation";
    this.extension = "";
    this.can_substitute = new CSL.Stack(0, CSL.LITERAL);
    this.element_rendered_ok = false;
    this.element_trace = new CSL.Stack("style");
    this.nameset_counter = 0;
    this.group_context = new CSL.Stack([false, false, false], CSL.LITERAL);
    this.term_predecessor = false;
    this.jump = new CSL.Stack(0, CSL.LITERAL);
    this.decorations = new CSL.Stack();
    this.tokenstore_stack = new CSL.Stack();
    this.last_suffix_used = "";
    this.last_names_used = [];
    this.last_years_used = [];
    this.years_used = [];
    this.names_used = [];
    this.taintedItemIDs = {};
    this.taintedCitationIDs = false;
    this.initialize_with = new CSL.Stack();
    this.disambig_request = false;
    this["name-as-sort-order"] = false;
    this.suppress_decorations = false;
    this.disambig_settings = new CSL.AmbigConfig();
    this.bib_sort_keys = [];
    this.prefix = new CSL.Stack("", CSL.LITERAL);
    this.suffix = new CSL.Stack("", CSL.LITERAL);
    this.delimiter = new CSL.Stack("", CSL.LITERAL);
    this.cite_locales = [];
    this.cite_affixes = false;
    this.strip_periods = 0;
    this.shadow_numbers = {};
};
CSL.Engine.Fun = function () {
    this.match = new  CSL.Util.Match();
    this.suffixator = new CSL.Util.Suffixator(CSL.SUFFIX_CHARS);
    this.romanizer = new CSL.Util.Romanizer();
    this.ordinalizer = new CSL.Util.Ordinalizer();
    this.long_ordinalizer = new CSL.Util.LongOrdinalizer();
};
CSL.Engine.Build = function () {
    this["alternate-term"] = false;
    this.in_bibliography = false;
    this.in_style = false;
    this.skip = false;
    this.postponed_macro = false;
    this.layout_flag = false;
    this.name = false;
    this.form = false;
    this.term = false;
    this.macro = {};
    this.macro_stack = [];
    this.text = false;
    this.lang = false;
    this.area = "citation";
    this.root = "citation";
    this.extension = "";
    this.substitute_level = new CSL.Stack(0, CSL.LITERAL);
    this.names_level = 0;
    this.render_nesting_level = 0;
    this.render_seen = false;
};
CSL.Engine.Configure = function () {
    this.fail = [];
    this.succeed = [];
};
CSL.Engine.Citation = function (state) {
    this.opt = {};
    this.tokens = [];
    this.srt = new CSL.Registry.Comparifier(state, "citation_sort");
    this.opt.collapse = [];
    this.opt["disambiguate-add-names"] = false;
    this.opt["disambiguate-add-givenname"] = false;
    this.opt["disambiguate-add-year-suffix"] = false;
    this.opt["givenname-disambiguation-rule"] = "none";
    this.opt["near-note-distance"] = 5;
    this.opt.topdecor = [];
    this.opt.layout_decorations = [];
    this.opt.layout_prefix = "";
    this.opt.layout_suffix = "";
    this.opt.layout_delimiter = "";
};
CSL.Engine.Bibliography = function () {
    this.opt = {};
    this.tokens = [];
    this.opt.collapse = [];
    this.opt.topdecor = [];
    this.opt.layout_decorations = [];
    this.opt.layout_prefix = "";
    this.opt.layout_suffix = "";
    this.opt.layout_delimiter = "";
    this.opt["line-spacing"] = 1;
    this.opt["entry-spacing"] = 1;
};
CSL.Engine.BibliographySort = function () {
    this.tokens = [];
    this.opt = {};
    this.opt.sort_directions = [];
    this.keys = [];
    this.opt.topdecor = [];
};
CSL.Engine.CitationSort = function () {
    this.tokens = [];
    this.opt = {};
    this.opt.sort_directions = [];
    this.keys = [];
    this.opt.topdecor = [];
};
CSL.Engine.prototype.setCitationId = function (citation, force) {
    var ret, id, direction;
    ret = false;
    if (!citation.citationID || force) {
        id = Math.floor(Math.random() * 100000000000000);
        while (true) {
            direction = 0;
            if (!this.registry.citationreg.citationById[id]) {
                citation.citationID = id.toString(32);
                break;
            } else if (!direction && id < 50000000000000) {
                direction = 1;
            } else {
                direction = -1;
            }
            if (direction === 1) {
                id += 1;
            } else {
                id += -1;
            }
        }
        ret = "" + id;
    }
    this.registry.citationreg.citationById[citation.citationID] = citation;
    return ret;
};
CSL.Engine.prototype.restoreProcessorState = function (citations) {
    var i, ilen, j, jlen, item, Item, newitem, citationList, itemList, sortedItems;
    citationList = [];
    itemList = [];
    if (!citations) {
        citations = [];
    }
    var indexNumbers = [];
    var citationIds = {};
    for (i = 0, ilen = citations.length; i < ilen; i += 1) {
        if (citationIds[citations[i].citationID]) {
            this.setCitationId(citations[i], true);
        }
        citationIds[citations[i].citationID] = true;
        indexNumbers.push(citations[i].properties.index);
    }
    var oldCitations = citations.slice();
    oldCitations.sort(
        function (a,b) {
            if (a.properties.index < b.properties.index) {
                return -1;
            } else if (a.properties.index > b.properties.index) {
                return 1;
            } else {
                return 0;
            }
        }
    );
    for (i = 0, ilen = oldCitations.length; i < ilen; i += 1) {
        oldCitations[i].properties.index = i;
    }
    for (i = 0, ilen = oldCitations.length; i < ilen; i += 1) {
        sortedItems = [];
        for (j = 0, jlen = oldCitations[i].citationItems.length; j < jlen; j += 1) {
            item = oldCitations[i].citationItems[j];
            if ("undefined" === typeof item.sortkeys) {
                item.sortkeys = [];
            }
            Item = this.retrieveItem("" + item.id);
            newitem = [Item, item];
            sortedItems.push(newitem);
            oldCitations[i].citationItems[j].item = Item;
            itemList.push("" + item.id);
        }
        if (!oldCitations[i].properties.unsorted) {
            sortedItems.sort(this.citation.srt.compareCompositeKeys);
        }
        oldCitations[i].sortedItems = sortedItems;
        this.registry.citationreg.citationById[oldCitations[i].citationID] = oldCitations[i];
    }
    this.updateItems(itemList);
    for (i = 0, ilen = citations.length; i < ilen; i += 1) {
        citationList.push(["" + citations[i].citationID, citations[i].properties.noteIndex]);
    }
    var ret = [];
    if (citations && citations.length) {
        ret = this.processCitationCluster(citations[0], [], citationList.slice(1));
    } else {
        this.registry = new CSL.Registry(this);
        this.tmp = new CSL.Engine.Tmp();
        this.disambiguate = new CSL.Disambiguation(this);
    }
    return ret;
};
CSL.Engine.prototype.updateItems = function (idList, nosort) {
    var debug = false;
    var oldArea = this.tmp.area;
    this.registry.init(idList);
    this.registry.dodeletes(this.registry.myhash);
    this.registry.doinserts(this.registry.mylist);
    this.registry.dorefreshes();
    this.registry.rebuildlist();
    this.registry.setsortkeys();
    this.registry.setdisambigs();
    if (!nosort) {
        this.registry.sorttokens();
    }
    this.registry.renumber();
    this.tmp.area = oldArea;
    return this.registry.getSortedIds();
};
CSL.Engine.prototype.updateUncitedItems = function (idList, nosort) {
    var debug = false;
    this.registry.init(idList, true);
    this.registry.doinserts(this.registry.mylist);
    this.registry.douncited();
    this.registry.rebuildlist();
    this.registry.setsortkeys();
    this.registry.setdisambigs();
    if (!nosort) {
        this.registry.sorttokens();
    }
    this.registry.renumber();
    return this.registry.getSortedIds();
};
CSL.Engine.prototype.getCitationLabel = function (Item) {
    var label = "";
    var params = this.getTrigraphParams();
    var config = params[0];
    var myname = this.getTerm("reference", "short", 0);
    myname = myname.replace(".", "");
    myname = myname.slice(0, 1).toUpperCase() + myname.slice(1);
    for (var i = 0, ilen = CSL.CREATORS.length; i < ilen; i += 1) {
        var n = CSL.CREATORS[i];
        if (Item[n]) {
            var names = Item[n];
            if (names.length > params.length) {
                config = params[params.length - 1];
            } else {
                config = params[names.length - 1];
            }
            for (var j = 0, jlen = names.length; j < jlen; j += 1) {
                if (j === config.authors.length) {
                    break;
                }
                var res = this.nameOutput.getName(names[j], "locale-translit", true);
                var name = res.name;
                if (name && name.family) {
                    myname = name.family;
                    myname = myname.replace(/^([ \'\u2019a-z]+\s+)/, "");
                } else if (name && name.literal) {
                    myname = name.literal;
                }
                var m = myname.toLowerCase().match(/^(a\s+|the\s+|an\s+)/);
                if (m) {
                    myname = myname.slice(m[1].length);
                }
                myname = myname.replace(CSL.ROMANESQUE_NOT_REGEXP, "", "g");
                if (!myname) {
                    break;
                }
                myname = myname.slice(0, config.authors[j]);
                if (myname.length > 1) {
                    myname = myname.slice(0, 1).toUpperCase() + myname.slice(1).toLowerCase();
                } else if (myname.length === 1) {
                    myname = myname.toUpperCase();
                }
                label += myname;
            }
            break;
        }
    }
    var year = "0000";
    if (Item.issued) {
        if (Item.issued.year) {
            year = "" + Item.issued.year;
        }
    }
    year = year.slice((config.year * -1));
    label = label + year;
    return label;
};
CSL.Engine.prototype.getTrigraphParams = function () {
    var params = [];
    var ilst = this.opt.trigraph.split(":");
    if (!this.opt.trigraph || this.opt.trigraph[0] !== "A") {
        throw "Bad trigraph definition: "+this.opt.trigraph;
    }
    for (var i = 0, ilen = ilst.length; i < ilen; i += 1) {
        var str = ilst[i];
        var config = {authors:[], year:0};
        for (var j = 0, jlen = str.length; j < jlen; j += 1) {
            switch (str[j]) {
            case "A":
                config.authors.push(1);
                break;
            case "a":
                config.authors[config.authors.length - 1] += 1;
                break;
            case "0":
                config.year += 1;
                break;
            default:
                throw "Invalid character in trigraph definition: "+this.opt.trigraph;
            }
        }
        params.push(config);
    }
    return params;
};
CSL.Engine.prototype.makeBibliography = function (bibsection) {
    var debug, ret, params, maxoffset, item, len, pos, tok, tokk, tokkk, entry_ids, entry_strings, bibliography_errors;
    debug = false;
    if (!this.bibliography.tokens.length) {
        return false;
    }
    if ("string" === typeof bibsection) {
        this.opt.citation_number_slug = bibsection;
        bibsection = false;
    }
    ret = CSL.getBibliographyEntries.call(this, bibsection);
    entry_ids = ret[0];
    entry_strings = ret[1];
    var done = ret[2];
    params = {
        "maxoffset": 0,
        "entryspacing": this.bibliography.opt["entry-spacing"],
        "linespacing": this.bibliography.opt["line-spacing"],
        "second-field-align": false,
        "entry_ids": entry_ids,
        "bibliography_errors": this.tmp.bibliography_errors.slice(),
        "done": done
    };
    if (this.bibliography.opt["second-field-align"]) {
        params["second-field-align"] = this.bibliography.opt["second-field-align"];
    }
    maxoffset = 0;
    len = this.registry.reflist.length;
    for (pos = 0; pos < len; pos += 1) {
        item = this.registry.reflist[pos];
        if (item.offset > params.maxoffset) {
            params.maxoffset = item.offset;
        }
    }
    if (this.bibliography.opt.hangingindent) {
        params.hangingindent = this.bibliography.opt.hangingindent;
    }
    params.bibstart = this.fun.decorate.bibstart;
    params.bibend = this.fun.decorate.bibend;
    this.opt.citation_number_slug = false;
    return [params, entry_strings];
};
CSL.getBibliographyEntries = function (bibsection) {
    var ret, input, include, anymatch, allmatch, bib_entry, res, len, pos, item, llen, ppos, spec, lllen, pppos, bib_layout, topblobs, all_item_ids, entry_item_ids, debug, collapse_parallel, i, ilen, siblings, skips, sortedItems, eyetem, chr, entry_item_data;
    ret = [];
    entry_item_data = [];
    this.tmp.area = "bibliography";
    this.tmp.last_rendered_name = false;
    this.tmp.bibliography_errors = [];
    this.tmp.bibliography_pos = 0;
    if (bibsection && bibsection.page_start && bibsection.page_length) {
        input = this.registry.getSortedIds();        
    } else {
        var originalIDs = this.registry.getSortedIds();
        var newIDs = [];
        this.registry.generate.items = {};
        for (var id  in this.registry.generate.origIDs) {
            var rule = this.registry.generate.origIDs[id];
            item = this.retrieveItem(id);
            var clonedItem = {};
            for (var key in item) {
                clonedItem[key] = item[key];
            }
            clonedItem.type = rule.to;
            for (i = 0, ilen = rule.triggers.length; i < ilen; i += 1) {
                if (clonedItem[rule.triggers[i]]) {
                    delete clonedItem[rule.triggers[i]];
                }
            }
            var newID = clonedItem.id + ":gen";
            clonedItem.id = newID;
            this.registry.generate.items[clonedItem.id] = clonedItem;
            newIDs.push(newID);
        }
        if (newIDs.length) {
            this.updateItems(originalIDs.concat(newIDs));
        }
        input = this.retrieveItems(this.registry.getSortedIds());
    }
    this.tmp.disambig_override = true;
    function eval_string(a, b) {
        if (a === b) {
            return true;
        }
        return false;
    }
    function eval_list(a, lst) {
        lllen = lst.length;
        for (pppos = 0; pppos < lllen; pppos += 1) {
            if (eval_string(a, lst[pppos])) {
                return true;
            }
        }
        return false;
    }
    function eval_spec(a, b) {
        if ((a === "none" || !a) && !b) {
            return true;
        }
        if ("string" === typeof b) {
            return eval_string(a, b);
        } else if (!b) {
            return false;
        } else {
            return eval_list(a, b);
        }
    }
    skips = {};
    if (bibsection && bibsection.page_start && bibsection.page_length) {
        var page_item_count = 0;
        if (bibsection.page_start !== true) {
            for (var i = 0, ilen = input.length; i < ilen; i += 1) {
                skips[input[i]] = true;
                if (bibsection.page_start == input[i]) {
                    break;
                }
            }
        }
    }
    processed_item_ids = [];
    for (var i = 0, ilen = input.length; i < ilen; i += 1) {
        if (bibsection && bibsection.page_start && bibsection.page_length) {
            if (skips[input[i]]) {
                continue;
            }
            item = this.retrieveItem(input[i]);
            if (page_item_count === bibsection.page_length) {
                break;
            }
        } else {
            item = input[i];
            if (skips[item.id]) {
                continue;
            }
        }
        if (bibsection) {
            include = true;
            if (bibsection.include) {
                include = false;
                for (j = 0, jlen = bibsection.include.length; j < jlen; j += 1) {
                    spec = bibsection.include[j];
                    if (eval_spec(spec.value, item[spec.field])) {
                        include = true;
                        break;
                    }
                }
            } else if (bibsection.exclude) {
                anymatch = false;
                for (j = 0, jlen = bibsection.exclude.length; j < jlen; j += 1) {
                    spec = bibsection.exclude[j];
                    if (eval_spec(spec.value, item[spec.field])) {
                        anymatch = true;
                        break;
                    }
                }
                if (anymatch) {
                    include = false;
                }
            } else if (bibsection.select) {
                include = false;
                allmatch = true;
                for (j = 0, jlen = bibsection.select.length; j < jlen; j += 1) {
                    spec = bibsection.select[j];
                    if (!eval_spec(spec.value, item[spec.field])) {
                        allmatch = false;
                    }
                }
                if (allmatch) {
                    include = true;
                }
            }
            if (bibsection.quash) {
                allmatch = true;
                for (j = 0, jlen = bibsection.quash.length; j < jlen; j += 1) {
                    spec = bibsection.quash[j];
                    if (!eval_spec(spec.value, item[spec.field])) {
                        allmatch = false;
                    }
                }
                if (allmatch) {
                    include = false;
                }
            }
            if (!include) {
                continue;
            }
        }
        bib_entry = new CSL.Token("group", CSL.START);
        bib_entry.decorations = [["@bibliography", "entry"]].concat(this[this.build.area].opt.layout_decorations);
        this.output.startTag("bib_entry", bib_entry);
        this.output.current.value().item_id = item.id;
        sortedItems = [[{id: "" + item.id}, item]];
        entry_item_ids = [];
        if (this.registry.registry[item.id].master 
            && !(bibsection && bibsection.page_start && bibsection.page_length)) {
            collapse_parallel = true;
            this.parallel.StartCitation(sortedItems);
            this.output.queue[0].strings.delimiter = ", ";
            this.tmp.term_predecessor = false;
            entry_item_ids.push("" + CSL.getCite.call(this, item));
            skips[item.id] = true;
            siblings = this.registry.registry[item.id].siblings;
            for (var j = 0, jlen = siblings.length; j < jlen; j += 1) {
                var k = this.registry.registry[item.id].siblings[j];
                eyetem = this.retrieveItem(k);
                entry_item_ids.push("" + CSL.getCite.call(this, eyetem));
                skips[eyetem.id] = true;
            }
            this.parallel.ComposeSet();
            this.parallel.PruneOutputQueue();
        } else if (!this.registry.registry[item.id].siblings) {
            this.parallel.StartCitation(sortedItems);
            this.tmp.term_predecessor = false;
            entry_item_ids.push("" + CSL.getCite.call(this, item));
            if (bibsection && bibsection.page_start && bibsection.page_length) {
                page_item_count += 1;
            }
        }
        entry_item_data.push("");
        this.tmp.bibliography_pos += 1;
        processed_item_ids.push(entry_item_ids);
        this.output.endTag("bib_entry");
        if (this.output.queue[0].blobs.length && this.output.queue[0].blobs[0].blobs.length) {
            if (collapse_parallel || !this.output.queue[0].blobs[0].blobs[0].strings) {
                topblobs = this.output.queue[0].blobs;
                collapse_parallel = false;
            } else {
                topblobs = this.output.queue[0].blobs[0].blobs;
            }
            for (var j  = topblobs.length - 1; j > -1; j += -1) {
                if (topblobs[j].blobs && topblobs[j].blobs.length !== 0) {
                    chr = this.bibliography.opt.layout_suffix.slice(0, 1);
                    if (chr && topblobs[j].strings.suffix.slice(-1) === chr) {
                        topblobs[j].strings.suffix = topblobs[j].strings.suffix.slice(0, -1);
                    }
                    topblobs[j].strings.suffix += this.bibliography.opt.layout_suffix;
                    break;
                }
            }
            topblobs[0].strings.prefix = this.bibliography.opt.layout_prefix + topblobs[0].strings.prefix;
        }
        CSL.Output.Queue.purgeEmptyBlobs(this.output.queue);
        CSL.Output.Queue.adjustPunctuation(this, this.output.queue);
        res = this.output.string(this, this.output.queue)[0];
        if (!res) {
            res = "\n[CSL STYLE ERROR: reference with no printed form.]\n";
        }
        ret.push(res);
    }
    var done = false;
    if (bibsection && bibsection.page_start && bibsection.page_length) {
        var last_expected_id = input.slice(-1)[0];
        var last_seen_id = processed_item_ids.slice(-1)[0];
        if (!last_expected_id || !last_seen_id || last_expected_id == last_seen_id) {
            done = true;
        }
    } else {
        if (newIDs.length) {
            this.updateItems(originalIDs);
        }
    }
    this.tmp.disambig_override = false;
    return [processed_item_ids, ret, done];
};
CSL.Engine.prototype.previewCitationCluster = function (citation, citationsPre, citationsPost, newMode) {
    var oldMode = this.opt.mode;
    this.setOutputFormat(newMode);
    var ret = this.processCitationCluster(citation, citationsPre, citationsPost, CSL.PREVIEW);
    this.setOutputFormat(oldMode);
    return ret[1];
};
CSL.Engine.prototype.appendCitationCluster = function (citation) {
    var citationsPre = [];
    var len = this.registry.citationreg.citationByIndex.length;
    for (var pos = 0; pos < len; pos += 1) {
        var c = this.registry.citationreg.citationByIndex[pos];
        citationsPre.push(["" + c.citationID, c.properties.noteIndex]);
    }
    return this.processCitationCluster(citation, citationsPre, [])[1];
};
CSL.Engine.prototype.processCitationCluster = function (citation, citationsPre, citationsPost, flag) {
    var c, i, ilen, j, jlen, k, klen, n, nlen, key, Item, item, noteCitations, textCitations;
    this.debug = false;
    this.tmp.citation_errors = [];
    var return_data = {"bibchange": false};
    this.setCitationId(citation);
    var oldCitationList;
    var oldItemList;
    var oldAmbigs;
    if (flag === CSL.PREVIEW) {
        oldCitationList = this.registry.citationreg.citationByIndex.slice();
        oldItemList = this.registry.reflist.slice();
        var newCitationList = citationsPre.concat([["" + citation.citationID, citation.properties.noteIndex]]).concat(citationsPost);
        var newItemIds = {};
        var newItemIdsList = [];
        for (i = 0, ilen = newCitationList.length; i < ilen; i += 1) {
            c = this.registry.citationreg.citationById[newCitationList[i][0]];
            for (j = 0, jlen = c.citationItems.length; j < jlen; j += 1) {
                newItemIds[c.citationItems[j].id] = true;
                newItemIdsList.push("" + c.citationItems[j].id);
            }
        }
        oldAmbigs = {};
        for (i = 0, ilen = oldItemList.length; i < ilen; i += 1) {
            if (!newItemIds[oldItemList[i].id]) {
                var oldAkey = this.registry.registry[oldItemList[i].id].ambig;
                var ids = this.registry.ambigcites[oldAkey];
                if (ids) {
                    for (j = 0, jlen = ids.length; j < jlen; j += 1) {
                        oldAmbigs[ids[j]] = CSL.cloneAmbigConfig(this.registry.registry[ids[j]].disambig);
                    }
                }
            }
        }
    }
    this.tmp.taintedCitationIDs = {};
    var sortedItems = [];
    for (i = 0, ilen = citation.citationItems.length; i < ilen; i += 1) {
        var item = {};
        for (var key in citation.citationItems[i]) {
            item[key] = citation.citationItems[i][key];
        }
        Item = this.retrieveItem("" + item.id);
        this.remapSectionVariable([[Item,item]]);
        if (this.opt.development_extensions.locator_date_and_revision) {
            if (item.locator) {
                item.locator = "" + item.locator;
                var idx = item.locator.indexOf("|");
                if (idx > -1) {
                    var raw_locator = item.locator;
                    item.locator = raw_locator.slice(0, idx);
                    raw_locator = raw_locator.slice(idx + 1);
                    var m = raw_locator.match(/^([0-9]{4}-[0-9]{2}-[0-9]{2}).*/);
                    if (m) {
                        item["locator-date"] = this.fun.dateparser.parse(m[1]);
                        raw_locator = raw_locator.slice(m[1].length);
                    }
                    item["locator-revision"] = raw_locator.replace(/^\s+/, "").replace(/\s+$/, "");
                }
            }
        }
        if (this.opt.development_extensions.locator_label_parse) {
            if (item.locator && ["bill","gazette","legislation","treaty"].indexOf(Item.type) === -1 && (!item.label || item.label === 'page')) {
                var m = CSL.LOCATOR_LABELS_REGEXP.exec(item.locator);
                if (m) {
                    item.label = CSL.LOCATOR_LABELS_MAP[m[2]];
                    item.locator = m[3];
                }
            }
        }
        var newitem = [Item, item];
        sortedItems.push(newitem);
        citation.citationItems[i].item = Item;
    }
    citation.sortedItems = sortedItems;
    var citationByIndex = [];
    for (i = 0, ilen = citationsPre.length; i < ilen; i += 1) {
        c = citationsPre[i];
        this.registry.citationreg.citationById[c[0]].properties.noteIndex = c[1];
        citationByIndex.push(this.registry.citationreg.citationById[c[0]]);
    }
    citationByIndex.push(citation);
    for (i = 0, ilen = citationsPost.length; i < ilen; i += 1) {
        c = citationsPost[i];
        this.registry.citationreg.citationById[c[0]].properties.noteIndex = c[1];
        citationByIndex.push(this.registry.citationreg.citationById[c[0]]);
    }
    this.registry.citationreg.citationByIndex = citationByIndex;
    this.registry.citationreg.citationsByItemId = {};
    if (this.opt.update_mode === CSL.POSITION) {
        textCitations = [];
        noteCitations = [];
        var citationsInNote = {};
    }
    var update_items = [];
    for (i = 0, ilen = citationByIndex.length; i < ilen; i += 1) {
        citationByIndex[i].properties.index = i;
        for (j = 0, jlen = citationByIndex[i].sortedItems.length; j < jlen; j += 1) {
            item = citationByIndex[i].sortedItems[j];
            if (!this.registry.citationreg.citationsByItemId[item[1].id]) {
                this.registry.citationreg.citationsByItemId[item[1].id] = [];
                update_items.push("" + item[1].id);
            }
            if (this.registry.citationreg.citationsByItemId[item[1].id].indexOf(citationByIndex[i]) === -1) {
                this.registry.citationreg.citationsByItemId[item[1].id].push(citationByIndex[i]);
            }
        }
        if (this.opt.update_mode === CSL.POSITION) {
            if (citationByIndex[i].properties.noteIndex) {
                noteCitations.push(citationByIndex[i]);
            } else {
                citationByIndex[i].properties.noteIndex = 0;
                textCitations.push(citationByIndex[i]);
            }
        }
    }
    if (flag !== CSL.ASSUME_ALL_ITEMS_REGISTERED) {
        this.updateItems(update_items);
    }
    if (!this.opt.citation_number_sort && sortedItems && sortedItems.length > 1 && this.citation_sort.tokens.length > 0) {
        for (i = 0, ilen = sortedItems.length; i < ilen; i += 1) {
            sortedItems[i][1].sortkeys = CSL.getSortKeys.call(this, sortedItems[i][0], "citation_sort");
        }
        if (this.opt.grouped_sort &&  !citation.properties.unsorted) {
            for (i = 0, ilen = sortedItems.length; i < ilen; i += 1) {
                var sortkeys = sortedItems[i][1].sortkeys;
                this.tmp.authorstring_request = true;
                var mydisambig = this.registry.registry[sortedItems[i][0].id].disambig;
                this.tmp.authorstring_request = true;
                CSL.getAmbiguousCite.call(this, sortedItems[i][0], mydisambig);
                var authorstring = this.registry.authorstrings[sortedItems[i][0].id];
                this.tmp.authorstring_request = false;
                sortedItems[i][1].sortkeys = [authorstring].concat(sortkeys);
            }
            sortedItems.sort(this.citation.srt.compareCompositeKeys);
            var lastauthor = false;
            var thiskey = false;
            var thisauthor = false;
            for (i = 0, ilen = sortedItems.length; i < ilen; i += 1) {
                if (sortedItems[i][1].sortkeys[0] !== lastauthor) {
                    thisauthor = sortedItems[i][1].sortkeys[0];
                    thiskey =  sortedItems[i][1].sortkeys[1];
                }
                sortedItems[i][1].sortkeys[0] = "" + thiskey + i;
                lastauthor = thisauthor;
            }
        }
        if (!citation.properties.unsorted) {
            sortedItems.sort(this.citation.srt.compareCompositeKeys);
        }
    }
    var citations;
    if (this.opt.update_mode === CSL.POSITION) {
        for (i = 0; i < 2; i += 1) {
            citations = [textCitations, noteCitations][i];
            var first_ref = {};
            var last_ref = {};
            for (j = 0, jlen = citations.length; j < jlen; j += 1) {
                var onecitation = citations[j];
                if (j > 0 && citations[j - 1].properties.noteIndex > citations[j].properties.noteIndex) {
                    citationsInNote = {};
                    first_ref = {};
                    last_ref = {};
                }
                for (var k = 0, klen = onecitation.sortedItems.length; k < klen; k += 1) {
                    if (!this.registry.registry[onecitation.sortedItems[k][1].id].parallel) {
                        if (!citationsInNote[onecitation.properties.noteIndex]) {
                            citationsInNote[onecitation.properties.noteIndex] = 1;
                        } else {
                            citationsInNote[onecitation.properties.noteIndex] += 1;
                        }
                    }
                }
                for (k = 0, klen = citations[j].sortedItems.length; k < klen; k += 1) {
                    item = citations[j].sortedItems[k];
                    var myid = item[0].id;
                    var mylocator = item[1].locator;
                    var mylabel = item[1].label;
                    if (item[0].legislation_id) {
                        myid = item[0].legislation_id;
                    }
                    var incitationid;
                    if (k > 0) {
                        if (onecitation.sortedItems[k - 1][0].legislation_id) {
                            incitationid = onecitation.sortedItems[k - 1][0].legislation_id;
                        } else {
                            incitationid = onecitation.sortedItems[k - 1][1].id
                        }
                    }
                    if (flag === CSL.PREVIEW) {
                        if (onecitation.citationID != citation.citationID) {
                            if ("undefined" === typeof first_ref[item[1].id]) {
                                first_ref[myid] = onecitation.properties.noteIndex;
                                last_ref[myid] = onecitation.properties.noteIndex;
                            } else {
                                last_ref[myid] = onecitation.properties.noteIndex;
                            }
                            continue;
                        }
                    }
                    var oldvalue = {};
                    oldvalue.position = item[1].position;
                    oldvalue["first-reference-note-number"] = item[1]["first-reference-note-number"];
                    oldvalue["near-note"] = item[1]["near-note"];
                    item[1]["first-reference-note-number"] = 0;
                    item[1]["near-note"] = false;
                    if ("undefined" === typeof first_ref[myid]) {
                        first_ref[myid] = onecitation.properties.noteIndex;
                        last_ref[myid] = onecitation.properties.noteIndex;
                        item[1].position = CSL.POSITION_FIRST;
                    } else {
                        var ibidme = false;
                        var suprame = false;
                        if (j > 0) {
                            var oldlastid =  citations[j - 1].sortedItems.slice(-1)[0][1].id;
                            if (citations[j - 1].sortedItems[0].slice(-1)[0].legislation_id) {
                                oldlastid = citations[j - 1].sortedItems[0].slice(-1)[0].legislation_id;
                            }
                        }
                        if (j > 0 && parseInt(k, 10) === 0 && citations[j - 1].properties.noteIndex !== citations[j].properties.noteIndex) {
                            var items = citations[(j - 1)].sortedItems;
                            var useme = false;
                            var oldid = citations[j - 1].sortedItems[0][0].id;
                            if (citations[j - 1].sortedItems[0][0].legislation_id) {
                                oldid = citations[j - 1].sortedItems[0][0].legislation_id;
                            }
                            if ((oldid  == myid && citations[j - 1].properties.noteIndex >= (citations[j].properties.noteIndex - 1)) || citations[j - 1].sortedItems[0][1].id == this.registry.registry[item[1].id].parallel) {
                                if (citationsInNote[citations[j - 1].properties.noteIndex] == 1 || citations[j - 1].properties.noteIndex == 0) {
                                    useme = true;
                                }
                            }
                            for (n = 0, nlen = items.slice(1).length; n < nlen; n += 1) {
                                var itmp = items.slice(1)[n];
                                if (!this.registry.registry[itmp[1].id].parallel || this.registry.registry[itmp[1].id].parallel == this.registry.registry[itmp[1].id]) {
                                    useme = false;
                                }
                            }
                            if (useme) {
                                ibidme = true;
                            } else {
                                suprame = true;
                            }
                        } else if (k > 0 && incitationid == myid) {
                            ibidme = true;
                        } else if (k == 0 && citations[j - 1].properties.noteIndex == citations[j].properties.noteIndex
                                   && citations[j - 1].sortedItems.length 
                                   && oldlastid == myid) {
                            ibidme = true;
                        } else {
                            suprame = true;
                        }
                        var prev, prev_locator, prev_label, curr_locator, curr_label;
                        if (ibidme) {
                            if (k > 0) {
                                prev = onecitation.sortedItems[(k - 1)][1];
                            } else {
                                prev = citations[(j - 1)].sortedItems[0][1];
                            }
                            if (prev.locator) {
                                if (prev.label) {
                                    prev_label = prev.label;
                                } else {
                                    prev_label = "";
                                }
                                prev_locator = "" + prev.locator + prev_label;
                            } else {
                                prev_locator = prev.locator;
                            }
                            if (mylocator) {
                                if (mylabel) {
                                    curr_label = mylabel;
                                } else {
                                    curr_label = "";
                                }
                                curr_locator = "" + mylocator + curr_label;
                            } else {
                                curr_locator = mylocator;
                            }
                        }
                        if (ibidme && prev_locator && !curr_locator) {
                            ibidme = false;
                            suprame = true;
                        }
                        if (ibidme) {
                            if (!prev_locator && curr_locator) {
                                item[1].position = CSL.POSITION_IBID_WITH_LOCATOR;
                            } else if (!prev_locator && !curr_locator) {
                                item[1].position = CSL.POSITION_IBID;
                            } else if (prev_locator && curr_locator === prev_locator) {
                                item[1].position = CSL.POSITION_IBID;
                            } else if (prev_locator && curr_locator && curr_locator !== prev_locator) {
                                item[1].position = CSL.POSITION_IBID_WITH_LOCATOR;
                            } else {
                                ibidme = false; // just to be clear
                                suprame = true;
                            }
                        }
                        if (suprame) {
                            item[1].position = CSL.POSITION_SUBSEQUENT;
                        }
                        if (suprame || ibidme) {
                            if (first_ref[myid] != onecitation.properties.noteIndex) {
                                item[1]["first-reference-note-number"] = first_ref[myid];
                            }
                        }
                    }
                    if (onecitation.properties.noteIndex) {
                        var note_distance = parseInt(onecitation.properties.noteIndex, 10) - parseInt(last_ref[myid], 10);
                        if (item[1].position !== CSL.POSITION_FIRST 
                            && note_distance <= this.citation.opt["near-note-distance"]) {
                            item[1]["near-note"] = true;
                        }
                        last_ref[myid] = onecitation.properties.noteIndex;
                    }
                    if (onecitation.citationID != citation.citationID) {
                        for (n = 0, nlen = CSL.POSITION_TEST_VARS.length; n < nlen; n += 1) {
                            var param = CSL.POSITION_TEST_VARS[n];
                            if (item[1][param] !== oldvalue[param]) {
                                this.tmp.taintedCitationIDs[onecitation.citationID] = true;
                            }
                        }
                    }
                }
            }
        }
    }
    if (this.opt.citation_number_sort && sortedItems && sortedItems.length > 1 && this.citation_sort.tokens.length > 0) {
        for (i = 0, ilen = sortedItems.length; i < ilen; i += 1) {
            sortedItems[i][1].sortkeys = CSL.getSortKeys.call(this, sortedItems[i][0], "citation_sort");
        }
        if (!citation.properties.unsorted) {
            sortedItems.sort(this.citation.srt.compareCompositeKeys);
        }
    }
    for (key in this.tmp.taintedItemIDs) {
        if (this.tmp.taintedItemIDs.hasOwnProperty(key)) {
            citations = this.registry.citationreg.citationsByItemId[key];
            if (citations) {
                for (i = 0, ilen = citations.length; i < ilen; i += 1) {
                    this.tmp.taintedCitationIDs[citations[i].citationID] = true;
                }
            }
        }
    }
    var ret = [];
    if (flag === CSL.PREVIEW) {
        try {
            ret = this.process_CitationCluster.call(this, citation.sortedItems, citation.citationID);
        } catch (e) {
            CSL.error("Error running CSL processor for preview: "+e);
        }
        this.registry.citationreg.citationByIndex = oldCitationList;
        this.registry.citationreg.citationById = {};
        for (i = 0, ilen = oldCitationList.length; i < ilen; i += 1) {
            this.registry.citationreg.citationById[oldCitationList[i].citationID] = oldCitationList[i];
        }
        var oldItemIds = [];
        for (i = 0, ilen = oldItemList.length; i < ilen; i += 1) {
            oldItemIds.push("" + oldItemList[i].id);
        }
        this.updateItems(oldItemIds);
        for (key in oldAmbigs) {
            if (oldAmbigs.hasOwnProperty(key)) {
                this.registry.registry[key].disambig = oldAmbigs[key];
            }
        }
    } else {
        var obj;
        for (key in this.tmp.taintedCitationIDs) {
            if (this.tmp.taintedCitationIDs.hasOwnProperty(key)) {
                if (key == citation.citationID) {
                    continue;
                }
                var mycitation = this.registry.citationreg.citationById[key];
                this.tmp.citation_pos = mycitation.properties.index;
                this.tmp.citation_note_index = mycitation.properties.noteIndex;
                this.tmp.citation_id = "" + mycitation.citationID;
                obj = [];
                obj.push(mycitation.properties.index);
                obj.push(this.process_CitationCluster.call(this, mycitation.sortedItems, mycitation.citationID));
                ret.push(obj);
                this.tmp.citation_pos += 1;
            }
        }
        this.tmp.taintedItemIDs = {};
        this.tmp.taintedCitationIDs = false;
        this.tmp.citation_pos = citation.properties.index;
        this.tmp.citation_note_index = citation.properties.noteIndex;
        this.tmp.citation_id = "" + citation.citationID;
        obj = [];
        obj.push(citationsPre.length);
        obj.push(this.process_CitationCluster.call(this, sortedItems));
        ret.push(obj);
        ret.sort(function (a, b) {
            if (a[0] > b[0]) {
                return 1;
            } else if (a[0] < b[0]) {
                return -1;
            } else {
                return 0;
            }
        });
    }
    return_data.citation_errors = this.tmp.citation_errors.slice();
    return [return_data, ret];
};
CSL.Engine.prototype.process_CitationCluster = function (sortedItems, citationID) {
    var str;
    this.parallel.StartCitation(sortedItems);
    str = CSL.getCitationCluster.call(this, sortedItems, citationID);
    return str;
};
CSL.Engine.prototype.makeCitationCluster = function (rawList) {
    var inputList, newitem, str, pos, len, item, Item;
    inputList = [];
    len = rawList.length;
    for (pos = 0; pos < len; pos += 1) {
        item = {};
        for (var key in rawList[pos]) {
            item[key] = rawList[pos][key];
        }
        Item = this.retrieveItem("" + item.id);
        if (this.opt.development_extensions.locator_label_parse) {
            if (item.locator && ["bill","gazette","legislation","treaty"].indexOf(Item.type) === -1 && (!item.label || item.label === 'page')) {
                var m = CSL.LOCATOR_LABELS_REGEXP.exec(item.locator);
                if (m) {
                    item.label = CSL.LOCATOR_LABELS_MAP[m[2]];
                    item.locator = m[3];
                }
            }
        }
        newitem = [Item, item];
        inputList.push(newitem);
    }
    this.remapSectionVariable(inputList);
    if (inputList && inputList.length > 1 && this.citation_sort.tokens.length > 0) {
        len = inputList.length;
        for (var pos = 0; pos < len; pos += 1) {
            inputList[pos][1].sortkeys = CSL.getSortKeys.call(this, inputList[pos][0], "citation_sort");
        }
        inputList.sort(this.citation.srt.compareCompositeKeys);
    }
    this.tmp.citation_errors = [];
    this.parallel.StartCitation(inputList);
    str = CSL.getCitationCluster.call(this, inputList);
    return str;
};
CSL.getAmbiguousCite = function (Item, disambig) {
    var use_parallels, ret;
    var oldTermSiblingLayer = this.tmp.group_context.value().slice();
    if (disambig) {
        this.tmp.disambig_request = disambig;
    } else {
        this.tmp.disambig_request = false;
    }
    this.tmp.area = "citation";
    use_parallels = this.parallel.use_parallels;
    this.parallel.use_parallels = false;
    this.tmp.suppress_decorations = true;
    this.tmp.just_looking = true;
    CSL.getCite.call(this, Item, {position: 1});
    CSL.Output.Queue.purgeEmptyBlobs(this.output.queue);
    if (this.opt.development_extensions.clean_up_csl_flaws) {
        CSL.Output.Queue.adjustPunctuation(this, this.output.queue);
    }
    ret = this.output.string(this, this.output.queue);
    this.tmp.just_looking = false;
    this.tmp.suppress_decorations = false;
    this.parallel.use_parallels = use_parallels;
    this.tmp.group_context.replace(oldTermSiblingLayer, "literal");
    return ret;
};
CSL.getSpliceDelimiter = function (last_collapsed, pos) {
    if (last_collapsed && ! this.tmp.have_collapsed && "string" === typeof this.citation.opt["after-collapse-delimiter"]) {
        this.tmp.splice_delimiter = this.citation.opt["after-collapse-delimiter"];
    } else if (this.tmp.have_collapsed && this.opt.xclass === "in-text" && this.opt.update_mode !== CSL.NUMERIC) {
        this.tmp.splice_delimiter = ", ";
    } else if (this.tmp.cite_locales[pos - 1]) {
        var alt_affixes = this.tmp.cite_affixes[this.tmp.cite_locales[pos - 1]];
        if (alt_affixes && alt_affixes.delimiter) {
            this.tmp.splice_delimiter = alt_affixes.delimiter;
        }
    }
    if (!this.tmp.splice_delimiter) {
        this.tmp.splice_delimiter = "";
    }
    return this.tmp.splice_delimiter;
};
CSL.getCitationCluster = function (inputList, citationID) {
    var result, objects, myparams, len, pos, item, last_collapsed, params, empties, composite, compie, myblobs, Item, llen, ppos, obj, preceding_item, txt_esc, error_object;
    this.tmp.last_primary_names_string = false;
    this.tmp.nestedBraces = false;
    txt_esc = CSL.getSafeEscape(this);
    this.tmp.area = "citation";
    result = "";
    objects = [];
    this.tmp.last_suffix_used = "";
    this.tmp.last_names_used = [];
    this.tmp.last_years_used = [];
    this.tmp.backref_index = [];
    this.tmp.cite_locales = [];
    if (citationID) {
        this.registry.citationreg.citationById[citationID].properties.backref_index = false;
        this.registry.citationreg.citationById[citationID].properties.backref_citation = false;
    }
    if (this.opt.xclass === "note") {
        var parasets = [];
        var lastTitle = false;
        var lastPosition = false;
        var lastID = false;
        for (var i=0, ilen = inputList.length; i < ilen; i += 1) {
            var type = inputList[i][0].type;
            var title = inputList[i][0].title;
            var position = inputList[i][1].position;
            var id = inputList[i][0].id;
            if (title && type === "legal_case" && id !== lastID && position) {
                if (title !== lastTitle || parasets.length === 0) {
                    var lst = [];
                    parasets.push(lst);
                }
                lst.push(inputList[i][1]);
            }
            lastTitle = title;
            lastPosition = position;
            lastID = id;
        }
        for (var i=0, ilen=parasets.length; i < ilen; i += 1) {
            var lst = parasets[i];
            if (lst.length < 2) {
                continue;
            }
            var locatorInLastPosition = lst.slice(-1)[0].locator;
            if (locatorInLastPosition) {
                for (var j=0, jlen=lst.length - 1; j < jlen; j += 1) {
                    if (lst[j].locator) {
                        locatorInLastPosition = false;
                    }
                }
            }
            if (locatorInLastPosition) {
                lst[0].locator = locatorInLastPosition;
                delete lst.slice(-1)[0].locator;
                lst[0].label = lst.slice(-1)[0].label;
                if (lst.slice(-1)[0].label) {
                    delete lst.slice(-1)[0].label;
                }
            }
       }
    }
    myparams = [];
    len = inputList.length;
    for (pos = 0; pos < len; pos += 1) {
        Item = inputList[pos][0];
        item = inputList[pos][1];
        last_collapsed = this.tmp.have_collapsed;
        params = {};
        if (pos > 0) {
            CSL.getCite.call(this, Item, item, "" + inputList[(pos - 1)][0].id);
        } else {
            this.tmp.term_predecessor = false;
            CSL.getCite.call(this, Item, item);
        }
        if (!this.tmp.cite_renders_content) {
            error_object = {
                citationID: "" + this.tmp.citation_id,
                index: this.tmp.citation_pos,
                noteIndex: this.tmp.citation_note_index,
                itemID: "" + Item.id,
                citationItems_pos: pos,
                error_code: CSL.ERROR_NO_RENDERED_FORM
            };
            this.tmp.citation_errors.push(error_object);
        }
        if (pos === (inputList.length - 1)) {
            this.parallel.ComposeSet();
        }
        params.splice_delimiter = CSL.getSpliceDelimiter.call(this, last_collapsed, pos);
        if (item && item["author-only"]) {
            this.tmp.suppress_decorations = true;
        }
        if (pos > 0) {
            preceding_item = inputList[pos - 1][1];
            if (preceding_item.suffix && pos > 0 && preceding_item.suffix.slice(-1) === ".") {
                var spaceidx = params.splice_delimiter.indexOf(" ");
                if (spaceidx > -1) {
                    params.splice_delimiter = params.splice_delimiter.slice(spaceidx);
                } else {
                    params.splice_delimiter = "";
                }
            }
        }
        params.suppress_decorations = this.tmp.suppress_decorations;
        params.have_collapsed = this.tmp.have_collapsed;
        myparams.push(params);
    }
    this.tmp.has_purged_parallel = false;
    this.parallel.PruneOutputQueue(this);
    empties = 0;
    myblobs = this.output.queue.slice();
    var fakeblob = {
        strings: {
            suffix: this.citation.opt.layout_suffix,
            delimiter: this.citation.opt.layout_delimiter                
        }
    };
    var suffix = this.citation.opt.layout_suffix;
    var last_locale = this.tmp.cite_locales[this.tmp.cite_locales.length - 1];
    if (last_locale && this.tmp.cite_affixes[last_locale] && this.tmp.cite_affixes[last_locale].suffix) {
        suffix = this.tmp.cite_affixes[last_locale].suffix;
    }
    if (CSL.TERMINAL_PUNCTUATION.slice(0, -1).indexOf(suffix.slice(0, 1)) > -1) {
        suffix = suffix.slice(0, 1);
    }
    var delimiter = this.citation.opt.layout_delimiter;
    if (!delimiter) {
        delimiter = "";
    }
    if (CSL.TERMINAL_PUNCTUATION.slice(0, -1).indexOf(delimiter.slice(0, 1)) > -1) {
        delimiter = delimiter.slice(0, 1);
    }
    var mystk = [
        {
            suffix: "",
            delimiter: delimiter,
            blob: fakeblob
        }
    ];
    var use_layout_suffix = suffix;
    for (pos = 0, len = myblobs.length; pos < len; pos += 1) {
        CSL.Output.Queue.purgeEmptyBlobs(this.output.queue, true);
    }
    for (pos = 0, len = myblobs.length; pos < len; pos += 1) {
        this.output.queue = [myblobs[pos]];
        this.tmp.suppress_decorations = myparams[pos].suppress_decorations;
        this.tmp.splice_delimiter = myparams[pos].splice_delimiter;
        if (myblobs[pos].parallel_delimiter) {
            this.tmp.splice_delimiter = myblobs[pos].parallel_delimiter;
        }
        this.tmp.have_collapsed = myparams[pos].have_collapsed;
        if (pos === (myblobs.length - 1)) {
            mystk[0].suffix = use_layout_suffix;
        }
        if (this.opt.development_extensions.clean_up_csl_flaws) {
            CSL.Output.Queue.adjustPunctuation(this, this.output.queue, mystk);
        }
        composite = this.output.string(this, this.output.queue);
        this.tmp.suppress_decorations = false;
        if ("string" === typeof composite) {
            this.tmp.suppress_decorations = false;
            return composite;
        }
        if ("object" === typeof composite && composite.length === 0 && !item["suppress-author"]) {
            if (this.tmp.has_purged_parallel) {
                composite.push("");
            } else {
                composite.push("[CSL STYLE ERROR: reference with no printed form.]");
            }
        }
        if (objects.length && "string" === typeof composite[0]) {
            composite.reverse();
            var tmpstr = composite.pop();
            if (tmpstr && tmpstr.slice(0, 1) === ",") {
                objects.push(tmpstr);
            } else if ("string" == typeof objects.slice(-1)[0] && objects.slice(-1)[0].slice(-1) === ",") {
                objects.push(" " + tmpstr)
            } else if (tmpstr) {
                objects.push(txt_esc(this.tmp.splice_delimiter) + tmpstr);
            }
        } else {
            composite.reverse();
            compie = composite.pop();
            if ("undefined" !== typeof compie) {
                if (objects.length && "string" === typeof objects[objects.length - 1]) {
                    objects[objects.length - 1] += compie.successor_prefix;
                }
                objects.push(compie);
            }
        }
        llen = composite.length;
        for (ppos = 0; ppos < llen; ppos += 1) {
            obj = composite[ppos];
            if ("string" === typeof obj) {
                objects.push(txt_esc(this.tmp.splice_delimiter) + obj);
                continue;
            }
            compie = composite.pop();
            if ("undefined" !== typeof compie) {
                objects.push(compie);
            }
        }
        if (objects.length === 0 && !inputList[pos][1]["suppress-author"]) {
            empties += 1;
        }
    }
    result += this.output.renderBlobs(objects);
    if (result) {
        if (CSL.TERMINAL_PUNCTUATION.indexOf(this.tmp.last_chr) > -1 
            && this.tmp.last_chr === use_layout_suffix.slice(0, 1)) {
            use_layout_suffix = use_layout_suffix.slice(1);
        }
        this.output.nestedBraces = false;
        result = txt_esc(this.citation.opt.layout_prefix) + result + txt_esc(use_layout_suffix);
        if (!this.tmp.suppress_decorations) {
            len = this.citation.opt.layout_decorations.length;
            for (pos = 0; pos < len; pos += 1) {
                params = this.citation.opt.layout_decorations[pos];
                if (params[1] === "normal") {
                    continue;
                }
                result = this.fun.decorate[params[0]][params[1]](this, result);
            }
        }
    }
    this.tmp.suppress_decorations = false;
    return result;
};
CSL.getCite = function (Item, item, prevItemID) {
    var next, error_object;
    this.tmp.cite_renders_content = false;
    this.parallel.StartCite(Item, item, prevItemID);
    CSL.citeStart.call(this, Item, item);
    next = 0;
    this.nameOutput = new CSL.NameOutput(this, Item, item);
    while (next < this[this.tmp.area].tokens.length) {
        next = CSL.tokenExec.call(this, this[this.tmp.area].tokens[next], Item, item);
    }
    CSL.citeEnd.call(this, Item, item);
    this.parallel.CloseCite(this);
    if (!this.tmp.cite_renders_content && !this.tmp.just_looking) {
        if (this.tmp.area === "bibliography") {
            error_object = {
                index: this.tmp.bibliography_pos,
                itemID: "" + Item.id,
                error_code: CSL.ERROR_NO_RENDERED_FORM
            };
            this.tmp.bibliography_errors.push(error_object);
        }
    }
    return "" + Item.id;
};
CSL.citeStart = function (Item, item) {
    this.tmp.same_author_as_previous_cite = false;
    this.tmp.lastchr = "";
    if (this.tmp.area === "citation" && this.citation.opt.collapse && this.citation.opt.collapse.length) {
        this.tmp.have_collapsed = true;
    } else {
        this.tmp.have_collapsed = false;
    }
    this.tmp.render_seen = false;
    if (this.tmp.disambig_request  && ! this.tmp.disambig_override) {
        this.tmp.disambig_settings = this.tmp.disambig_request;
    } else if (this.registry.registry[Item.id] && ! this.tmp.disambig_override) {
        this.tmp.disambig_request = this.registry.registry[Item.id].disambig;
        this.tmp.disambig_settings = this.registry.registry[Item.id].disambig;
    } else {
        this.tmp.disambig_settings = new CSL.AmbigConfig();
    }
    if (this.tmp.area === 'bibliography' && this.opt["disambiguate-add-names"] && this.registry.registry[Item.id] && this.tmp.disambig_override) {
        this.tmp.disambig_request = this.tmp.disambig_settings;
        this.tmp.disambig_request.names = this.registry.registry[Item.id].disambig.names.slice();
        this.tmp.disambig_settings.names = this.registry.registry[Item.id].disambig.names.slice();
    }
    this.tmp.names_used = [];
    this.tmp.nameset_counter = 0;
    this.tmp.years_used = [];
    this.tmp.names_max.clear();
    this.tmp.splice_delimiter = this[this.tmp.area].opt.layout_delimiter;
    this.bibliography_sort.keys = [];
    this.citation_sort.keys = [];
    this.tmp.has_done_year_suffix = false;
    this.tmp.last_cite_locale = false;
    if (!this.tmp.just_looking && item && !item.position && this.registry.registry[Item.id]) {
        this.tmp.disambig_restore = CSL.cloneAmbigConfig(this.registry.registry[Item.id].disambig);
    }
    this.tmp.shadow_numbers = {};
    this.setNumberLabels(Item);
    this.tmp.first_name_string = false;
    if (this.opt.development_extensions.flip_parentheses_to_braces && item && item.prefix) {
        var openBrace = CSL.checkNestedBraceOpen.exec(item.prefix);
        var closeBrace = CSL.checkNestedBraceClose.exec(item.prefix);
        if (openBrace) {
            if (!closeBrace) {
                this.output.nestedBraces = CSL.NestedBraces;
            } else if (closeBrace[0].length < openBrace[0].length) {
                this.output.nestedBraces = CSL.NestedBraces;
            } else {
                this.output.nestedBraces = false;
            }
        } else if (closeBrace) {
            this.output.nestedBraces = false;
        }
    }
};
CSL.citeEnd = function (Item, item) {
    if (this.tmp.disambig_restore) {
        this.registry.registry[Item.id].disambig.names = this.tmp.disambig_restore.names;
        this.registry.registry[Item.id].disambig.givens = this.tmp.disambig_restore.givens;
    }
    this.tmp.disambig_restore = false;
    this.tmp.last_suffix_used = this.tmp.suffix.value();
    this.tmp.last_years_used = this.tmp.years_used.slice();
    this.tmp.last_names_used = this.tmp.names_used.slice();
    this.tmp.cut_var = false;
    this.tmp.disambig_request = false;
    this.tmp.cite_locales.push(this.tmp.last_cite_locale);
    if (this.tmp.original_date && this.tmp.renders_collection_number) {
        var buf = [];
        for (var i = this.tmp.original_date.list.length - 1; i > this.tmp.original_date.pos; i += -1) {
            buf.push(this.tmp.original_date.list.pop());
        }
        this.tmp.original_date.list.pop();
        for (var i = buf.length - 1; i > -1; i += -1) {
            this.tmp.original_date.list.push(buf.pop());
        }
        this.parallel.cite["original-date"] = false;
    }
    this.tmp.original_date = false;
    this.tmp.renders_collection_number = false;
    if (this.opt.development_extensions.flip_parentheses_to_braces && item && item.suffix) {
        var openBrace = CSL.checkNestedBraceOpen.exec(item.suffix);
        var closeBrace = CSL.checkNestedBraceClose.exec(item.suffix);
        if (closeBrace) {
            if (!openBrace) {
                this.output.nestedBraces = false;
            } else if (openBrace[0].length < closeBrace[0].length) {
                this.output.nestedBraces = false;
            } else {
                this.output.nestedBraces = CSL.NestedBraces;
            }
        } else if (openBrace) {
            this.output.nestedBraces = CSL.NestedBraces;
        }
    }
};
CSL.Node = {};
CSL.Node.bibliography = {
    build: function (state, target) {
        if (this.tokentype === CSL.START) {
            state.build.area = "bibliography";
            state.build.root = "bibliography";
            state.fixOpt(this, "names-delimiter", "delimiter");
            state.fixOpt(this, "name-delimiter", "delimiter");
            state.fixOpt(this, "name-form", "form");
            state.fixOpt(this, "and", "and");
            state.fixOpt(this, "delimiter-precedes-last", "delimiter-precedes-last");
            state.fixOpt(this, "delimiter-precedes-et-al", "delimiter-precedes-et-al");
            state.fixOpt(this, "initialize-with", "initialize-with");
            state.fixOpt(this, "initialize", "initialize");
            state.fixOpt(this, "name-as-sort-order", "name-as-sort-order");
            state.fixOpt(this, "sort-separator", "sort-separator");
            state.fixOpt(this, "and", "and");
            state.fixOpt(this, "et-al-min", "et-al-min");
            state.fixOpt(this, "et-al-use-first", "et-al-use-first");
            state.fixOpt(this, "et-al-use-last", "et-al-use-last");
            state.fixOpt(this, "et-al-subsequent-min", "et-al-subsequent-min");
            state.fixOpt(this, "et-al-subsequent-use-first", "et-al-subsequent-use-first");
        }
        target.push(this);
    }
};
CSL.Node.choose = {
    build: function (state, target) {
        var func;
        if (this.tokentype === CSL.START) {
            func = function (state, Item) {
                state.tmp.jump.push(undefined, CSL.LITERAL);
            };
        }
        if (this.tokentype === CSL.END) {
            func = function (state, Item) {
                state.tmp.jump.pop();
            };
        }
        this.execs.push(func);
        target.push(this);
    },
    configure: function (state, pos) {
        if (this.tokentype === CSL.END) {
            state.configure.fail.push((pos));
            state.configure.succeed.push((pos));
        } else {
            state.configure.fail.pop();
            state.configure.succeed.pop();
        }
    }
};
CSL.localeResolve = function (langstr) {
    var ret, langlst;
    ret = {};
    langlst = langstr.split(/[\-_]/);
    ret.base = CSL.LANG_BASES[langlst[0]];
    if ("undefined" === typeof ret.base) {
        CSL.debug("Warning: unknown locale "+langstr+", setting fallback to en-US");
        return {base:"en-US", best:langstr, bare:"en"};
    }
    if (langlst.length === 1 || langlst[1] === "x") {
        ret.best = ret.base.replace("_", "-");
    } else {
        ret.best = langlst.slice(0, 2).join("-");
    }
    ret.base = ret.base.replace("_", "-");
    ret.bare = langlst[0];
    return ret;
};
CSL.localeParse = function (arg) {
    return arg;
};
CSL.Engine.prototype.localeConfigure = function (langspec) {
    var localexml;
    localexml = this.sys.xml.makeXml(this.sys.retrieveLocale("en-US"));
    this.localeSet(localexml, "en-US", langspec.best);
    if (langspec.best !== "en-US") {
        if (langspec.base !== langspec.best) {
            localexml = this.sys.xml.makeXml(this.sys.retrieveLocale(langspec.base));
            this.localeSet(localexml, langspec.base, langspec.best);
        }
        localexml = this.sys.xml.makeXml(this.sys.retrieveLocale(langspec.best));
        this.localeSet(localexml, langspec.best, langspec.best);        
    }
    this.localeSet(this.cslXml, "", langspec.best);
    this.localeSet(this.cslXml, langspec.bare, langspec.best);
    if (langspec.base !== langspec.best) {
        this.localeSet(this.cslXml, langspec.base, langspec.best);
    }
    this.localeSet(this.cslXml, langspec.best, langspec.best);
    if ("undefined" === typeof this.locale[langspec.best].terms["page-range-delimiter"]) {
        if (["fr", "pt"].indexOf(langspec.best.slice(0, 2).toLowerCase()) > -1) {
            this.locale[langspec.best].terms["page-range-delimiter"] = "-";
        } else {
            this.locale[langspec.best].terms["page-range-delimiter"] = "\u2013";
        }
    }
    if ("undefined" === typeof this.locale[langspec.best].terms["year-range-delimiter"]) {
        this.locale[langspec.best].terms["year-range-delimiter"] = "\u2013";
    }
    if ("undefined" === typeof this.locale[langspec.best].terms["citation-range-delimiter"]) {
        this.locale[langspec.best].terms["citation-range-delimiter"] = "\u2013";
    }
};
CSL.Engine.prototype.localeSet = function (myxml, lang_in, lang_out) {
    var blob, locale, nodes, attributes, pos, ppos, term, form, termname, styleopts, attr, date, attrname, len, genderform, target, i, ilen;
    lang_in = lang_in.replace("_", "-");
    lang_out = lang_out.replace("_", "-");
    if (!this.locale[lang_out]) {
        this.locale[lang_out] = {};
        this.locale[lang_out].terms = {};
        this.locale[lang_out].opts = {};
        this.locale[lang_out].opts["skip-words"] = CSL.SKIP_WORDS;
        this.locale[lang_out].dates = {};
    }
    locale = this.sys.xml.makeXml();
    if (this.sys.xml.nodeNameIs(myxml, 'locale')) {
        locale = myxml;
    } else {
        nodes = this.sys.xml.getNodesByName(myxml, "locale");
        for (pos = 0, len = this.sys.xml.numberofnodes(nodes); pos < len; pos += 1) {
            blob = nodes[pos];
            if (this.sys.xml.getAttributeValue(blob, 'lang', 'xml') === lang_in) {
                locale = blob;
                break;
            }
        }
    }
    nodes = this.sys.xml.getNodesByName(locale, 'type');
    for (i = 0, ilen = this.sys.xml.numberofnodes(nodes); i < ilen; i += 1) {
        var typenode = nodes[i];
        var type = this.sys.xml.getAttributeValue(typenode, 'name');
        var gender = this.sys.xml.getAttributeValue(typenode, 'gender');
        this.opt.gender[type] = gender;
    }
    nodes = this.sys.xml.getNodesByName(locale, 'term');
    for (pos = 0, len = this.sys.xml.numberofnodes(nodes); pos < len; pos += 1) {
        term = nodes[pos];
        termname = this.sys.xml.getAttributeValue(term, 'name');
        if (termname === "sub verbo") {
            termname = "sub-verbo";
        }
        if ("undefined" === typeof this.locale[lang_out].terms[termname]) {
            this.locale[lang_out].terms[termname] = {};
        }
        form = "long";
        genderform = false;
        if (this.sys.xml.getAttributeValue(term, 'form')) {
            form = this.sys.xml.getAttributeValue(term, 'form');
        }
        if (this.sys.xml.getAttributeValue(term, 'gender-form')) {
            genderform = this.sys.xml.getAttributeValue(term, 'gender-form');
        }
        if (this.sys.xml.getAttributeValue(term, 'gender')) {
            this.opt["noun-genders"][termname] = this.sys.xml.getAttributeValue(term, 'gender');
        }
        if (genderform) {
            this.locale[lang_out].terms[termname][genderform] = {};
            this.locale[lang_out].terms[termname][genderform][form] = [];
            target = this.locale[lang_out].terms[termname][genderform];
        } else {
            this.locale[lang_out].terms[termname][form] = [];
            target = this.locale[lang_out].terms[termname];
        }
        if (this.sys.xml.numberofnodes(this.sys.xml.getNodesByName(term, 'multiple'))) {
            target[form][0] = this.sys.xml.getNodeValue(term, 'single');
            target[form][1] = this.sys.xml.getNodeValue(term, 'multiple');
        } else {
            target[form] = this.sys.xml.getNodeValue(term);
        }
    }
    for (termname in this.locale[lang_out].terms) {
        if (this.locale[lang_out].terms.hasOwnProperty(termname)) {
            for (i = 0, ilen = 2; i < ilen; i += 1) {
                genderform = CSL.GENDERS[i];
                if (this.locale[lang_out].terms[termname][genderform]) {
                    for (form in this.locale[lang_out].terms[termname]) {
                        if (!this.locale[lang_out].terms[termname][genderform][form]) {
                            this.locale[lang_out].terms[termname][genderform][form] = this.locale[lang_out].terms[termname][form];
                        }
                    }
                }
            }
        }
    }
    nodes = this.sys.xml.getNodesByName(locale, 'style-options');
    for (pos = 0, len = this.sys.xml.numberofnodes(nodes); pos < len; pos += 1) {
        if (true) {
            styleopts = nodes[pos];
            attributes = this.sys.xml.attributes(styleopts);
            for (attrname in attributes) {
                if (attributes.hasOwnProperty(attrname)) {
                    if (attrname === "@punctuation-in-quote") {
                        if (attributes[attrname] === "true") {
                            this.locale[lang_out].opts[attrname.slice(1)] = true;
                        } else {
                            this.locale[lang_out].opts[attrname.slice(1)] = false;
                        }
                    } else if (attrname === "@skip-words") {
                        var skip_words = attributes[attrname].split(/\s+/);
                        this.locale[lang_out].opts[attrname.slice(1)] = skip_words;
                    }
                }
            }
        }
    }
    nodes = this.sys.xml.getNodesByName(locale, 'date');
    for (pos = 0, len = this.sys.xml.numberofnodes(nodes); pos < len; pos += 1) {
        if (true) {
            date = nodes[pos];
            this.locale[lang_out].dates[this.sys.xml.getAttributeValue(date, "form")] = date;
        }
    }
};
CSL.Node.citation = {
    build: function (state, target) {
        if (this.tokentype === CSL.START) {
            state.fixOpt(this, "names-delimiter", "delimiter");
            state.fixOpt(this, "name-delimiter", "delimiter");
            state.fixOpt(this, "name-form", "form");
            state.fixOpt(this, "and", "and");
            state.fixOpt(this, "delimiter-precedes-last", "delimiter-precedes-last");
            state.fixOpt(this, "delimiter-precedes-et-al", "delimiter-precedes-et-al");
            state.fixOpt(this, "initialize-with", "initialize-with");
            state.fixOpt(this, "initialize", "initialize");
            state.fixOpt(this, "name-as-sort-order", "name-as-sort-order");
            state.fixOpt(this, "sort-separator", "sort-separator");
            state.fixOpt(this, "and", "and");
            state.fixOpt(this, "et-al-min", "et-al-min");
            state.fixOpt(this, "et-al-use-first", "et-al-use-first");
            state.fixOpt(this, "et-al-use-last", "et-al-use-last");
            state.fixOpt(this, "et-al-subsequent-min", "et-al-subsequent-min");
            state.fixOpt(this, "et-al-subsequent-use-first", "et-al-subsequent-use-first");
            state.build.area = "citation";
        }
        if (this.tokentype === CSL.END) {
            state.opt.grouped_sort = state.opt.xclass === "in-text" 
                && state.citation.opt.collapse 
                && state.citation.opt.collapse.length
                && state.opt.update_mode !== CSL.POSITION
                && state.opt.update_mode !== CSL.NUMERIC;
            if (state.opt.grouped_sort 
                && state.citation_sort.opt.sort_directions.length) {
                var firstkey = state.citation_sort.opt.sort_directions[0].slice();
                state.citation_sort.opt.sort_directions = [firstkey].concat(state.citation_sort.opt.sort_directions);
            }
            state.citation.srt = new CSL.Registry.Comparifier(state, "citation_sort");
        }
    }
};
CSL.Node.date = {
    build: function (state, target) {
        var func, date_obj, tok, len, pos, part, dpx, parts, mypos, start, end;
        if (this.tokentype === CSL.START || this.tokentype === CSL.SINGLETON) {
            state.build.date_parts = [];
            state.build.date_variables = this.variables;
            if (!state.build.extension) {
                CSL.Util.substituteStart.call(this, state, target);
            }
            if (state.build.extension) {
                func = CSL.dateMacroAsSortKey;
            } else {
                func = function (state, Item, item) {
                    var key, dp;
                    state.tmp.element_rendered_ok = false;
                    state.tmp.donesies = [];
                    state.tmp.dateparts = [];
                    dp = [];
                    if (this.variables.length
                        && !(state.tmp.just_looking
                             && this.variables[0] !== "issued")) {
                        state.parallel.StartVariable(this.variables[0]);
                        date_obj = Item[this.variables[0]];
                        if ("undefined" === typeof date_obj) {
                            date_obj = {"date-parts": [[0]] };
                            if (state.opt.development_extensions.locator_date_and_revision) {
                                if (item && this.variables[0] === "locator-date" && item["locator-date"]) {
                                    date_obj = item["locator-date"];
                                }
                            }
                        }
                        state.tmp.date_object = date_obj;
                        len = this.dateparts.length;
                        for (pos = 0; pos < len; pos += 1) {
                            part = this.dateparts[pos];
                            if ("undefined" !== typeof state.tmp.date_object[(part +  "_end")]) {
                                dp.push(part);
                            } else if (part === "month" && "undefined" !== typeof state.tmp.date_object.season_end) {
                                dp.push(part);
                            }
                        }
                        dpx = [];
                        parts = ["year", "month", "day"];
                        len = parts.length;
                        for (pos = 0; pos < len; pos += 1) {
                            if (dp.indexOf(parts[pos]) > -1) {
                                dpx.push(parts[pos]);
                            }
                        }
                        dp = dpx.slice();
                        mypos = 2;
                        len = dp.length;
                        for (pos = 0; pos < len; pos += 1) {
                            part = dp[pos];
                            start = state.tmp.date_object[part];
                            end = state.tmp.date_object[(part + "_end")];
                            if (start !== end) {
                                mypos = pos;
                                break;
                            }
                        }
                        state.tmp.date_collapse_at = dp.slice(mypos);
                    } else {
                        state.tmp.date_object = false;
                    }
                };
            }
            this.execs.push(func);
            func = function (state, Item) {
                state.output.startTag("date", this);
                if (this.variables[0] === "original-date"
                    && Item.type === "legal_case"
                    && !state.tmp.extension
                    && "" + Item["collection-number"] === "" + state.tmp.date_object.year
                    && this.dateparts.length === 1
                    && this.dateparts[0] === "year") {
                    for (key in state.tmp.date_object) {
                        if (state.tmp.date_object.hasOwnProperty(key)) {
                            if (key.slice(0, 4) === "year") {
                                state.tmp.original_date = {};
                                var lst = state.output.current.mystack.slice(-2)[0].blobs;
                                state.tmp.original_date.list = lst;
                                state.tmp.original_date.pos = lst.length - 1;
                            }
                        }
                    }
                }
            };
            this.execs.push(func);
        }
        if (!state.build.extension && (this.tokentype === CSL.END || this.tokentype === CSL.SINGLETON)) {
            func = function (state, Item) {
                state.output.endTag();
                state.parallel.CloseVariable("date");
            };
            this.execs.push(func);
        }
        target.push(this);
        if (this.tokentype === CSL.END || this.tokentype === CSL.SINGLETON) {
            if (!state.build.extension) {
                CSL.Util.substituteEnd.call(this, state, target);
            }
        }
    }
};
CSL.Node["date-part"] = {
    build: function (state, target) {
        var func, pos, len, decor, first_date, value, value_end, real, have_collapsed, invoked, precondition, known_year, bc, ad, bc_end, ad_end, ready, curr, dcurr, number, num, formatter, item, i, ilen;
        if (!this.strings.form) {
            this.strings.form = "long";
        }
        state.build.date_parts.push(this.strings.name);
        func = function (state, Item) {
            if (!state.tmp.date_object) {
                return;
            }
            first_date = true;
            value = "";
            value_end = "";
            state.tmp.donesies.push(this.strings.name);
            if (state.tmp.date_object.literal && "year" === this.strings.name) {
                state.parallel.AppendToVariable(state.tmp.date_object.literal);
                state.output.append(state.tmp.date_object.literal, this);
            }
            if (state.tmp.date_object) {
                value = state.tmp.date_object[this.strings.name];
                value_end = state.tmp.date_object[(this.strings.name + "_end")];
            }
            if ("year" === this.strings.name && value === 0 && !state.tmp.suppress_decorations) {
                value = false;
            }
            real = !state.tmp.suppress_decorations;
            have_collapsed = state.tmp.have_collapsed;
            invoked = state[state.tmp.area].opt.collapse === "year-suffix" || state[state.tmp.area].opt.collapse === "year-suffix-ranged";
            precondition = state.opt["disambiguate-add-year-suffix"];
            if (real && precondition && invoked) {
                state.tmp.years_used.push(value);
                known_year = state.tmp.last_years_used.length >= state.tmp.years_used.length;
                if (known_year && have_collapsed) {
                    if (state.tmp.last_years_used[(state.tmp.years_used.length - 1)] === value) {
                        value = false;
                    }
                }
            }
            if ("undefined" !== typeof value) {
                bc = false;
                ad = false;
                bc_end = false;
                ad_end = false;
                if ("year" === this.strings.name) {
                    if (parseInt(value, 10) < 500 && parseInt(value, 10) > 0) {
                        ad = state.getTerm("ad");
                    }
                    if (parseInt(value, 10) < 0) {
                        bc = state.getTerm("bc");
                        value = (parseInt(value, 10) * -1);
                    }
                    if (value_end) {
                        if (parseInt(value_end, 10) < 500 && parseInt(value_end, 10) > 0) {
                            ad_end = state.getTerm("ad");
                        }
                        if (parseInt(value_end, 10) < 0) {
                            bc_end = state.getTerm("bc");
                            value_end = (parseInt(value_end, 10) * -1);
                        }
                    }
                }
                state.parallel.AppendToVariable(value);
                var monthnameid = ""+state.tmp.date_object.month;
                while (monthnameid.length < 2) {
                    monthnameid = "0"+monthnameid;
                }
                monthnameid = "month-"+monthnameid;
                var gender = state.opt["noun-genders"][monthnameid];
                if (this.strings.form) {
                    value = CSL.Util.Dates[this.strings.name][this.strings.form](state, value, gender);
                    if ("month" === this.strings.name) {
                        if (state.tmp.strip_periods) {
                            value = value.replace(/\./g, "");
                        } else {
                            for (i = 0, ilen = this.decorations.length; i < ilen; i += 1) {
                                if ("@strip-periods" === this.decorations[i][0] && "true" === this.decorations[i][1]) {
                                    value = value.replace(/\./g, "");
                                    break;
                                }
                            }
                        }
                        if (value_end) {
                            value_end = CSL.Util.Dates[this.strings.name][this.strings.form](state, value_end, gender);
                            if (state.tmp.strip_periods) {
                                value_end = value_end.replace(/\./g, "");
                            } else {
                                for (i = 0, ilen = this.decorations.length; i < ilen; i += 1) {
                                    if ("@strip-periods" === this.decorations[i][0] && "true" === this.decorations[i][1]) {
                                        value_end = value_end.replace(/\./g, "");
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                state.output.openLevel("empty");
                if (state.tmp.date_collapse_at.length) {
                    ready = true;
                    len = state.tmp.date_collapse_at.length;
                    for (pos = 0; pos < len; pos += 1) {
                        item = state.tmp.date_collapse_at[pos];
                        if (state.tmp.donesies.indexOf(item) === -1) {
                            ready = false;
                            break;
                        }
                    }
                    if (ready) {
                        if ("" + value_end !== "0") {
                            if (state.dateput.queue.length === 0) {
                                first_date = true;
                            }
                            if (state.opt["year-range-format"]
                                && state.opt["year-range-format"] !== "expanded"
                                && !state.tmp.date_object.day
                                && !state.tmp.date_object.month
                                && !state.tmp.date_object.season
                                && this.strings.name === "year"
                                && value && value_end) {
                                value_end = state.fun.year_mangler(value + "-" + value_end, true);
                                var range_delimiter = state.getTerm("year-range-delimiter");
                                value_end = value_end.slice(value_end.indexOf(range_delimiter) + 1);
                            }
                            state.dateput.append(value_end, this);
                            if (first_date) {
                                state.dateput.current.value()[0].strings.prefix = "";
                            }
                        }
                        state.output.append(value, this);
                        curr = state.output.current.value();
                        curr.blobs[(curr.blobs.length - 1)].strings.suffix = "";
                        state.output.append(state.getTerm("year-range-delimiter"), "empty");
                        dcurr = state.dateput.current.value();
                        curr.blobs = curr.blobs.concat(dcurr);
                        state.dateput.string(state, state.dateput.queue);
                        state.tmp.date_collapse_at = [];
                    } else {
                        state.output.append(value, this);
                        if (state.tmp.date_collapse_at.indexOf(this.strings.name) > -1) {
                            if ("" + value_end !== "0") {
                                if (state.dateput.queue.length === 0) {
                                    first_date = true;
                                }
                                state.dateput.openLevel("empty");
                                state.dateput.append(value_end, this);
                                if (first_date) {
                                    state.dateput.current.value().blobs[0].strings.prefix = "";
                                }
                                if (bc) {
                                    state.dateput.append(bc);
                                }
                                if (ad) {
                                    state.dateput.append(ad);
                                }
                                state.dateput.closeLevel();
                            }
                        }
                    }
                } else {
                    state.output.append(value, this);
                }
                if (bc) {
                    state.output.append(bc);
                }
                if (ad) {
                    state.output.append(ad);
                }
                state.output.closeLevel();
            } else if ("month" === this.strings.name) {
                if (state.tmp.date_object.season) {
                    value = "" + state.tmp.date_object.season;
                    if (value && value.match(/^[1-4]$/)) {
                        state.tmp.group_context.replace([false, false, true]);
                        state.output.append(state.getTerm(("season-0" + value)), this);
                    } else if (value) {
                        state.output.append(value, this);
                    }
                }
            }
            state.tmp.value = [];
            if ((value || state.tmp.have_collapsed) && !state.opt.has_year_suffix && "year" === this.strings.name && !state.tmp.just_looking) {
                if (state.registry.registry[Item.id] && state.registry.registry[Item.id].disambig.year_suffix !== false && !state.tmp.has_done_year_suffix) {
                    state.tmp.has_done_year_suffix = true;
                    num = parseInt(state.registry.registry[Item.id].disambig.year_suffix, 10);
                    number = new CSL.NumericBlob(num, this, Item.id);
                    this.successor_prefix = state[state.build.area].opt.layout_delimiter;
                    this.splice_prefix = state[state.build.area].opt.layout_delimiter;
                    formatter = new CSL.Util.Suffixator(CSL.SUFFIX_CHARS);
                    number.setFormatter(formatter);
                    if (state[state.tmp.area].opt.collapse === "year-suffix-ranged") {
                        number.range_prefix = state.getTerm("citation-range-delimiter");
                    }
                    if (state[state.tmp.area].opt["year-suffix-delimiter"]) {
                        number.successor_prefix = state[state.tmp.area].opt["year-suffix-delimiter"];
                    } else {
                        number.successor_prefix = state[state.tmp.area].opt.layout_delimiter;
                    }
                    number.UGLY_DELIMITER_SUPPRESS_HACK = true;
                    state.output.append(number, "literal");
                }
            }
        };
        this.execs.push(func);
        target.push(this);
    }
};
CSL.Node["else-if"] = {
    build: function (state, target) {
        var func, tryposition;
        if (this.tokentype === CSL.START || this.tokentype === CSL.SINGLETON) {
            if (this.locale) {
                state.opt.lang = this.locale;
            }
            if (! this.evaluator) {
                this.evaluator = state.fun.match.any;
            }
        }
        if (this.tokentype === CSL.END || this.tokentype === CSL.SINGLETON) {
            func = function (state, Item) {
                if (this.locale_default) {
                    state.output.current.value().old_locale = this.locale_default;
                    state.output.closeLevel("empty");
                    state.opt.lang = this.locale_default;
                }
                var next = this[state.tmp.jump.value()];
                return next;
            };
            this.execs.push(func);
            if (this.locale_default) {
                state.opt.lang = this.locale_default;
            }
        }
        target.push(this);
    },
    configure: function (state, pos) {
        if (this.tokentype === CSL.START) {
            this.fail = state.configure.fail.slice(-1)[0];
            this.succeed = this.next;
            state.configure.fail[(state.configure.fail.length - 1)] = pos;
        } else if (this.tokentype === CSL.SINGLETON) {
            this.fail = this.next;
            this.succeed = state.configure.succeed.slice(-1)[0];
            state.configure.fail[(state.configure.fail.length - 1)] = pos;
        } else {
            this.succeed = state.configure.succeed.slice(-1)[0];
            this.fail = this.next;
        }
    }
};
CSL.Node["else"] = {
    build: function (state, target) {
        target.push(this);
    },
    configure: function (state, pos) {
        if (this.tokentype === CSL.START) {
            state.configure.fail[(state.configure.fail.length - 1)] = pos;
        }
    }
};
CSL.Node["#comment"] = {
       build: function (state, target) {
       }
};
CSL.Node["et-al"] = {
    build: function (state, target) {
        if (state.build.area === "citation" || state.build.area === "bibliography") {
            state.build.etal_node = this;
            if ("string" === typeof this.strings.term) {
                state.build.etal_term = this.strings.term;
            }
        }
    }
};
CSL.Node.group = {
    build: function (state, target) {
        var func, execs;
        if (this.tokentype === CSL.START) {
            CSL.Util.substituteStart.call(this, state, target);
            if (state.build.substitute_level.value()) {
                state.build.substitute_level.replace((state.build.substitute_level.value() + 1));
            }
            func = function (state, Item) {
                state.output.startTag("group", this);
                if (state.tmp.group_context.mystack.length) {
                    state.output.current.value().parent = state.tmp.group_context.value()[4];
                }
                var label_form = state.tmp.group_context.value()[5];
                if (!label_form && this.strings.label_form_override) {
                    label_form = this.strings.label_form_override;
                }
                state.tmp.group_context.push([false, false, false, false, state.output.current.value(), label_form, this.strings.set_parallel_condition], CSL.LITERAL);
                if (this.strings.oops) {
                    state.tmp.group_context.value()[3] = this.strings.oops;
                }
            };
            execs = [];
            execs.push(func);
            this.execs = execs.concat(this.execs);
            if (this.strings["has-publisher-and-publisher-place"]) {
                state.build["publisher-special"] = true;
                func = function (state, Item) {
                    if (this.strings["subgroup-delimiter"]
                        && Item.publisher && Item["publisher-place"]) {
                        var publisher_lst = Item.publisher.split(/;\s*/);
                        var publisher_place_lst = Item["publisher-place"].split(/;\s*/);
                        if (publisher_lst.length > 1
                            && publisher_lst.length === publisher_place_lst.length) {
                            state.publisherOutput = new CSL.PublisherOutput(state, this);
                            state.publisherOutput["publisher-list"] = publisher_lst;
                            state.publisherOutput["publisher-place-list"] = publisher_place_lst;
                        }
                    }
                };
                this.execs.push(func);
            }
        } else {
            if (state.build["publisher-special"]) {
                state.build["publisher-special"] = false;
                if ("string" === typeof state[state.build.root].opt["name-delimiter"]) {
                    func = function (state, Item) {
                        if (state.publisherOutput) {
                            state.publisherOutput.render();
                            state.publisherOutput = false;
                        }
                    };
                    this.execs.push(func);
                }
            }
            func = function (state, Item) {
                var flag = state.tmp.group_context.pop();
                state.output.endTag();
                var upperflag = state.tmp.group_context.value();
                if (flag[1]) {
                    state.tmp.group_context.value()[1] = true;
                }
                if (flag[2] || (flag[0] && !flag[1])) {
                    state.tmp.group_context.value()[2] = true;
                    var blobs = state.output.current.value().blobs;
                    var pos = state.output.current.value().blobs.length - 1;
                    if (!state.tmp.just_looking && "undefined" !== typeof flag[6]) {
                        var parallel_condition_object = {
                            blobs: blobs,
                            conditions: flag[6],
                            id: Item.id,
                            pos: pos
                        }
                        state.parallel.parallel_conditional_blobs_list.push(parallel_condition_object);
                    }
                } else {
                    if (state.output.current.value().blobs) {
                        state.output.current.value().blobs.pop();
                    }
                    if (state.tmp.group_context.value()[3]) {
                        state.output.current.mystack[state.output.current.mystack.length - 2].strings.delimiter = state.tmp.group_context.value()[3];
                    }
                }
            };
            this.execs.push(func);
        }
        target.push(this);
        if (this.tokentype === CSL.END) {
            if (state.build.substitute_level.value()) {
                state.build.substitute_level.replace((state.build.substitute_level.value() - 1));
            }
            CSL.Util.substituteEnd.call(this, state, target);
        }
    }
};
CSL.Node["if"] = {
    build: function (state, target) {
        var func;
        if (this.tokentype === CSL.START || this.tokentype === CSL.SINGLETON) {
            if (this.locale) {
                state.opt.lang = this.locale;
            }
            if (!this.evaluator) {
                this.evaluator = state.fun.match.any;
            }
        }
        if (this.tokentype === CSL.END || this.tokentype === CSL.SINGLETON) {
            func = function (state, Item) {
                if (this.locale_default) {
                    state.output.current.value().old_locale = this.locale_default;
                    state.output.closeLevel("empty");
                    state.opt.lang = this.locale_default;
                }
                var next = this[state.tmp.jump.value()];
                return next;
            };
            this.execs.push(func);
            if (this.locale_default) {
                state.opt.lang = this.locale_default;
            }
        }
        target.push(this);
    },
    configure: function (state, pos) {
        if (this.tokentype === CSL.START) {
            this.fail = state.configure.fail.slice(-1)[0];
            this.succeed = this.next;
        } else if (this.tokentype === CSL.SINGLETON) {
            this.fail = this.next;
            this.succeed = state.configure.succeed.slice(-1)[0];
        } else {
            this.succeed = state.configure.succeed.slice(-1)[0];
            this.fail = this.next;
        }
    }
};
CSL.Node.info = {
    build: function (state, target) {
        if (this.tokentype === CSL.START) {
            state.build.skip = "info";
        } else {
            state.build.skip = false;
        }
    }
};
CSL.Node.institution = {
    build: function (state, target) {
        if ([CSL.SINGLETON, CSL.START].indexOf(this.tokentype) > -1) {
            if ("string" === typeof state.build.name_delimiter && !this.strings.delimiter) {
                this.strings.delimiter = state.build.name_delimiter;
            }
            var myand, and_default_prefix, and_suffix;
            if ("text" === this.strings.and) {
                this.and_term = state.getTerm("and", "long", 0);
            } else if ("symbol" === this.strings.and) {
                this.and_term = "&";
            } else if ("none" === this.strings.and) {
                this.and_term = this.strings.delimiter;
            }
            if ("undefined" === typeof this.and_term && state.build.and_term) {
                this.and_term = state.getTerm("and", "long", 0);
            }
            if (CSL.STARTSWITH_ROMANESQUE_REGEXP.test(this.and_term)) {
                this.and_prefix_single = " ";
                this.and_prefix_multiple = ", ";
                if ("string" === typeof this.strings.delimiter) {
                    this.and_prefix_multiple = this.strings.delimiter;
                }
                this.and_suffix = " ";
            } else {
                this.and_prefix_single = "";
                this.and_prefix_multiple = "";
                this.and_suffix = "";
            }
            if (this.strings["delimiter-precedes-last"] === "always") {
                this.and_prefix_single = this.strings.delimiter;
            } else if (this.strings["delimiter-precedes-last"] === "never") {
                if (this.and_prefix_multiple) {
                    this.and_prefix_multiple = " ";
                }
            }
            func = function (state, Item) {
                this.and = {};
                if ("undefined" !== typeof this.and_term) {
                    state.output.append(this.and_term, "empty", true);
                    this.and.single = state.output.pop();
                    this.and.single.strings.prefix = this.and_prefix_single;
                    this.and.single.strings.suffix = this.and_suffix;
                    state.output.append(this.and_term, "empty", true);
                    this.and.multiple = state.output.pop();
                    this.and.multiple.strings.prefix = this.and_prefix_multiple;
                    this.and.multiple.strings.suffix = this.and_suffix;
                } else if ("undefined" !== this.strings.delimiter) {
                    this.and.single = new CSL.Blob(this.strings.delimiter);
                    this.and.single.strings.prefix = "";
                    this.and.single.strings.suffix = "";
                    this.and.multiple = new CSL.Blob(this.strings.delimiter);
                    this.and.multiple.strings.prefix = "";
                    this.and.multiple.strings.suffix = "";
                }
                state.nameOutput.institution = this;
            };
            this.execs.push(func);
        }
        target.push(this);
    },
    configure: function (state, pos) {
        if ([CSL.SINGLETON, CSL.START].indexOf(this.tokentype) > -1) {
            state.build.has_institution = true;
        }
    }
};
CSL.Node["institution-part"] = {
    build: function (state, target) {
        var func;
        if ("long" === this.strings.name) {
            if (this.strings["if-short"]) {
                func = function (state, Item) {
                    state.nameOutput.institutionpart["long-with-short"] = this;
                };
            } else {
                func = function (state, Item) {
                    state.nameOutput.institutionpart["long"] = this;
                };
            }
        } else if ("short" === this.strings.name) {
            func = function (state, Item) {
                state.nameOutput.institutionpart["short"] = this;
            };
        }
        this.execs.push(func);
        target.push(this);
    }
};
CSL.Node.key = {
    build: function (state, target) {
        var func, i, ilen;
        var debug = false;
        var start_key = new CSL.Token("key", CSL.START);
        start_key.strings["et-al-min"] = this.strings["et-al-min"];
        start_key.strings["et-al-use-first"] = this.strings["et-al-use-first"];
        start_key.strings["et-al-use-last"] = this.strings["et-al-use-last"];
        func = function (state, Item) {
            state.tmp.done_vars = [];
        };
        start_key.execs.push(func);
        state.opt.citation_number_sort_direction = this.strings.sort_direction;
        func = function (state, Item) {
            state.output.openLevel("empty");
        };
        start_key.execs.push(func);
        var sort_direction = [];
        if (this.strings.sort_direction === CSL.DESCENDING) {
            sort_direction.push(1);
            sort_direction.push(-1);
        } else {
            sort_direction.push(-1);
            sort_direction.push(1);
        }
        state[state.build.area].opt.sort_directions.push(sort_direction);
        func = function (state, Item) {
            state.tmp.sort_key_flag = true;
            if (this.strings["et-al-min"]) {
                state.tmp["et-al-min"] = this.strings["et-al-min"];
            }
            if (this.strings["et-al-use-first"]) {
                state.tmp["et-al-use-first"] = this.strings["et-al-use-first"];
            }
            if ("boolean" === typeof this.strings["et-al-use-last"]) {
                state.tmp["et-al-use-last"] = this.strings["et-al-use-last"];
            }
        };
        start_key.execs.push(func);
        target.push(start_key);
        if (this.variables.length) {
            var variable = this.variables[0];
            if (variable === "citation-number") {
                if (state.build.area === "citation_sort") {
                    state.opt.citation_number_sort = true;
                }
                if (state.build.area === "bibliography_sort") {
                    state.opt.citation_number_sort_used = true;
                }
            }
            if (CSL.CREATORS.indexOf(variable) > -1) {
                var names_start_token = new CSL.Token("names", CSL.START);
                names_start_token.tokentype = CSL.START;
                names_start_token.variables = this.variables;
                CSL.Node.names.build.call(names_start_token, state, target);
                var name_token = new CSL.Token("name", CSL.SINGLETON);
                name_token.tokentype = CSL.SINGLETON;
                name_token.strings["name-as-sort-order"] = "all";
                name_token.strings["sort-separator"] = " ";
                name_token.strings["et-al-use-last"] = this.strings["et-al-use-last"];
                name_token.strings["et-al-min"] = this.strings["et-al-min"];
                name_token.strings["et-al-use-first"] = this.strings["et-al-use-first"];
                CSL.Node.name.build.call(name_token, state, target);
                var institution_token = new CSL.Token("institution", CSL.SINGLETON);
                institution_token.tokentype = CSL.SINGLETON;
                CSL.Node.institution.build.call(institution_token, state, target);
                var names_end_token = new CSL.Token("names", CSL.END);
                names_end_token.tokentype = CSL.END;
                CSL.Node.names.build.call(names_end_token, state, target);
            } else {
                var single_text = new CSL.Token("text", CSL.SINGLETON);
                single_text.dateparts = this.dateparts;
                if (CSL.NUMERIC_VARIABLES.indexOf(variable) > -1) {
                    func = function (state, Item) {
                        var num, m;
                        num = false;
                        if ("citation-number" === variable) {
                            num = state.registry.registry[Item.id].seq.toString();
                        } else {
                            num = Item[variable];
                        }
                        if (num) {
                            num = CSL.Util.padding(num);
                        }
                        state.output.append(num, this);
                    };
                } else if (variable === "citation-label") {
                    func = function (state, Item) {
                        var trigraph = state.getCitationLabel(Item);
                        state.output.append(trigraph, this);
                    };
                } else if (CSL.DATE_VARIABLES.indexOf(variable) > -1) {
                    func = CSL.dateAsSortKey;
                    single_text.variables = this.variables;
                } else if ("title" === variable) {
                    var abbrevfam = "title";
                    var abbrfall = false;
                    var altvar = false;
                    var transfall = true;
                    func = state.transform.getOutputFunction(this.variables, abbrevfam, abbrfall, altvar, transfall);
                } else {
                    func = function (state, Item) {
                        var varval = Item[variable];
                        state.output.append(varval, "empty");
                    };
                }
                single_text.execs.push(func);
                target.push(single_text);
            }
        } else { // macro
            var token = new CSL.Token("text", CSL.SINGLETON);
            token.postponed_macro = this.postponed_macro;
            CSL.expandMacro.call(state, token);
        }
        var end_key = new CSL.Token("key", CSL.END);
        func = function (state, Item) {
            var keystring = state.output.string(state, state.output.queue);
            if ("" === keystring) {
                keystring = undefined;
            }
            if ("string" !== typeof keystring || state.tmp.empty_date) {
                keystring = undefined;
                state.tmp.empty_date = false;
            }
            state[state.tmp.area].keys.push(keystring);
            state.tmp.value = [];
        };
        end_key.execs.push(func);
        func = function (state, Item) {
            state.tmp["et-al-min"] = undefined;
            state.tmp["et-al-use-first"] = undefined;
            state.tmp["et-al-use-last"] = undefined;
            state.tmp.sort_key_flag = false;
        };
        end_key.execs.push(func);
        target.push(end_key);
    }
};
CSL.Node.label = {
    build: function (state, target) {
        var debug = false;
        if (this.strings.term) {
            var plural = false;
            if (!this.strings.form) {
                this.strings.form = "long";
            }
            var func = function (state, Item, item) {
                var termtxt = CSL.evaluateLabel(this, state, Item, item);
                if (item && this.strings.term === "locator") {
                    state.parallel.StartVariable("label");
                    state.parallel.AppendToVariable(item.label);
                    item.section_form_override = this.strings.form;
                }
                state.output.append(termtxt, this);
                if (item && this.strings.term === "locator") {
                    state.parallel.CloseVariable();
                }
            };
            this.execs.push(func);
        } else {
            if (!state.build.name_label) {
                state.build.name_label = {};
            }
            if (!state.build.name_flag) {
                state.build.name_label.before = this;
            } else {
                state.build.name_label.after = this;
            }
        }
        target.push(this);
    }
};
CSL.Node.layout = {
    build: function (state, target) {
        var func, prefix_token, suffix_token, tok;
        if (this.tokentype === CSL.START && !state.tmp.cite_affixes) {
            func = function (state, Item) {
                state.tmp.done_vars = [];
                if (!state.tmp.just_looking && state.registry.registry[Item.id].parallel) {
                    state.tmp.done_vars.push("first-reference-note-number");
                }
                state.tmp.rendered_name = false;
                state.tmp.name_node = {};
            };
            this.execs.push(func);
            func = function (state, Item) {
                state.tmp.sort_key_flag = false;
            };
            this.execs.push(func);
            func = function (state, Item) {
                state.tmp.nameset_counter = 0;
            };
            this.execs.push(func);
            func = function (state, Item) {
                state.output.openLevel("empty");
            };
            this.execs.push(func);
            target.push(this);
            if (state.build.area === "citation") {
                prefix_token = new CSL.Token("text", CSL.SINGLETON);
                func = function (state, Item, item) {
                    var sp;
                    if (item && item.prefix) {
                        sp = "";
                        var prefix = item.prefix.replace(/<[^>]+>/g, "").replace(/\s+$/, "").replace(/^\s+/, "");
                        if (prefix.match(CSL.ENDSWITH_ROMANESQUE_REGEXP)) {
                            sp = " ";
                        }
                        var ignorePredecessor = false;
                        if (CSL.TERMINAL_PUNCTUATION.slice(0,-1).indexOf(prefix.slice(-1)) > -1
                            && prefix[0] != prefix[0].toLowerCase()) {
                            state.tmp.term_predecessor = false;
                            ignorePredecessor = true;
                        }
                        prefix = (item.prefix + sp).replace(/\s+/g, " ")
                        state.output.append(prefix, this, false, ignorePredecessor);
                    }
                };
                prefix_token.execs.push(func);
                target.push(prefix_token);
            }
        }
        var my_tok;
        if (this.locale_raw) {
            my_tok = new CSL.Token("dummy", CSL.START);
            my_tok.locale = this.locale_raw;
            my_tok.strings.delimiter = this.strings.delimiter;
            my_tok.strings.suffix = this.strings.suffix;
            if (!state.tmp.cite_affixes) {
                state.tmp.cite_affixes = {};
            }
        }
        if (this.tokentype === CSL.START) {
            state.build.layout_flag = true;
            if (!this.locale_raw) {
                state[state.tmp.area].opt.topdecor = [this.decorations];
                state[(state.tmp.area + "_sort")].opt.topdecor = [this.decorations];
                state[state.build.area].opt.layout_prefix = this.strings.prefix;
                state[state.build.area].opt.layout_suffix = this.strings.suffix;
                state[state.build.area].opt.layout_delimiter = this.strings.delimiter;
                state[state.build.area].opt.layout_decorations = this.decorations;
                if (state.tmp.cite_affixes) {
                    tok = new CSL.Token("else", CSL.START);
                    CSL.Node["else"].build.call(tok, state, target);
                }
            } // !this.locale_raw
            if (this.locale_raw) {
                if (!state.build.layout_locale_flag) {
                    var choose_tok = new CSL.Token("choose", CSL.START);
                    CSL.Node.choose.build.call(choose_tok, state, target);
                    my_tok.name = "if";
                    CSL.Attributes["@locale"].call(my_tok, state, this.locale_raw);
                    CSL.Node["if"].build.call(my_tok, state, target);
                } else {
                    my_tok.name = "else-if";
                    CSL.Attributes["@locale"].call(my_tok, state, this.locale_raw);
                    CSL.Node["else-if"].build.call(my_tok, state, target);
                }
                state.tmp.cite_affixes[my_tok.locale] = {};
                state.tmp.cite_affixes[my_tok.locale].delimiter = this.strings.delimiter;
                state.tmp.cite_affixes[my_tok.locale].suffix = this.strings.suffix;
            }
        }
        if (this.tokentype === CSL.END) {
            if (this.locale_raw) {
                if (!state.build.layout_locale_flag) {
                    my_tok.name = "if";
                    my_tok.tokentype = CSL.END;
                    CSL.Attributes["@locale"].call(my_tok, state, this.locale_raw);
                    CSL.Node["if"].build.call(my_tok, state, target);
                    state.build.layout_locale_flag = true;
                } else {
                    my_tok.name = "else-if";
                    my_tok.tokentype = CSL.END;
                    CSL.Attributes["@locale"].call(my_tok, state, this.locale_raw);
                    CSL.Node["else-if"].build.call(my_tok, state, target);
                }
            }
            if (!this.locale_raw) {
                if (state.tmp.cite_affixes) {
                    if (state.build.layout_locale_flag) {
                        tok = new CSL.Token("else", CSL.END);
                        CSL.Node["else"].build.call(tok, state, target);
                        tok = new CSL.Token("choose", CSL.END);
                        CSL.Node.choose.build.call(tok, state, target);
                    }
                }
                state.build_layout_locale_flag = true;
                if (state.build.area === "citation") {
                    suffix_token = new CSL.Token("text", CSL.SINGLETON);
                    func = function (state, Item, item) {
                        var sp;
                        if (item && item.suffix) {
                            sp = "";
                            if (item.suffix.match(CSL.STARTSWITH_ROMANESQUE_REGEXP)) {
                                sp = " ";
                            }
                            state.output.append((sp + item.suffix), this);
                        }
                    };
                    suffix_token.execs.push(func);
                    target.push(suffix_token);
                }
                func = function (state, Item) {
                    if (state.tmp.area === "bibliography") {
                        if (state.bibliography.opt["second-field-align"]) {
                            state.output.endTag();
                        }
                    }
                    state.output.closeLevel();
                };
                this.execs.push(func);
                target.push(this);
                state.build.layout_flag = false;
                state.build.layout_locale_flag = false;
            } // !this.layout_raw
        }
    }
};
CSL.Node.macro = {
    build: function (state, target) {}
};
CSL.NameOutput = function(state, Item, item, variables) {
    this.debug = false;
    this.state = state;
    this.Item = Item;
    this.item = item;
    this.nameset_base = 0;
    this.etal_spec = [];
    this._first_creator_variable = false;
    this._please_chop = false;
};
CSL.NameOutput.prototype.init = function (names) {
    if (this.nameset_offset) {
        this.nameset_base = this.nameset_base + this.nameset_offset;
    }
    this.nameset_offset = 0;
    this.names = names;
    this.variables = names.variables;
    this.state.tmp.value = [];
    for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
        if (this.Item[this.variables[i]] && this.Item[this.variables[i]].length) {
            this.state.tmp.value = this.state.tmp.value.concat(this.Item[this.variables[i]]);
        }
    }
    this["et-al"] = undefined;
    this["with"] = undefined;
    this.name = undefined;
    this.institutionpart = {};
    this.state.tmp.group_context.value()[1] = true;
    if (!this.state.tmp.value.length) {
        return;
    }
};
CSL.NameOutput.prototype.reinit = function (names) {
    if (this.state.tmp.can_substitute.value()) {
        this.nameset_offset = 0;
        this.variables = names.variables;
        var oldval = this.state.tmp.value.slice();
        this.state.tmp.value = [];
        for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
            if (this.Item[this.variables[i]] && this.Item[this.variables[i]].length) {
                this.state.tmp.value = this.state.tmp.value.concat(this.Item[this.variables[i]]);
            }
        }
        if (this.state.tmp.value.length) {
            this.state.tmp.can_substitute.replace(false, CSL.LITERAL);
        }
        this.state.tmp.value = oldval;
    }
};
CSL.NameOutput.prototype.outputNames = function () {
    var i, ilen;
    var variables = this.variables;
    if (this.institution.and) {
        if (!this.institution.and.single.blobs || !this.institution.and.single.blobs.length) {
            this.institution.and.single.blobs = this.name.and.single.blobs;
        }
        if (!this.institution.and.multiple.blobs || !this.institution.and.multiple.blobs.length) {
            this.institution.and.multiple.blobs = this.name.and.multiple.blobs;
        }
    }
    this.variable_offset = {};
    if (this.family) {
        this.family_decor = CSL.Util.cloneToken(this.family);
        this.family_decor.strings.prefix = "";
        this.family_decor.strings.suffix = "";
        for (i = 0, ilen = this.family.execs.length; i < ilen; i += 1) {
            this.family.execs[i].call(this.family_decor, this.state, this.Item);
        }
    } else {
        this.family_decor = false;
    }
    if (this.given) {
        this.given_decor = CSL.Util.cloneToken(this.given);
        this.given_decor.strings.prefix = "";
        this.given_decor.strings.suffix = "";
        for (i = 0, ilen = this.given.execs.length; i < ilen; i += 1) {
            this.given.execs[i].call(this.given_decor, this.state, this.Item);
        }
    } else {
        this.given_decor = false;
    }
    this.getEtAlConfig();
    this.divideAndTransliterateNames();
    this.truncatePersonalNameLists();
    this.disambigNames();
    this.constrainNames();
    if (this.name.strings.form === "count") {
        if (this.state.tmp.extension || this.names_count != 0) {
            this.state.output.append(this.names_count, "empty");
            this.state.tmp.group_context.value()[2] = true;
        }
        return;
    }
    this.setEtAlParameters();
    this.setCommonTerm();
    this.state.tmp.name_node = {};
    this.state.tmp.name_node.children = [];
    this.renderAllNames();
    var blob_list = [];
    for (i = 0, ilen = variables.length; i < ilen; i += 1) {
        var v = variables[i];
        var institution_sets = [];
        var institutions = false;
        for (var j = 0, jlen = this.institutions[v].length; j < jlen; j += 1) {
            institution_sets.push(this.joinPersonsAndInstitutions([this.persons[v][j], this.institutions[v][j]]));
        }
        if (this.institutions[v].length) {
            var pos = this.nameset_base + this.variable_offset[v];
            if (this.freeters[v].length) {
                pos += 1;
            }
            institutions = this.joinInstitutionSets(institution_sets, pos);
        }
        var varblob = this.joinFreetersAndInstitutionSets([this.freeters[v], institutions]);
        if (varblob) {
            varblob = this._applyLabels(varblob, v);
            blob_list.push(varblob);
        }
        if (this.common_term) {
            break;
        }
    }
    this.state.output.openLevel("empty");
    this.state.output.current.value().strings.delimiter = this.names.strings.delimiter;
    for (i = 0, ilen = blob_list.length; i < ilen; i += 1) {
        this.state.output.append(blob_list[i], "literal", true);
    }
    this.state.output.closeLevel("empty");
    var blob = this.state.output.pop();
    this.state.output.append(blob, this.names);
    this.state.tmp.name_node.top = this.state.output.current.value();
    if (variables[0] !== "authority") {
        var name_node_string = [];
        var nameobjs = this.Item[variables[0]];
        if (nameobjs) {
            for (var i = 0, ilen = nameobjs.length; i < ilen; i += 1) {
                substring = CSL.Util.Names.getRawName(nameobjs[i]);
                if (substring) {
                    name_node_string.push(substring);
                }
            }
        }
        name_node_string = name_node_string.join(", ");
        if (name_node_string) {
            this.state.tmp.name_node.string = name_node_string;
        }
    }
    if (this.state.tmp.name_node.string && !this.state.tmp.first_name_string) {
        this.state.tmp.first_name_string = this.state.tmp.name_node.string;
    }
    if ("classic" === this.Item.type) {
        var author_title = [];
        if (this.state.tmp.first_name_string) {
            author_title.push(this.state.tmp.first_name_string);
        }
        if (this.Item.title) {
            author_title.push(this.Item.title);
        }
        author_title = author_title.join(", ");
        if (author_title && this.state.sys.getAbbreviation) {
            this.state.transform.loadAbbreviation("default", "classic", author_title);
            if (this.state.transform.abbrevs["default"].classic[author_title]) {
                this.state.tmp.done_vars.push("title");
                this.state.output.append(this.state.transform.abbrevs["default"].classic[author_title], "empty", true);
                blob = this.state.output.pop();
				this.state.tmp.name_node.top.blobs.pop();
                this.state.tmp.name_node.top.blobs.push(blob);
            }
        }
    }
    this._collapseAuthor();
    this.variables = [];
};
CSL.NameOutput.prototype._applyLabels = function (blob, v) {
    var txt;
    if (!this.label) {
        return blob;
    }
    var plural = 0;
    var num = this.freeters_count[v] + this.institutions_count[v];
    if (num > 1) {
        plural = 1;
    } else {
        for (var i = 0, ilen = this.persons[v].length; i < ilen; i += 1) {
            num += this.persons_count[v][i];
        }
        if (num > 1) {
            plural = 1;
        }
    }
    if (this.label.before) {
        if ("number" === typeof this.label.before.strings.plural) {
            plural = this.label.before.strings.plural;
        }
        txt = this._buildLabel(v, plural, "before");
        this.state.output.openLevel("empty");
        this.state.output.append(txt, this.label.before, true);
        this.state.output.append(blob, "literal", true);
        this.state.output.closeLevel("empty");
        blob = this.state.output.pop();
    }
    if (this.label.after) {
        if ("number" === typeof this.label.after.strings.plural) {
            plural = this.label.after.strings.plural;
        }
        txt = this._buildLabel(v, plural, "after");
        this.state.output.openLevel("empty");
        this.state.output.append(blob, "literal", true);
        this.state.output.append(txt, this.label.after, true);
        this.state.output.closeLevel("empty");
        blob = this.state.output.pop();
    }
    return blob;
};
CSL.NameOutput.prototype._buildLabel = function (term, plural, position) {
    if (this.common_term) {
        term = this.common_term;
    }
    var ret = false;
    var node = this.label[position];
    if (node) {
        ret = CSL.castLabel(this.state, node, term, plural, CSL.TOLERANT);
    }
    return ret;
};
CSL.NameOutput.prototype._collapseAuthor = function () {
    var myqueue, mystr, oldchars;
    if (this.nameset_base === 0 && this.Item[this.variables[0]] && !this._first_creator_variable) {
        this._first_creator_variable = this.variables[0];
    }
    if ((this.item && this.item["suppress-author"] && this._first_creator_variable == this.variables[0])
        || (this.state[this.state.tmp.area].opt.collapse 
            && this.state[this.state.tmp.area].opt.collapse.length)) {
        if (this.state.tmp.authorstring_request) {
            mystr = "";
            myqueue = this.state.tmp.name_node.top.blobs.slice(-1)[0].blobs;
            oldchars = this.state.tmp.offset_characters;
            if (myqueue) {
                mystr = this.state.output.string(this.state, myqueue, false);
            }
            this.state.tmp.offset_characters = oldchars;
            this.state.registry.authorstrings[this.Item.id] = mystr;
        } else if (!this.state.tmp.just_looking
            && !this.state.tmp.suppress_decorations) {
            mystr = "";
            myqueue = this.state.tmp.name_node.top.blobs.slice(-1)[0].blobs;
            oldchars = this.state.tmp.offset_characters;
            if (myqueue) {
                mystr = this.state.output.string(this.state, myqueue, false);
            }
            if (mystr === this.state.tmp.last_primary_names_string) {
                this.state.tmp.name_node.top.blobs.pop();
                this.state.tmp.name_node.children = [];
                this.state.tmp.offset_characters = oldchars;
            } else {
                this.state.tmp.last_primary_names_string = mystr;
                if (this.variables.indexOf(this._first_creator_variable) > -1 && this.item && this.item["suppress-author"] && this.Item.type !== "legal_case") {
                    this.state.tmp.name_node.top.blobs.pop();
                    this.state.tmp.name_node.children = [];
                    this.state.tmp.offset_characters = oldchars;
                    this.state.tmp.term_predecessor = false;
                }
                this.state.tmp.have_collapsed = false;
            }
        }
    }
};
CSL.NameOutput.prototype.isPerson = function (value) {
    if (value.literal
        || (!value.given && value.family && value.isInstitution)) {
        return false;
    } else {
        return true;
    }
};
CSL.NameOutput.prototype.truncatePersonalNameLists = function () {
    var v, i, ilen, j, jlen, chopvar, values;
    this.freeters_count = {};
    this.persons_count = {};
    this.institutions_count = {};
    for (v in this.freeters) {
        if (this.freeters.hasOwnProperty(v)) {
            this.freeters_count[v] = this.freeters[v].length;
            this.freeters[v] = this._truncateNameList(this.freeters, v);
        }
    }
    for (v in this.persons) {
        if (this.persons.hasOwnProperty(v)) {
            this.institutions_count[v] = this.institutions[v].length;
            this._truncateNameList(this.institutions, v);
            this.persons[v] = this.persons[v].slice(0, this.institutions[v].length);
            this.persons_count[v] = [];
            for (j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
                this.persons_count[v][j] = this.persons[v][j].length;
                this.persons[v][j] = this._truncateNameList(this.persons, v, j);
            }
        }
    }
    if (this.etal_min === 1 && this.etal_use_first === 1 
        && !(this.state.tmp.extension
             || this.state.tmp.just_looking)) {
        chopvar = v;
    } else {
        chopvar = false;
    }
    if (chopvar || this._please_chop) {
        for (i = 0, ilen = this.variables.length; i < ilen; i += 1) {
            v = this.variables[i];
            if (this.freeters[v].length) {
                if (this._please_chop === v) {
                    this.freeters[v] = this.freeters[v].slice(1);
                    this.freeters_count[v] += -1;
                    this._please_chop = false;
                } else if (chopvar && !this._please_chop) {
                    this.freeters[v] = this.freeters[v].slice(0, 1);
                    this.freeters_count[v] = 1;
                    this.institutions[v] = [];
                    this.persons[v] = [];
                    this._please_chop = chopvar;
                }
            }
            for (i = 0, ilen = this.persons[v].length; i < ilen; i += 1) {
                if (this.persons[v][i].length) {
                    if (this._please_chop === v) {
                        this.persons[v][i] = this.persons[v][i].slice(1);
                        this.persons_count[v][i] += -1;
                        this._please_chop = false;
                        break;
                    } else if (chopvar && !this._please_chop) {
                        this.freeters[v] = this.persons[v][i].slice(0, 1);
                        this.freeters_count[v] = 1;
                        this.institutions[v] = [];
                        this.persons[v] = [];
                        values = [];
                        this._please_chop = chopvar;
                        break;
                    }
                }
            }
            if (this.institutions[v].length) {
                if (this._please_chop === v) {
                    this.institutions[v] = this.institutions[v].slice(1);
                    this.institutions_count[v] += -1;
                    this._please_chop = false;
                } else if (chopvar && !this._please_chop) {
                    this.institutions[v] = this.institutions[v].slice(0, 1);
                    this.institutions_count[v] = 1;
                    values = [];
                    this._please_chop = chopvar;
                }
            }
        }
    }
    for (i = 0, ilen = this.variables.length; i < ilen; i += 1) {
        if (this.institutions[v].length) {
            this.nameset_offset += 1;
        }
        for (i = 0, ilen = this.persons[v].length; i < ilen; i += 1) {
            if (this.persons[v][i].length) {
                this.nameset_offset += 1;
            }
        }
    }
};
CSL.NameOutput.prototype._truncateNameList = function (container, variable, index) {
    var lst;
    if ("undefined" === typeof index) {
        lst = container[variable];
    } else {
        lst = container[variable][index];
    }
    if (this.state.opt.max_number_of_names 
        && lst.length > 50 
        && lst.length > (this.state.opt.max_number_of_names + 2)) {
        lst = lst.slice(0, this.state.opt.max_number_of_names + 2);
    }
    return lst;
};
CSL.NameOutput.prototype.divideAndTransliterateNames = function () {
    var i, ilen, j, jlen;
    var Item = this.Item;
    var variables = this.variables;
    this.varnames = variables.slice();
    this.freeters = {};
    this.persons = {};
    this.institutions = {};
    for (i = 0, ilen = variables.length; i < ilen; i += 1) {
        var v = variables[i];
        this.variable_offset[v] = this.nameset_offset;
        var values = this._normalizeVariableValue(Item, v);
        if (this.name.strings["suppress-min"] && values.length >= this.name.strings["suppress-min"]) {
            values = [];
        }
        if (this.name.strings["suppress-max"] && values.length <= this.name.strings["suppress-max"]) {
            values = [];
        }
        this._getFreeters(v, values);
        this._getPersonsAndInstitutions(v, values);
        if (this.name.strings["suppress-min"] === 0) {
            this.freeters[v] = [];
            for (j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
                this.persons[v][j] = [];
            }
        } else if (this.institution.strings["suppress-min"] === 0) {
            this.institutions[v] = [];
            this.freeters[v] = this.freeters[v].concat(this.persons[v]);
            for (j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
                for (var k = 0, klen = this.persons[v][j].length; k < klen; k += 1) {
                    this.freeters[v].push(this.persons[v][j][k]);
                }
            }
            this.persons[v] = [];
        }
    }
};
CSL.NameOutput.prototype._normalizeVariableValue = function (Item, variable) {
    var names, name, i, ilen;
    if ("string" === typeof Item[variable]) {
        names = [{literal: Item[variable]}];
    } else if (!Item[variable]) {
        names = [];
    } else {
        names = Item[variable].slice();
    }
    return names;
};
CSL.NameOutput.prototype._getFreeters = function (v, values) {
    this.freeters[v] = [];
    for (var i = values.length - 1; i > -1; i += -1) {
        if (this.isPerson(values[i])) {
            var value = this._checkNickname(values.pop());
            if (value) {
                this.freeters[v].push(value);
            }
        } else {
            break;
        }
    }
    this.freeters[v].reverse();
    if (this.freeters[v].length) {
        this.nameset_offset += 1;
    }
};
CSL.NameOutput.prototype._getPersonsAndInstitutions = function (v, values) {
    this.persons[v] = [];
    this.institutions[v] = [];
    var persons = [];
    var has_affiliates = false;
    var first = true;
    for (var i = values.length - 1; i > -1; i += -1) {
        if (this.isPerson(values[i])) {
            var value = this._checkNickname(values[i]);
            if (value) {
                persons.push(value);
            }
        } else {
            has_affiliates = true;
            this.institutions[v].push(values[i]);
            if (!first) {
                persons.reverse();
                this.persons[v].push(persons);
                persons = [];
            }
            first = false;
        }
    }
    if (has_affiliates) {
        persons.reverse();
        this.persons[v].push(persons);
        this.persons[v].reverse();
        this.institutions[v].reverse();
    }
};
CSL.NameOutput.prototype._clearValues = function (values) {
    for (var i = values.length - 1; i > -1; i += -1) {
        values.pop();
    }
};
CSL.NameOutput.prototype._checkNickname = function (name) {
    if (["interview", "personal_communication"].indexOf(this.Item.type) > -1) {
        var author = "";
        author = CSL.Util.Names.getRawName(name);
        if (author && this.state.sys.getAbbreviation && !(this.item && this.item["suppress-author"])) {
            this.state.transform.loadAbbreviation("default", "nickname", author);
            var myLocalName = this.state.transform.abbrevs["default"].nickname[author];
            if (myLocalName) {
                if (myLocalName === "{suppress}") {
                    name = false;
                } else {
                    name = {family:myLocalName,given:''};
                }
            }
        }
    }
    return name;
}
CSL.NameOutput.prototype.joinPersons = function (blobs, pos) {
    var ret;
    if (this.etal_spec[pos] === 1) {
        ret = this._joinEtAl(blobs, "name");
    } else if (this.etal_spec[pos] === 2) {
        ret = this._joinEllipsis(blobs, "name");
    } else if (!this.state.tmp.sort_key_flag) {
        ret = this._joinAnd(blobs, "name");
    } else {
        ret = this._join(blobs, " ");
    }
    return ret;
};
CSL.NameOutput.prototype.joinInstitutionSets = function (blobs, pos) {
    var ret;
    if (this.etal_spec[pos] === 1) {
        ret = this._joinEtAl(blobs, "institution");
    } else if (this.etal_spec[pos] === 2) {
        ret = this._joinEllipsis(blobs, "institution");
    } else {
        ret = this._joinAnd(blobs, "institution");
    }
    return ret;
};
CSL.NameOutput.prototype.joinPersonsAndInstitutions = function (blobs) {
    return this._join(blobs, this.name.strings.delimiter);
};
CSL.NameOutput.prototype.joinFreetersAndInstitutionSets = function (blobs) {
    var ret = this._join(blobs, "[never here]", this["with"].single, this["with"].multiple);
    return ret;
};
CSL.NameOutput.prototype._joinEtAl = function (blobs, tokenname) {
    var blob = this._join(blobs, this.name.strings.delimiter);
    this.state.output.openLevel(this._getToken(tokenname));
    this.state.output.current.value().strings.delimiter = "";
    this.state.output.append(blob, "literal", true);
    if (blobs.length > 1) {
        this.state.output.append(this["et-al"].multiple, "literal", true);
    } else if (blobs.length === 1) {
        this.state.output.append(this["et-al"].single, "literal", true);
    }
    this.state.output.closeLevel();
    return this.state.output.pop();
};
CSL.NameOutput.prototype._joinEllipsis = function (blobs, tokenname) {
    return this._join(blobs, this.name.strings.delimiter, this.name.ellipsis.single, this.name.ellipsis.multiple, tokenname);
};
CSL.NameOutput.prototype._joinAnd = function (blobs, tokenname) {
    return this._join(blobs, this[tokenname].strings.delimiter, this[tokenname].and.single, this[tokenname].and.multiple, tokenname);
};
CSL.NameOutput.prototype._join = function (blobs, delimiter, single, multiple, tokenname) {
    var i, ilen;
    if (!blobs) {
        return false;
    }
    for (i = blobs.length - 1; i > -1; i += -1) {
        if (!blobs[i] || blobs[i].length === 0 || !blobs[i].blobs.length) {
            blobs = blobs.slice(0, i).concat(blobs.slice(i + 1));
        }
    }
    if (!blobs.length) {
        return false;
    } else if (single && blobs.length === 2) {
        blobs = [blobs[0], single, blobs[1]];
    } else {
        var delimiter_offset;
        if (multiple) {
            delimiter_offset = 2;
        } else {
            delimiter_offset = 1;
        }
        for (i = 0, ilen = blobs.length - delimiter_offset; i < ilen; i += 1) {
            blobs[i].strings.suffix += delimiter;
        }
        if (blobs.length > 1) {
            var blob = blobs.pop();
            if (multiple) {
                blobs.push(multiple);
            } else {
                blobs.push(single);
            }
            blobs.push(blob);
        }
    }
    this.state.output.openLevel(this._getToken(tokenname));
    if (single && multiple) {
        this.state.output.current.value().strings.delimiter = "";
    }
    for (i = 0, ilen = blobs.length; i < ilen; i += 1) {
        this.state.output.append(blobs[i], false, true);
    }
    this.state.output.closeLevel();
    return this.state.output.pop();
};
CSL.NameOutput.prototype._getToken = function (tokenname) {
    var token = this[tokenname];
    if (tokenname === "institution") {
        var newtoken = new CSL.Token();
        return newtoken;
    }
    return token;
};
CSL.NameOutput.prototype.disambigNames = function () {
    var pos = this.nameset_base;
    for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
        var v = this.variables[i];
        if (this.freeters[v].length) {
            this._runDisambigNames(this.freeters[v], pos);
            pos += 1;
        }
        if (this.institutions[v].length) {
            pos += 1;
        }
        for (var j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
            if (this.persons[v][j].length) {
                this._runDisambigNames(this.persons[v][j], pos);
                this.state.tmp.disambig_settings.givens.push([]);
                pos += 1;
            }
        }
    }
};
CSL.NameOutput.prototype._runDisambigNames = function (lst, pos) {
    var chk, myform, myinitials, param, i, ilen, paramx;
    for (i = 0, ilen = lst.length; i < ilen; i += 1) {
        if (!lst[i].given && !lst[i].family) {
            continue;
        }
        myinitials = this.name.strings["initialize-with"];
        this.state.registry.namereg.addname("" + this.Item.id, lst[i], i);
        chk = this.state.tmp.disambig_settings.givens[pos];
        if ("undefined" === typeof chk) {
            for (var j = 0, jlen = pos + 1; j < jlen; j += 1) {
                if (!this.state.tmp.disambig_settings.givens[j]) {
                    this.state.tmp.disambig_settings.givens[j] = [];
                }
            }
        }
        chk = this.state.tmp.disambig_settings.givens[pos][i];
        if ("undefined" === typeof chk) {
            myform = this.name.strings.form;
            param = this.state.registry.namereg.evalname("" + this.Item.id, lst[i], i, 0, myform, myinitials);
            this.state.tmp.disambig_settings.givens[pos].push(param);
        }
        myform = this.name.strings.form;
        paramx = this.state.registry.namereg.evalname("" + this.Item.id, lst[i], i, 0, myform, myinitials);
        if (this.state.tmp.disambig_request) {
            var val = this.state.tmp.disambig_settings.givens[pos][i];
            if (val === 1 && 
                this.state.opt["givenname-disambiguation-rule"] === "by-cite" && 
                "undefined" === typeof this.name.strings["initialize-with"]) {
                val = 2;
            }
            param = val;
            if (this.state.opt["disambiguate-add-givenname"]) {
                param = this.state.registry.namereg.evalname("" + this.Item.id, lst[i], i, param, this.name.strings.form, this.name.strings["initialize-with"]);
            }
        } else {
            param = paramx;
        }
        if (!this.state.tmp.just_looking && this.item && this.item.position === CSL.POSITION_FIRST) {
            param = paramx;
        }
        if (!this.state.tmp.sort_key_flag) {
            this.state.tmp.disambig_settings.givens[pos][i] = param;
            if ("string" === typeof myinitials
                && ("undefined" === typeof this.name.strings["initialize"]
                    || true === this.name.strings["initialize"])) {
                this.state.tmp.disambig_settings.use_initials = true;
            }
        }
    }
};
CSL.NameOutput.prototype.setCommonTerm = function () {
    var variables = this.variables;
    var varnames = variables.slice();
    varnames.sort();
    this.common_term = varnames.join("");
    if (!this.common_term) {
        return false;
    }
    var has_term = false;
    if (this.label) {
        if (this.label.before) {
            has_term = this.state.getTerm(this.common_term, this.label.before.strings.form, 0);
        } else if (this.label.after) {
            has_term = this.state.getTerm(this.common_term, this.label.after.strings.form, 0);
        }
    }
    if (!this.state.locale[this.state.opt.lang].terms[this.common_term]
        || !has_term
        || this.variables.length < 2) {
        this.common_term = false;
        return;
    }
    var freeters_offset = 0;
    for (var i = 0, ilen = this.variables.length - 1; i < ilen; i += 1) {
        var v = this.variables[i];
        var vv = this.variables[i + 1];
        if (this.freeters[v].length || this.freeters[vv].length) {
            if (this.etal_spec[this.variable_offset[v]] !== this.etal_spec[this.variable_offset[vv]]
                || !this._compareNamesets(this.freeters[v], this.freeters[vv])) {
                this.common_term = false;
                return;
            }
            freeters_offset += 1;
        }
        for (var j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
            if (this.etal_spec[this.variable_offset[v] + freeters_offset + j + 1] !== this.etal_spec[this.variable_offset + freeters_offset + j + 1]
                || !this._compareNamesets(this.persons[v][j], this.persons[vv][j])) {
                this.common_term = false;
                return;
            }
        }
    }
};
CSL.NameOutput.prototype._compareNamesets = function (base_nameset, nameset) {
    if (base_nameset.length !== nameset.length) {
        return false;
    }
    for (var i = 0, ilen = nameset.length; i < ilen; i += 1) {
        var name = nameset[i];
        for (var j = 0, jlen = CSL.NAME_PARTS.length; j < jlen; j += 1) {
            var part = CSL.NAME_PARTS[j];
            if (!base_nameset[i] || base_nameset[i][part] != nameset[i][part]) {
                return false;
            }
        }
    }
    return true;
};
CSL.NameOutput.prototype.constrainNames = function () {
    this.names_count = 0;
    var pos = this.nameset_base;
    for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
        var v = this.variables[i];
        if (this.freeters[v].length) {
            this.state.tmp.names_max.push(this.freeters[v].length, "literal");
            this._imposeNameConstraints(this.freeters, this.freeters_count, v, pos);
            this.names_count += this.freeters[v].length;
            pos += 1;
        }
        if (this.institutions[v].length) {
            this.state.tmp.names_max.push(this.institutions[v].length, "literal");
            this._imposeNameConstraints(this.institutions, this.institutions_count, v, pos);
            this.persons[v] = this.persons[v].slice(0, this.institutions[v].length);
            this.names_count += this.institutions[v].length;
            pos += 1;
        }
        for (var j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
            if (this.persons[v][j].length) {
                this.state.tmp.names_max.push(this.persons[v][j].length, "literal");
                this._imposeNameConstraints(this.persons[v], this.persons_count[v], j, pos);
                this.names_count += this.persons[v][j].length;
                pos += 1;
            }
        }
    }
};
CSL.NameOutput.prototype._imposeNameConstraints = function (lst, count, key, pos) {
    var display_names = lst[key];
    var discretionary_names_length = this.state.tmp["et-al-min"];
    if (this.state.tmp.suppress_decorations) {
        if (this.state.tmp.disambig_request) {
            discretionary_names_length = this.state.tmp.disambig_request.names[pos];
        } else if (count[key] >= this.etal_min) {
            discretionary_names_length = this.etal_use_first;
        }
    } else {
        if (this.state.tmp.disambig_request 
            && this.state.tmp.disambig_request.names[pos] > this.etal_use_first) {
            if (count[key] < this.etal_min) {
                discretionary_names_length = count[key];
            } else {
                discretionary_names_length = this.state.tmp.disambig_request.names[pos];
            }
        } else if (count[key] >= this.etal_min) {
            discretionary_names_length = this.etal_use_first;
        }
        if (this.etal_use_last && discretionary_names_length > (this.etal_min - 2)) {
            discretionary_names_length = this.etal_min - 2;
        }
    }
    var sane = this.etal_min >= this.etal_use_first;
    var overlength = count[key] > discretionary_names_length;
    if (discretionary_names_length > count[key]) {
        discretionary_names_length = display_names.length;
    }
    if (sane && overlength) {
        if (this.etal_use_last) {
            lst[key] = display_names.slice(0, discretionary_names_length).concat(display_names.slice(-1));
        } else {
            lst[key] = display_names.slice(0, discretionary_names_length);
        }
        if (!lst[key].length) {
            this.etal_spec.push(0);
        }
    }
    this.state.tmp.disambig_settings.names[pos] = lst[key].length;
};
CSL.NameOutput.prototype.getEtAlConfig = function () {
    var item = this.item;
    this["et-al"] = {};
    this.state.output.append(this.etal_term, this.etal_style, true);
    this["et-al"].single = this.state.output.pop();
    this["et-al"].single.strings.suffix = this.etal_suffix;
    this["et-al"].single.strings.prefix = this.etal_prefix_single;
    this.state.output.append(this.etal_term, this.etal_style, true);
    this["et-al"].multiple = this.state.output.pop();
    this["et-al"].multiple.strings.suffix = this.etal_suffix;
    this["et-al"].multiple.strings.prefix = this.etal_prefix_multiple;
    if ("undefined" === typeof item) {
        item = {};
    }
    if (item.position) {
        if (this.name.strings["et-al-subsequent-min"]) {
            this.etal_min = this.name.strings["et-al-subsequent-min"];
        } else {
            this.etal_min = this.name.strings["et-al-min"];
        }
        if (this.name.strings["et-al-subsequent-use-first"]) {
            this.etal_use_first = this.name.strings["et-al-subsequent-use-first"];
        } else {
            this.etal_use_first = this.name.strings["et-al-use-first"];
        }
    } else {
        if (this.state.tmp["et-al-min"]) {
            this.etal_min = this.state.tmp["et-al-min"];
        } else {
            this.etal_min = this.name.strings["et-al-min"];
        }
        if (this.state.tmp["et-al-use-first"]) {
            this.etal_use_first = this.state.tmp["et-al-use-first"];
        } else {
            this.etal_use_first = this.name.strings["et-al-use-first"];
        }
        if ("boolean" === typeof this.state.tmp["et-al-use-last"]) {
            this.etal_use_last = this.state.tmp["et-al-use-last"];
        } else {
            this.etal_use_last = this.name.strings["et-al-use-last"];
        }
    }
    if (!this.state.tmp["et-al-min"]) {
        this.state.tmp["et-al-min"] = this.etal_min;
    }
};
CSL.NameOutput.prototype.renderAllNames = function () {
    var pos = this.nameset_base;
    for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
        var v = this.variables[i];
        if (this.freeters[v].length) {
            this.freeters[v] = this._renderPersonalNames(this.freeters[v], pos);
            pos += 1;
        }
        if (this.institutions[v].length) {
            pos += 1;
        }
        for (var j = 0, jlen = this.institutions[v].length; j < jlen; j += 1) {
            this.persons[v][j] = this._renderPersonalNames(this.persons[v][j], pos);
            pos += 1;
        }
    }
    this.renderInstitutionNames();
};
CSL.NameOutput.prototype.renderInstitutionNames = function () {
    for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
        var v = this.variables[i];
        for (var j = 0, jlen = this.institutions[v].length; j < jlen; j += 1) {
            var institution, institution_short, institution_long, short_style, long_style;
            var name = this.institutions[v][j];
            var j, ret, optLangTag, jlen, key, localesets;
            if (this.state.tmp.extension) {
                localesets = ["sort"];
            } else if (name.isInstitution) {
                localesets = this.state.opt['cite-lang-prefs'].institutions;
            } else {
                localesets = this.state.opt['cite-lang-prefs'].persons;
            }
            slot = {primary:false,secondary:false,tertiary:false};
	        if (localesets) {
		        var slotnames = ["primary", "secondary", "tertiary"];
		        for (var k = 0, klen = slotnames.length; k < klen; k += 1) {
			        if (localesets.length - 1 <  j) {
				        break;
			        }
                    if (localesets[k]) {
			            slot[slotnames[k]] = 'locale-' + localesets[k];
                    }
		        }
	        } else {
		        slot.primary = 'locale-translat';
	        }
	        if (this.state.tmp.area !== "bibliography"
		        && !(this.state.tmp.area === "citation"
			         && this.state.opt.xclass === "note"
			         && this.item && !this.item.position)) {
		        slot.secondary = false;
		        slot.tertiary = false;
	        }
            var res;
            res = this.getName(name, slot.primary, true);
            var primary = res.name;
            var usedOrig = res.usedOrig;
            if (primary) {
                primary = this.fixupInstitution(primary, v, j);
            }
			secondary = false;
			if (slot.secondary) {
                res = this.getName(name, slot.secondary, false, usedOrig);
                secondary = res.name;
                usedOrig = res.usedOrig;
                if (secondary) {
				    secondary = this.fixupInstitution(secondary, v, j);
                }
			}
			tertiary = false;
			if (slot.tertiary) {
                res = this.getName(name, slot.tertiary, false, usedOrig);
                tertiary = res.name;
                if (tertiary) {
				    tertiary = this.fixupInstitution(tertiary, v, j);
                }
			}
            switch (this.institution.strings["institution-parts"]) {
            case "short":
                if (primary["short"].length) {
                    short_style = this._getShortStyle();
                    institution = [this._renderOneInstitutionPart(primary["short"], short_style)];
                } else {
                    long_style = this._getLongStyle(primary, v, j);
                    institution = [this._renderOneInstitutionPart(primary["long"], long_style)];
                }
                break;
            case "short-long":
                long_style = this._getLongStyle(primary, v, j);
                short_style = this._getShortStyle();
                institution_short = this._renderOneInstitutionPart(primary["short"], short_style);
                institution_long = this._composeOneInstitutionPart([primary, secondary, tertiary], long_style);
                institution = [institution_short, institution_long];
                break;
            case "long-short":
                long_style = this._getLongStyle(primary, v, j);
                short_style = this._getShortStyle();
                institution_short = this._renderOneInstitutionPart(primary["short"], short_style);
                institution_long = this._composeOneInstitutionPart([primary, secondary, tertiary], long_style, true);
                institution = [institution_long, institution_short];
                break;
            default:
                long_style = this._getLongStyle(primary, v, j);
                institution = [this._composeOneInstitutionPart([primary, secondary, tertiary], long_style)];
                break;
            }
            this.institutions[v][j] = this._join(institution, "");
        }
    }
};
CSL.NameOutput.prototype._composeOneInstitutionPart = function (names, style) {
    var primary = false, secondary = false, tertiary = false;
    if (names[0]) {
        primary = this._renderOneInstitutionPart(names[0]["long"], style);
    }
    if (names[1]) {
        secondary = this._renderOneInstitutionPart(names[1]["long"], style);
    }
    if (names[2]) {
        tertiary = this._renderOneInstitutionPart(names[2]["long"], style);
    }
    var institutionblob;
    if (secondary || tertiary) {
        var multiblob = this._join([secondary, tertiary], ", ");
        var group_tok = new CSL.Token();
        group_tok.strings.prefix = " [";
        group_tok.strings.suffix = "]";
        this.state.output.openLevel(group_tok);
        this.state.output.append(multiblob);
        this.state.output.closeLevel();
        multiblob = this.state.output.pop();
        institutionblob = this._join([primary, multiblob], "");
    } else {
        institutionblob = primary;
    }
    return institutionblob;
}
CSL.NameOutput.prototype._renderOneInstitutionPart = function (blobs, style) {
    for (var i = 0, ilen = blobs.length; i < ilen; i += 1) {
        if (blobs[i]) {
            var str = blobs[i];
            if (this.state.tmp.strip_periods) {
                str = str.replace(/\./g, "");
            } else {
                for (var j = 0, jlen = style.decorations.length; j < jlen; j += 1) {
                    if ("@strip-periods" === style.decorations[j][0] && "true" === style.decorations[j][1]) {
                        str = str.replace(/\./g, "");
                        break;
                    }
                }
            }
            this.state.tmp.group_context.value()[2] = true;
            this.state.tmp.can_substitute.replace(false, CSL.LITERAL);
            this.state.output.append(str, style, true);
            blobs[i] = this.state.output.pop();
        }
    }
    if ("undefined" === typeof this.institution.strings["part-separator"]) {
        this.institution.strings["part-separator"] = this.name.strings.delimiter;
    }
    return this._join(blobs, this.institution.strings["part-separator"]);
};
CSL.NameOutput.prototype._renderPersonalNames = function (values, pos) {
    var ret = false;
    if (values.length) {
        var names = [];
        for (var i = 0, ilen = values.length; i < ilen; i += 1) {
            var name = values[i];
            var j, ret, optLangTag, jlen, key, localesets;
            if (this.state.tmp.extension) {
                localesets = ["sort"];
            } else if (name.isInstitution) {
                localesets = this.state.opt['cite-lang-prefs'].institutions;
            } else {
                localesets = this.state.opt['cite-lang-prefs'].persons;
            }
            slot = {primary:false,secondary:false,tertiary:false};
	        if (localesets) {
		        var slotnames = ["primary", "secondary", "tertiary"];
		        for (var j = 0, jlen = slotnames.length; j < jlen; j += 1) {
			        if (localesets.length - 1 <  j) {
				        break;
			        }
			        slot[slotnames[j]] = 'locale-' + localesets[j];
		        }
	        } else {
		        slot.primary = 'locale-translat';
	        }
	        if (this.state.tmp.sort_key_flag || (this.state.tmp.area !== "bibliography"
		        && !(this.state.tmp.area === "citation"
			         && this.state.opt.xclass === "note"
			         && this.item && !this.item.position))) {
		        slot.secondary = false;
		        slot.tertiary = false;
	        }
            var res = this.getName(name, slot.primary, true);
            var primary = this._renderOnePersonalName(res.name, pos, i);
			secondary = false;
			if (slot.secondary) {
                res = this.getName(name, slot.secondary, false, res.usedOrig);
                if (res.name) {
				    secondary = this._renderOnePersonalName(res.name, pos, i);
                }
			}
			tertiary = false;
			if (slot.tertiary) {
                res = this.getName(name, slot.tertiary, false, res.usedOrig);
                if (res.name) {
				    tertiary = this._renderOnePersonalName(res.name, pos, i);
                }
			}
            var personblob;
            if (secondary || tertiary) {
                var multiblob = this._join([secondary, tertiary], ", ");
                var group_tok = new CSL.Token();
                group_tok.strings.prefix = " [";
                group_tok.strings.suffix = "]";
                this.state.output.openLevel(group_tok);
                this.state.output.append(multiblob);
                this.state.output.closeLevel();
                multiblob = this.state.output.pop();
                personblob = this._join([primary, multiblob], "");
            } else {
                personblob = primary;
            }
            names.push(personblob);
        }
        ret = this.joinPersons(names, pos);
    }
    return ret;
};
CSL.NameOutput.prototype._renderOnePersonalName = function (value, pos, i) {
    var name = value;
    var dropping_particle = this._droppingParticle(name, pos);
    var family = this._familyName(name);
    var non_dropping_particle = this._nonDroppingParticle(name);
    var given = this._givenName(name, pos, i);
    var suffix = this._nameSuffix(name);
    if (this._isShort(pos, i)) {
        dropping_particle = false;
        given = false;
        suffix = false;
    }
    var sort_sep = this.name.strings["sort-separator"];
    if (!sort_sep) {
        sort_sep = "";
    }
    var suffix_sep;
    if (name["comma-suffix"]) {
        suffix_sep = ", ";
    } else {
        suffix_sep = " ";
    }
    var romanesque = name.family.match(CSL.ROMANESQUE_REGEXP);
    var blob, merged, first, second;
    if (!romanesque) {
        blob = this._join([non_dropping_particle, family, given], "");
    } else if (name["static-ordering"]) { // entry likes sort order
        blob = this._join([non_dropping_particle, family, given], " ");
    } else if (this.state.tmp.sort_key_flag) {
        if (this.state.opt["demote-non-dropping-particle"] === "never") {
            first = this._join([non_dropping_particle, family, dropping_particle], " ");
            merged = this._join([first, given], " ");
            blob = this._join([merged, suffix], " ");
        } else {
            second = this._join([given, dropping_particle, non_dropping_particle], " ");
            merged = this._join([family, second], " ");
            blob = this._join([merged, suffix], " ");
        }
    } else if (this.name.strings["name-as-sort-order"] === "all" || (this.name.strings["name-as-sort-order"] === "first" && i === 0)) {
        if (["Lord", "Lady"].indexOf(name.given) > -1) {
            sort_sep = ", ";
        }
        if (["always", "display-and-sort"].indexOf(this.state.opt["demote-non-dropping-particle"]) > -1) {
            second = this._join([given, dropping_particle], (name["comma-dropping-particle"] + " "));
            second = this._join([second, non_dropping_particle], " ");
            if (second && this.given) {
                second.strings.prefix = this.given.strings.prefix;
                second.strings.suffix = this.given.strings.suffix;
            }
            if (family && this.family) {
                family.strings.prefix = this.family.strings.prefix;
                family.strings.suffix = this.family.strings.suffix;
            }
            merged = this._join([family, second], sort_sep);
            blob = this._join([merged, suffix], sort_sep);
        } else {
            first = this._join([non_dropping_particle, family], " ");
            if (first && this.family) {
                first.strings.prefix = this.family.strings.prefix;
                first.strings.suffix = this.family.strings.suffix;
            }
            second = this._join([given, dropping_particle], (name["comma-dropping-particle"] + " "));
            if (second && this.given) {
                second.strings.prefix = this.given.strings.prefix;
                second.strings.suffix = this.given.strings.suffix;
            }
            merged = this._join([first, second], sort_sep);
            blob = this._join([merged, suffix], sort_sep);
        }
    } else { // plain vanilla
        if (name["dropping-particle"] && name.family && !name["non-dropping-particle"]) {
            if (["'","\u02bc","\u2019"].indexOf(name["dropping-particle"].slice(-1)) > -1) {
                family = this._join([dropping_particle, family], "");
                dropping_particle = false;
            }
        }
        second = this._join([dropping_particle, non_dropping_particle, family], " ");
        second = this._join([second, suffix], suffix_sep);
        if (second && this.family) {
            second.strings.prefix = this.family.strings.prefix;
            second.strings.suffix = this.family.strings.suffix;
        }
        if (given && this.given) {
            given.strings.prefix = this.given.strings.prefix;
            given.strings.suffix = this.given.strings.suffix;
        }
        if (second.strings.prefix) {
            name["comma-dropping-particle"] = "";
        }
        blob = this._join([given, second], (name["comma-dropping-particle"] + " "));
    }
    this.state.tmp.group_context.value()[2] = true;
    this.state.tmp.can_substitute.replace(false, CSL.LITERAL);
    this.state.tmp.name_node.children.push(blob);
    return blob;
};
CSL.NameOutput.prototype._isShort = function (pos, i) {
    if (0 === this.state.tmp.disambig_settings.givens[pos][i]) {
        return true;
    } else {
        return false;
    }
};
CSL.NameOutput.prototype._normalizeNameInput = function (value) {
    var name = {
        literal:value.literal,
        family:value.family,
        isInstitution:value.isInstitution,
        given:value.given,
        suffix:value.suffix,
        "comma-suffix":value["comma-suffix"],
        "non-dropping-particle":value["non-dropping-particle"],
        "dropping-particle":value["dropping-particle"],
        "static-ordering":value["static-ordering"],
        "parse-names":value["parse-names"],
        "comma-dropping-particle": "",
        block_initialize:value.block_initialize,
        multi:value.multi
    };
    this._parseName(name);
    return name;
};
CSL.NameOutput.prototype._stripPeriods = function (tokname, str) {
    var decor_tok = this[tokname + "_decor"];
    if (str) {
        if (this.state.tmp.strip_periods) {
            str = str.replace(/\./g, "");
        } else  if (decor_tok) {
            for (var i = 0, ilen = decor_tok.decorations.length; i < ilen; i += 1) {
                if ("@strip-periods" === decor_tok.decorations[i][0] && "true" === decor_tok.decorations[i][1]) {
                    str = str.replace(/\./g, "");
                    break;
                }
            }
        }
    }
    return str;
};
CSL.NameOutput.prototype._nonDroppingParticle = function (name) {
    var str = this._stripPeriods("family", name["non-dropping-particle"]);
    if (this.state.output.append(str, this.family_decor, true)) {
        return this.state.output.pop();
    }
    return false;
};
CSL.NameOutput.prototype._droppingParticle = function (name, pos) {
    var str = this._stripPeriods("given", name["dropping-particle"]);
    if (name["dropping-particle"] && name["dropping-particle"].match(/^et.?al[^a-z]$/)) {
        if (this.name.strings["et-al-use-last"]) {
            this.etal_spec[pos] = 2;
        } else {
            this.etal_spec[pos] = 1;
        }
        name["comma-dropping-particle"] = "";
    } else if (this.state.output.append(str, this.given_decor, true)) {
        return this.state.output.pop();
    }
    return false;
};
CSL.NameOutput.prototype._familyName = function (name) {
    var str = this._stripPeriods("family", name.family);
    if (this.state.output.append(str, this.family_decor, true)) {
        return this.state.output.pop();
    }
    return false;
};
CSL.NameOutput.prototype._givenName = function (name, pos, i) {
    if (this.name.strings.initialize === false) {
        if (name.family && name.given && this.name.strings.initialize === false) {
            name.given = CSL.Util.Names.initializeWith(this.state, name.given, this.name.strings["initialize-with"], true);
        }
        name.given = CSL.Util.Names.unInitialize(this.state, name.given);
    } else {
        if (name.family && 1 === this.state.tmp.disambig_settings.givens[pos][i] && !name.block_initialize) {
            var initialize_with = this.name.strings["initialize-with"];
            name.given = CSL.Util.Names.initializeWith(this.state, name.given, initialize_with);
        } else {
            name.given = CSL.Util.Names.unInitialize(this.state, name.given);
        }
    }
    var str = this._stripPeriods("given", name.given);
    if (this.state.output.append(str, this.given_decor, true)) {
        return this.state.output.pop();
    }
    return false;
};
CSL.NameOutput.prototype._nameSuffix = function (name) {
    var str = name.suffix;
    if ("string" === typeof this.name.strings["initialize-with"]) {
        str = CSL.Util.Names.initializeWith(this.state, name.suffix, this.name.strings["initialize-with"], true);
    }
    str = this._stripPeriods("family", str);
    if (this.state.output.append(str, "empty", true)) {
        return this.state.output.pop();
    }
    return false;
};
CSL.NameOutput.prototype._getLongStyle = function (name, v, i) {
    var long_style, short_style;
    if (name["short"].length) {
        if (this.institutionpart["long-with-short"]) {
            long_style = this.institutionpart["long-with-short"];
        } else {
            long_style = this.institutionpart["long"];
        }
    } else {
        long_style = this.institutionpart["long"];
    }
    if (!long_style) {
        long_style = new CSL.Token();
    }
    return long_style;
};
CSL.NameOutput.prototype._getShortStyle = function () {
    var short_style;
    if (this.institutionpart["short"]) {
        short_style = this.institutionpart["short"];
    } else {
        short_style = new CSL.Token();
    }
    return short_style;
};
CSL.NameOutput.prototype._parseName = function (name) {
    var m, idx;
    if (!name["parse-names"] && "undefined" !== typeof name["parse-names"]) {
        return name;
    }
    if (name.family && !name.given && name.isInstitution) {
        name.literal = name.family;
        name.family = undefined;
        name.isInstitution = undefined;
    }
    var noparse;
    if (name.family 
        && (name.family.slice(0, 1) === '"' && name.family.slice(-1) === '"')
        || (!name["parse-names"] && "undefined" !== typeof name["parse-names"])) {
        name.family = name.family.slice(1, -1);
        noparse = true;
        name["parse-names"] = 0;
    } else {
        noparse = false;
    }
    if (!name["non-dropping-particle"] && name.family && !noparse) {
        m = name.family.match(/^((?:[a-z][ \'\u2019a-z]*[\s+|\'\u2019]|[DVL][^ ]\s+[a-z]*\s*|[DVL][^ ][^ ]\s+[a-z]*\s*))/);
        if (m) {
            name.family = name.family.slice(m[1].length);
            name["non-dropping-particle"] = m[1].replace(/\s+$/, "");
        }
    }
    if (!name.suffix && name.given) {
        m = name.given.match(/(\s*,!*\s*)/);
        if (m) {
            idx = name.given.indexOf(m[1]);
            var possible_suffix = name.given.slice(idx + m[1].length);
            var possible_comma = name.given.slice(idx, idx + m[1].length).replace(/\s*/g, "");
            if (possible_suffix.length <= 3) {
                if (possible_comma.length === 2) {
                    name["comma-suffix"] = true;
                }
                name.suffix = possible_suffix;
            } else if (!name["dropping-particle"] && name.given) {
                name["dropping-particle"] = possible_suffix;
                name["comma-dropping-particle"] = ",";
            }
            name.given = name.given.slice(0, idx);
        }
    }
    if (!name["dropping-particle"] && name.given) {
        m = name.given.match(/(\s+)([a-z][ \'\u2019a-z]*)$/);
        if (m) {
            name.given = name.given.slice(0, (m[1].length + m[2].length) * -1);
            name["dropping-particle"] = m[2];
        }
    }
};
CSL.NameOutput.prototype.getName = function (name, slotLocaleset, fallback, stopOrig) {
    if (stopOrig && slotLocaleset === 'locale-orig') {
        return {name:false,usedOrig:stopOrig};
    }
    if (!name.family) {
        name.family = "";
    }
    if (!name.given) {
        name.given = "";
    }
    var static_ordering_freshcheck = false;
    var block_initialize = false;
    var transliterated = false;
    var static_ordering_val = this.getStaticOrder(name);
    var foundTag = true;
    if (slotLocaleset !== 'locale-orig') {
        foundTag = false;
        if (name.multi) {
            var langTags = this.state.opt[slotLocaleset]
            for (i = 0, ilen = langTags.length; i < ilen; i += 1) {
                langTag = langTags[i];
                if (name.multi._key[langTag]) {
                    foundTag = true;
                    name = name.multi._key[langTag];
                    transliterated = true;
                    if (!this.state.opt['locale-use-original-name-format'] && false) {
                        static_ordering_freshcheck = true;
                    } else {
                        if ((name.family.replace('"','','g') + name.given).match(CSL.ROMANESQUE_REGEXP)) {
                            block_initialize = true;
                        }
                    }
                    break;
                }
            }
        }
    }
    if (!fallback && !foundTag) {
        return {name:false,usedOrig:stopOrig};
    }
    if (!name.family) {
        name.family = "";
    }
    if (!name.given) {
        name.given = "";
    }
    name = {
        family:name.family,
        given:name.given,
        "non-dropping-particle":name["non-dropping-particle"],
        "dropping-particle":name["dropping-particle"],
        suffix:name.suffix,
        "static-ordering":static_ordering_val,
        "parse-names":name["parse-names"],
        "comma-suffix":name["comma-suffix"],
        "comma-dropping-particle":name["comma-dropping-particle"],
        transliterated:transliterated,
        block_initialize:block_initialize,
        literal:name.literal,
        isInstitution:name.isInstitution,
    };
    if (static_ordering_freshcheck &&
        !this.getStaticOrder(name, true)) {
        name["static-ordering"] = false;
    }
    if (!name.literal && (!name.given && name.family && name.isInstitution)) {
        name.literal = name.family;
    }
    if (name.literal) {
        delete name.family;
        delete name.given;
    }
    name = this._normalizeNameInput(name);
    var usedOrig;
    if (stopOrig) {
        usedOrig = stopOrig;
    } else {
        usedOrig = !foundTag;
    }
    return {name:name,usedOrig:usedOrig};
}
CSL.NameOutput.prototype.fixupInstitution = function (name, varname, listpos) {
    name = this._splitInstitution(name, varname, listpos);
    if (this.institution.strings["reverse-order"]) {
        name["long"].reverse();
    }
    var long_form = name["long"];
    var short_form = long_form.slice();
    if (this.state.sys.getAbbreviation) {
        var jurisdiction = this.Item.jurisdiction;
        for (var j = 0, jlen = long_form.length; j < jlen; j += 1) {
            jurisdiction = this.state.transform.loadAbbreviation(jurisdiction, "institution-part", long_form[j]);
            if (this.state.transform.abbrevs[jurisdiction]["institution-part"][long_form[j]]) {
                short_form[j] = this.state.transform.abbrevs[jurisdiction]["institution-part"][long_form[j]];
            }
        }
    }
    name["short"] = short_form;
    return name;
}
CSL.NameOutput.prototype.getStaticOrder = function (name, refresh) {
    var static_ordering_val = false;
    if (!refresh && name["static-ordering"]) {
        static_ordering_val = true;
    } else if (!(name.family.replace('"', '', 'g') + name.given).match(CSL.ROMANESQUE_REGEXP)) {
        static_ordering_val = true;
    } else if (name.multi && name.multi.main && name.multi.main.slice(0,2) == 'vn') {
        static_ordering_val = true;
    } else {
        if (this.state.opt['auto-vietnamese-names']
            && (CSL.VIETNAMESE_NAMES.exec(name.family + " " + name.given)
                && CSL.VIETNAMESE_SPECIALS.exec(name.family + name.given))) {
            static_ordering_val = true;
        }
    }
    return static_ordering_val;
}
CSL.NameOutput.prototype._splitInstitution = function (value, v, i) {
    var ret = {};
    var splitInstitution = value.literal.replace(/\s*\|\s*/g, "|");
    splitInstitution = splitInstitution.split("|");
    if (this.institution.strings.form === "short" && this.state.sys.getAbbreviation) {
        var jurisdiction = this.Item.jurisdiction;
        for (var j = splitInstitution.length; j > 0; j += -1) {
            var str = splitInstitution.slice(0, j).join("|");
            jurisdiction = this.state.transform.loadAbbreviation(jurisdiction, "institution-entire", str);
            if (this.state.transform.abbrevs[jurisdiction]["institution-entire"][str]) {
                var splitLst = this.state.transform.abbrevs[jurisdiction]["institution-entire"][str];
                splitLst = this.state.transform.quashCheck(splitLst);
                var splitSplitLst = splitLst.split(/>>[0-9]{4}>>/);
                var m = splitLst.match(/>>([0-9]{4})>>/);
                splitLst = splitSplitLst.pop();
                if (splitSplitLst.length > 0 && this.Item.issued && this.Item.issued.year) {
                    for (var k=m.length - 1; k > 0; k += -1) {
                        if (parseInt(this.Item.issued.year, 10) >= parseInt(m[k], 10)) {
                            break;
                        }
                        splitLst = splitSplitLst.pop();
                    }
                }
                splitLst = splitLst.replace(/\s*\|\s*/g, "|");
                splitLst = splitLst.split("|");
                splitInstitution = splitLst.concat(splitInstitution.slice(j));
            }
        }
    }
    splitInstitution.reverse();
    ret["long"] = this._trimInstitution(splitInstitution, v, i);
    return ret;
};
CSL.NameOutput.prototype._trimInstitution = function (subunits, v, i) {
    var use_first = false;
    var append_last = false;
    var stop_last = false;
    var s = subunits.slice();
    if (this.institution) {
        if ("undefined" !== typeof this.institution.strings["use-first"]) {
            use_first = this.institution.strings["use-first"];
        }
        if ("undefined" !== typeof this.institution.strings["stop-last"]) {
            s = s.slice(0, this.institution.strings["stop-last"]);
            subunits = subunits.slice(0, this.institution.strings["stop-last"]);
        }
        if ("undefined" !== typeof this.institution.strings["use-last"]) {
            append_last = this.institution.strings["use-last"];
        }
    }
    if (false === use_first) {
        if (this.persons[v].length === 0) {
            use_first = this.institution.strings["substitute-use-first"];
        }
        if (!use_first) {
            use_first = 0;
        }
    }
    if (false === append_last) {
        if (!use_first) {
            append_last = subunits.length;
        } else {
            append_last = 0;
        }
    }
    if (use_first > subunits.length - append_last) {
        use_first = subunits.length - append_last;
    }
    if (stop_last) {
        append_last = 0;
    }
    subunits = subunits.slice(0, use_first);
    s = s.slice(use_first);
    if (append_last) {
        if (append_last > s.length) {
            append_last = s.length;
        }
        if (append_last) {
            subunits = subunits.concat(s.slice((s.length - append_last)));
        }
    }
    return subunits;
};
CSL.NameOutput.prototype.setEtAlParameters = function () {
    var i, ilen, j, jlen;
    for (i = 0, ilen = this.variables.length; i < ilen; i += 1) {
        var v = this.variables[i];
        if (this.freeters[v].length) {
            this._setEtAlParameter("freeters", v);
        }
        if (this.institutions[v].length) {
            this._setEtAlParameter("institutions", v);
        }
        for (j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
            this._setEtAlParameter("persons", v, j);
        }
    }
};
CSL.NameOutput.prototype._setEtAlParameter = function (type, v, j) {
    var lst, count;
    if ("undefined" === typeof j) {
        lst = this[type][v];
        count = this[type + "_count"][v];
    } else {
        lst = this[type][v][j];
        count = this[type + "_count"][v][j];
    }
    if (lst.length < count && !this.state.tmp.sort_key_flag) {
        if (this.etal_use_last) {
            this.etal_spec.push(2);
        } else {
            this.etal_spec.push(1);
        }
    } else {
        this.etal_spec.push(0);
    }
};
CSL.evaluateLabel = function (node, state, Item, item) {
    var myterm;
    if ("locator" === node.strings.term) {
        if (item && item.label) {
            if (item.label === "sub verbo") {
                myterm = "sub-verbo";
            } else {
                myterm = item.label;
            }
        }
        if (!myterm) {
            myterm = "page";
        }
    } else {
        myterm = node.strings.term;
    }
    var plural = node.strings.plural;
    if (item && "number" === typeof item.force_pluralism) {
        plural = item.force_pluralism;
    } else if ("number" !== typeof plural) {
        if ("locator" === node.strings.term) {
            if (item && item.locator) {
                if (state.opt.development_extensions.locator_parsing_for_plurals) {
                    if (!state.tmp.shadow_numbers.locator) {
                        state.processNumber(false, item, "locator", Item.type);
                    }
                    plural = state.tmp.shadow_numbers.locator.plural;
                } else {
                    plural = CSL.evaluateStringPluralism(item.locator);
                }
            }
        } else if (["page", "page-first"].indexOf(node.variables[0]) > -1) {
            state.processNumber(false, Item, myterm, Item.type);
            plural = state.tmp.shadow_numbers[myterm].plural;
            myterm = state.tmp.shadow_numbers[myterm].label;
        } else {
            if (!state.tmp.shadow_numbers[myterm]) {
                state.processNumber(false, Item, myterm, Item.type);
            }
            plural = state.tmp.shadow_numbers[myterm].plural;
        }
        if (node.decorations && state.opt.development_extensions.csl_reverse_lookup_support) {
            node.decorations.reverse();
            node.decorations.push(["@showid","true", node.cslid]);
            node.decorations.reverse();
        }
    }
    return CSL.castLabel(state, node, myterm, plural, CSL.TOLERANT);
};
CSL.evaluateStringPluralism = function (str) {
    if (str) {
        var m = str.match(/(?:[0-9],\s*[0-9]|\s+and\s+|&|([0-9]+)\s*[\-\u2013]\s*([0-9]+))/)
        if (m && (!m[1] || parseInt(m[1]) < parseInt(m[2]))) {
            return 1
        }
    }
    return 0;
};
CSL.castLabel = function (state, node, term, plural, mode) {
    var label_form = node.strings.form;
    if (state.tmp.group_context.value()[5]) {
        label_form = state.tmp.group_context.value()[5];
    }
    var ret = state.getTerm(term, label_form, plural, false, mode);
    if (state.tmp.strip_periods) {
        ret = ret.replace(/\./g, "");
    } else {
        for (var i = 0, ilen = node.decorations.length; i < ilen; i += 1) {
            if ("@strip-periods" === node.decorations[i][0] && "true" === node.decorations[i][1]) {
                ret = ret.replace(/\./g, "");
                break;
            }
        }
    }
    return ret;
};
CSL.PublisherOutput = function (state, group_tok) {
    this.state = state;
    this.group_tok = group_tok;
    this.varlist = [];
};
CSL.PublisherOutput.prototype.render = function () {
    this.clearVars();
    this.composeAndBlob();
    this.composeElements();
    this.composePublishers();
    this.joinPublishers();
};
CSL.PublisherOutput.prototype.composeAndBlob = function () {
    this.and_blob = {};
    var and_term = false;
    if (this.group_tok.strings.and === "text") {
        and_term = this.state.getTerm("and");
    } else if (this.group_tok.strings.and === "symbol") {
        and_term = "&";
    }
    var tok = new CSL.Token();
    tok.strings.suffix = " ";
    tok.strings.prefix = " ";
    this.state.output.append(and_term, tok, true);
    var no_delim = this.state.output.pop();
    tok.strings.prefix = this.group_tok.strings["subgroup-delimiter"];
    this.state.output.append(and_term, tok, true);
    var with_delim = this.state.output.pop();
    this.and_blob.single = false;
    this.and_blob.multiple = false;
    if (and_term) {
        if (this.group_tok.strings["subgroup-delimiter-precedes-last"] === "always") {
            this.and_blob.single = with_delim;
        } else if (this.group_tok.strings["subgroup-delimiter-precedes-last"] === "never") {
            this.and_blob.single = no_delim;
            this.and_blob.multiple = no_delim;
        } else {
            this.and_blob.single = no_delim;
            this.and_blob.multiple = with_delim;
        }
    }
};
CSL.PublisherOutput.prototype.composeElements = function () {
    for (var i = 0, ilen = 2; i < ilen; i += 1) {
        var varname = ["publisher", "publisher-place"][i];
        for (var j = 0, jlen = this["publisher-list"].length; j < jlen; j += 1) {
            var str = this[varname + "-list"][j];
            var tok = this[varname + "-token"];
            this.state.output.append(str, tok, true);
            this[varname + "-list"][j] = this.state.output.pop();
        }
    }
};
CSL.PublisherOutput.prototype.composePublishers = function () {
    var blobs;
    for (var i = 0, ilen = this["publisher-list"].length; i < ilen; i += 1) {
        var ordered_list = [];
        blobs = [this[this.varlist[0] + "-list"][i], this[this.varlist[1] + "-list"][i]];
        this["publisher-list"][i] = this._join(blobs, this.group_tok.strings.delimiter);
    }
};
CSL.PublisherOutput.prototype.joinPublishers = function () {
    var blobs = this["publisher-list"];
    var delim = this.name_delimiter;
    var publishers = this._join(blobs, this.group_tok.strings["subgroup-delimiter"], this.and_blob.single, this.and_blob.multiple, this.group_tok);
    this.state.output.append(publishers, "literal");
};
CSL.PublisherOutput.prototype._join = CSL.NameOutput.prototype._join;
CSL.PublisherOutput.prototype._getToken = CSL.NameOutput.prototype._getToken;
CSL.PublisherOutput.prototype.clearVars = function () {
    this.state.tmp["publisher-list"] = false;
    this.state.tmp["publisher-place-list"] = false;
    this.state.tmp["publisher-group-token"] = false;
    this.state.tmp["publisher-token"] = false;
    this.state.tmp["publisher-place-token"] = false;
};
CSL.dateMacroAsSortKey = function (state, Item) {
    CSL.dateAsSortKey.call(this, state, Item, true);
};
CSL.dateAsSortKey = function (state, Item, isMacro) {
    var dp, elem, value, e, yr, prefix, i, ilen, num;
    var variable = this.variables[0];
    var macroFlag = "empty";
    if (isMacro) {
        macroFlag = "macro-with-date";
    }
    dp = Item[variable];
    if ("undefined" === typeof dp) {
        dp = {"date-parts": [[0]] };
        if (!dp.year) {
            state.tmp.empty_date = true;
        }
    }
    if ("undefined" === typeof this.dateparts) {
        this.dateparts = ["year", "month", "day"];
    }
    if (dp.raw) {
        dp = state.fun.dateparser.parse(dp.raw);
    } else if (dp["date-parts"]) {
        dp = state.dateParseArray(dp);
    }
    if ("undefined" === typeof dp) {
        dp = {};
    }
    for (i = 0, ilen = CSL.DATE_PARTS_INTERNAL.length; i < ilen; i += 1) {
        elem = CSL.DATE_PARTS_INTERNAL[i];
        value = 0;
        e = elem;
        if (e.slice(-4) === "_end") {
            e = e.slice(0, -4);
        }
        if (dp[elem] && this.dateparts.indexOf(e) > -1) {
            value = dp[elem];
        }
        if (elem.slice(0, 4) === "year") {
            yr = CSL.Util.Dates[e].numeric(state, value);
            prefix = "Y";
            if (yr[0] === "-") {
                prefix = "X";
                yr = yr.slice(1);
                yr = 9999 - parseInt(yr, 10);
            }
            state.output.append(CSL.Util.Dates[elem.slice(0, 4)].numeric(state, (prefix + yr)), macroFlag);
        } else {
            state.output.append(CSL.Util.Dates[e]["numeric-leading-zeros"](state, value), macroFlag);
        }
    }
    if (state.registry.registry[Item.id] && state.registry.registry[Item.id].disambig.year_suffix) {
        num = state.registry.registry[Item.id].disambig.year_suffix.toString();
        num = CSL.Util.padding(num);
    } else {
        num = CSL.Util.padding("0");
    }
    state.output.append("S"+num, macroFlag);
};
CSL.Engine.prototype.dateParseArray = function (date_obj) {
    var ret, field, dpos, ppos, dp, exts, llen, pos, len, pppos, lllen;
    ret = {};
    for (field in date_obj) {
        if (field === "date-parts") {
            dp = date_obj["date-parts"];
            if (dp.length > 1) {
                if (dp[0].length !== dp[1].length) {
                    CSL.error("CSL data error: element mismatch in date range input.");
                }
            }
            exts = ["", "_end"];
            for (var i = 0, ilen = dp.length; i < ilen; i += 1) {
                for (var j = 0, jlen = CSL.DATE_PARTS.length; j < jlen; j += 1) {
                    if ("undefined" === typeof dp[i][j]) {
                        ret[(CSL.DATE_PARTS[j] + exts[i])] = dp[i][j];
                    } else {
                        ret[(CSL.DATE_PARTS[j] + exts[i])] = parseInt(dp[i][j], 10);
                    }
                }
            }
        } else if (date_obj.hasOwnProperty(field)) {
            if (field === "literal" && "object" === typeof date_obj.literal && "string" === typeof date_obj.literal.part) {
                CSL.debug("Warning: fixing up weird literal date value");
                ret.literal = date_obj.literal.part;
            } else {
                ret[field] = date_obj[field];
            }
        }
    }
    return ret;
};
CSL.Node.name = {
    build: function (state, target) {
        var func, pos, len, attrname;
        if ([CSL.SINGLETON, CSL.START].indexOf(this.tokentype) > -1) {
            state.fixOpt(this, "name-delimiter", "name_delimiter");
            state.fixOpt(this, "name-form", "form");
            state.fixOpt(this, "and", "and");
            state.fixOpt(this, "delimiter-precedes-last", "delimiter-precedes-last");
            state.fixOpt(this, "delimiter-precedes-et-al", "delimiter-precedes-et-al");
            state.fixOpt(this, "initialize-with", "initialize-with");
            state.fixOpt(this, "initialize", "initialize");
            state.fixOpt(this, "name-as-sort-order", "name-as-sort-order");
            state.fixOpt(this, "sort-separator", "sort-separator");
            state.fixOpt(this, "and", "and");
            state.fixOpt(this, "et-al-min", "et-al-min");
            state.fixOpt(this, "et-al-use-first", "et-al-use-first");
            state.fixOpt(this, "et-al-use-last", "et-al-use-last");
            state.fixOpt(this, "et-al-subsequent-min", "et-al-subsequent-min");
            state.fixOpt(this, "et-al-subsequent-use-first", "et-al-subsequent-use-first");
            if (this.strings["et-al-subsequent-min"]
                && (this.strings["et-al-subsequent-min"] !== this.strings["et-al-min"])) {
                state.opt.update_mode = CSL.POSITION;
            }
            if (this.strings["et-al-subsequent-use-first"]
                && (this.strings["et-al-subsequent-use-first"] !== this.strings["et-al-use-first"])) {
                state.opt.update_mode = CSL.POSITION;
            }
            state.build.etal_term = "et-al";
            state.build.name_delimiter = this.strings.delimiter;
            state.build["delimiter-precedes-et-al"] = this.strings["delimiter-precedes-et-al"];
            if ("undefined" == typeof this.strings.name_delimiter) {
                this.strings.delimiter = ", ";
            } else {
                this.strings.delimiter = this.strings.name_delimiter;
            }
            if ("text" === this.strings.and) {
                this.and_term = state.getTerm("and", "long", 0);
            } else if ("symbol" === this.strings.and) {
                this.and_term = "&";
            }
            state.build.and_term = this.and_term;
            if (CSL.STARTSWITH_ROMANESQUE_REGEXP.test(this.and_term)) {
                this.and_prefix_single = " ";
                this.and_prefix_multiple = ", ";
                if ("string" === typeof this.strings.delimiter) {
                    this.and_prefix_multiple = this.strings.delimiter;
                }
                this.and_suffix = " ";
                state.build.name_delimiter = this.strings.delimiter;
            } else {
                this.and_prefix_single = "";
                this.and_prefix_multiple = "";
                this.and_suffix = "";
            }
            if (this.strings["delimiter-precedes-last"] === "always") {
                this.and_prefix_single = this.strings.delimiter;
            } else if (this.strings["delimiter-precedes-last"] === "never") {
                if (this.and_prefix_multiple) {
                    this.and_prefix_multiple = " ";
                }
            }
            if (this.strings["et-al-use-last"]) {
                this.ellipsis_term = "\u2026";
                this.ellipsis_prefix_single = " ";
                this.ellipsis_prefix_multiple =  this.strings.delimiter;
                this.ellipsis_suffix = " ";
            }
            func = function (state, Item) {
                this.and = {};
                if (this.strings.and) {
                    state.output.append(this.and_term, "empty", true);
                    this.and.single = state.output.pop();
                    this.and.single.strings.prefix = this.and_prefix_single;
                    this.and.single.strings.suffix = this.and_suffix;
                    state.output.append(this.and_term, "empty", true);
                    this.and.multiple = state.output.pop();
                    this.and.multiple.strings.prefix = this.and_prefix_multiple;
                    this.and.multiple.strings.suffix = this.and_suffix;
                } else if (this.strings.delimiter) {
                    this.and.single = new CSL.Blob(this.strings.delimiter);
                    this.and.single.strings.prefix = "";
                    this.and.single.strings.suffix = "";
                    this.and.multiple = new CSL.Blob(this.strings.delimiter);
                    this.and.multiple.strings.prefix = "";
                    this.and.multiple.strings.suffix = "";
                }
                this.ellipsis = {};
                if (this.strings["et-al-use-last"]) {
                    this.ellipsis.single = new CSL.Blob(this.ellipsis_term);
                    this.ellipsis.single.strings.prefix = this.ellipsis_prefix_single;
                    this.ellipsis.single.strings.suffix = this.ellipsis_suffix;
                    this.ellipsis.multiple = new CSL.Blob(this.ellipsis_term);
                    this.ellipsis.multiple.strings.prefix = this.ellipsis_prefix_multiple;
                    this.ellipsis.multiple.strings.suffix = this.ellipsis_suffix;
                }
                if ("undefined" === typeof state.tmp["et-al-min"]) {
                    state.tmp["et-al-min"] = this.strings["et-al-min"];
                }
                if ("undefined" === typeof state.tmp["et-al-use-first"]) {
                    state.tmp["et-al-use-first"] = this.strings["et-al-use-first"];
                }
                if ("undefined" === typeof state.tmp["et-al-use-last"]) {
                    state.tmp["et-al-use-last"] = this.strings["et-al-use-last"];
                }
                state.nameOutput.name = this;
            };
            state.build.name_flag = true;
            this.execs.push(func);
        }
        target.push(this);
    }
};
CSL.Node["name-part"] = {
    build: function (state, target) {
        state.build[this.strings.name] = this;
    }
};
CSL.Node.names = {
    build: function (state, target) {
        var func, len, pos, attrname;
        var debug = false;
        if (this.tokentype === CSL.START || this.tokentype === CSL.SINGLETON) {
            CSL.Util.substituteStart.call(this, state, target);
            state.build.substitute_level.push(1);
            state.fixOpt(this, "names-delimiter", "delimiter");
        }
        if (this.tokentype === CSL.SINGLETON) {
            func = function (state, Item, item) {
                state.nameOutput.reinit(this);
            };
            this.execs.push(func);
        }
        if (this.tokentype === CSL.START) {
            state.build.names_flag = true;
            state.build.names_level += 1;
            func = function (state, Item, item) {
                state.tmp.can_substitute.push(true);
                state.parallel.StartVariable("names");
                state.nameOutput.init(this);
            };
            this.execs.push(func);
        }
        if (this.tokentype === CSL.END) {
            for (var i = 0, ilen = 3; i < ilen; i += 1) {
                var key = ["family", "given", "et-al"][i];
                this[key] = state.build[key];
                if (state.build.names_level === 1) {
                    state.build[key] = undefined;
                }
            }
            state.build.names_level += -1;
            this.label = state.build.name_label;
            state.build.name_label = undefined;
            var mywith = "with";
            var with_default_prefix = "";
            var with_suffix = "";
            if (CSL.STARTSWITH_ROMANESQUE_REGEXP.test(mywith)) {
                with_default_prefix = " ";
                with_suffix = " ";
            }
            this["with"] = {};
            this["with"].single = new CSL.Blob(mywith);
            this["with"].single.strings.suffix = with_suffix;
            this["with"].multiple = new CSL.Blob(mywith);
            this["with"].multiple.strings.suffix = with_suffix;
            if (this.strings["delimiter-precedes-last"] === "always") {
                this["with"].single.strings.prefix = this.strings.delimiter;
                this["with"].multiple.strings.prefix = this.strings.delimiter;
            } else if (this.strings["delimiter-precedes-last"] === "contextual") {
                this["with"].single.strings.prefix = with_default_prefix;
                this["with"].multiple.strings.prefix = this.strings.delimiter;
            } else {
                this["with"].single.strings.prefix = with_default_prefix;
                this["with"].multiple.strings.prefix = with_default_prefix;
            }
            if (state.build.etal_node) {
                this.etal_style = state.build.etal_node;
            } else {
                this.etal_style = "empty";
            }
            this.etal_term = state.getTerm(state.build.etal_term, "long", 0);
            if (CSL.STARTSWITH_ROMANESQUE_REGEXP.test(this.etal_term)) {
                this.etal_prefix_single = " ";
                this.etal_prefix_multiple = state.build.name_delimiter;
                if (state.build["delimiter-precedes-et-al"] === "always") {
                    this.etal_prefix_single = state.build.name_delimiter;
                } else if (state.build["delimiter-precedes-et-al"] === "never") {
                    this.etal_prefix_multiple = " ";
                }
                this.etal_suffix = "";
            } else {
                this.etal_prefix_single = "";
                this.etal_prefix_multiple = "";
                this.etal_suffix = "";
            }
            func = function (state, Item, item) {
                for (var i = 0, ilen = 3; i < ilen; i += 1) {
                    var key = ["family", "given"][i];
                    state.nameOutput[key] = this[key];
                }
                state.nameOutput["with"] = this["with"];
                state.nameOutput.label = this.label;
                state.nameOutput.etal_style = this.etal_style;
                state.nameOutput.etal_term = this.etal_term;
                state.nameOutput.etal_prefix_single = this.etal_prefix_single;
                state.nameOutput.etal_prefix_multiple = this.etal_prefix_multiple;
                state.nameOutput.etal_suffix = this.etal_suffix;
                state.nameOutput.outputNames();
                state.tmp["et-al-use-first"] = undefined;
                state.tmp["et-al-min"] = undefined;
                state.tmp["et-al-use-last"] = undefined;
            };
            this.execs.push(func);
            func = function (state, Item) {
                if (!state.tmp.can_substitute.pop()) {
                    state.tmp.can_substitute.replace(false, CSL.LITERAL);
                }
                state.parallel.CloseVariable("names");
                state.tmp.can_block_substitute = false;
            };
            this.execs.push(func);
            state.build.name_flag = false;
        }
        target.push(this);
        if (this.tokentype === CSL.END || this.tokentype === CSL.SINGLETON) {
            state.build.substitute_level.pop();
            CSL.Util.substituteEnd.call(this, state, target);
        }
    }
};
CSL.Node.number = {
    build: function (state, target) {
        var func;
        CSL.Util.substituteStart.call(this, state, target);
        if (this.strings.form === "roman") {
            this.formatter = state.fun.romanizer;
        } else if (this.strings.form === "ordinal") {
            this.formatter = state.fun.ordinalizer;
        } else if (this.strings.form === "long-ordinal") {
            this.formatter = state.fun.long_ordinalizer;
        }
        if ("undefined" === typeof this.successor_prefix) {
            this.successor_prefix = state[state.build.area].opt.layout_delimiter;
        }
        if ("undefined" === typeof this.splice_prefix) {
            this.splice_prefix = state[state.build.area].opt.layout_delimiter;
        }
        func = function (state, Item, item) {
            if (this.variables.length === 0) {
                return;
            }
            var varname, num, number, m, j, jlen;
            varname = this.variables[0];
            state.parallel.StartVariable(this.variables[0]);
            if (this.variables[0] === "locator") {
                state.parallel.AppendToVariable(Item["section"]);
            } else {
                state.parallel.AppendToVariable(Item[this.variables[0]]);
            }
            var rex = new RegExp("(?:&|, | and |" + state.getTerm("page-range-delimiter") + ")");
            if (varname === 'collection-number' && Item.type === 'legal_case') {
                state.tmp.renders_collection_number = true;
            }
            var value = Item[this.variables[0]];
            var form = "long";
            if (this.strings.label_form_override) {
                form = this.strings.label_form_override;
            }
            if (this.text_case_normal) {
                if (value) {
                    value = value.replace("\\", "");
                    state.output.append(value, this);
                }
            } else if (varname === "locator"
                       && item.locator) {
                item.locator = item.locator.replace(/([^\\])\s*-\s*/, "$1" + state.getTerm("page-range-delimiter"));
                var m = item.locator.match(CSL.STATUTE_SUBDIV_GROUPED_REGEX);
                if (m) {
                    var lst = item.locator.split(CSL.STATUTE_SUBDIV_PLAIN_REGEX);
                    for (var i = 0, ilen = lst.length; i < ilen; i += 1) {
                        lst[i] = state.fun.page_mangler(lst[i]);
                    }
                    var newlst = [lst[0]];
                    if (!this.strings.label_form_override && state.tmp.group_context.value()[5]) {
                        form = state.tmp.group_context.value()[5];
                    }
                    for (var i = 1, ilen = lst.length; i < ilen; i += 1) {
                        var subplural = 0;
                        if (lst[i].match(rex)) {
                            subplural = 1;
                        }
                        var term = CSL.STATUTE_SUBDIV_STRINGS[m[i - 1].replace(/^\s*/,"")];
                        var myform = form;
                        if (item.section_label_count > i && item.section_form_override) {
                            myform = item.section_form_override;
                        }
                        newlst.push(state.getTerm(term, myform, subplural));
                        newlst.push(lst[i].replace(/^\s*/,""));
                    }
                    value = newlst.join(" ");
                    value = value.replace(/\\/, "", "g");
                    state.output.append(value, this);
                } else {
                    value = state.fun.page_mangler(item.locator);
                    value = value.replace(/\\/, "", "g");
                    state.output.append(value, this);
                }
            } else {
                var node = this;
                if (!state.tmp.shadow_numbers[varname] 
                    || (state.tmp.shadow_numbers[varname].values.length 
                        && state.tmp.shadow_numbers[varname].values[0][2] === false)) {
                    if (varname === "locator") {
                        state.processNumber(node, item, varname, Item.type);
                    } else {
                        state.processNumber(node, Item, varname, Item.type);
                    }
                }
                var values = state.tmp.shadow_numbers[varname].values;
                var blob;
                var newstr = ""
                var rangeType = "page";
                if (["bill","gazette","legislation","legal_case","treaty"].indexOf(Item.type) > -1
                    && varname === "collection-number") {
                    rangeType = "year";
                }
                if (((varname === "number" 
                      && ["bill","gazette","legislation","treaty"].indexOf(Item.type) > -1)
                     || state.opt[rangeType + "-range-format"]) 
                    && !this.strings.prefix && !this.strings.suffix
                    && !this.strings.form) {
                    for (var i = 0, ilen = values.length; i < ilen; i += 1) {
                        newstr += values[i][1];
                    }
                }
                if (newstr && !newstr.match(/^[-.\u20130-9]+$/)) {
                    if (varname === "number" 
                        && ["bill","gazette","legislation","treaty"].indexOf(Item.type) > -1) {
                        var firstword = newstr.split(/\s/)[0];
                        if (firstword) {
                            var newlst = [];
                            var m = newstr.match(CSL.STATUTE_SUBDIV_GROUPED_REGEX);
                            if (m) {
                                var lst = newstr.split(CSL.STATUTE_SUBDIV_PLAIN_REGEX);
                                for (var i = 1, ilen = lst.length; i < ilen; i += 1) {
                                    newlst.push(state.getTerm(CSL.STATUTE_SUBDIV_STRINGS[m[i - 1].replace(/^\s+/, "")], this.strings.label_form_override));
                                    newlst.push(lst[i].replace(/^\s+/, ""));
                                }
                                newstr = newlst.join(" ");
                            }
                        }
                    }
                    state.output.append(newstr, this);
                } else {
                    if (values.length) {
                        state.output.openLevel("empty");
                        for (var i = 0, ilen = values.length; i < ilen; i += 1) {
                            var blob = new CSL[values[i][0]](values[i][1], values[i][2], Item.id);
                            if (i > 0) {
                                blob.strings.prefix = blob.strings.prefix.replace(/^\s*/, "");
                            }
                            if (i < values.length - 1) {
                                blob.strings.suffix = blob.strings.suffix.replace(/\s*$/, "");
                            }
                            state.output.append(blob, "literal", false, false, true);
                        }
                        state.output.closeLevel("empty");
                    }
                }
            }
            if (varname === "locator") {
                state.tmp.done_vars.push("locator");
            }
            state.parallel.CloseVariable("number");
        };
        this.execs.push(func);
        target.push(this);
        CSL.Util.substituteEnd.call(this, state, target);
    }
};
CSL.Node.sort = {
    build: function (state, target) {
        if (this.tokentype === CSL.START) {
            if (state.build.area === "citation") {
                state.parallel.use_parallels = false;
                state.opt.sort_citations = true;
            }
            state.build.area = state.build.root + "_sort";
            state.build.extension = "_sort";
            var func = function (state, Item) {
            }
            this.execs.push(func);
        }
        if (this.tokentype === CSL.END) {
            state.build.area = state.build.root;
            state.build.extension = "";
        }
        target.push(this);
    }
};
CSL.Node.substitute = {
    build: function (state, target) {
        var func;
        if (this.tokentype === CSL.START) {
            func = function (state, Item) {
                state.tmp.can_block_substitute = true;
                if (state.tmp.value.length) {
                    state.tmp.can_substitute.replace(false, CSL.LITERAL);
                }
            };
            this.execs.push(func);
        }
        target.push(this);
    }
};
CSL.Node.text = {
    build: function (state, target) {
        var variable, func, form, plural, id, num, number, formatter, firstoutput, specialdelimiter, label, myname, names, name, year, suffix, term, dp, len, pos, n, m, value, flag;
        CSL.Util.substituteStart.call(this, state, target);
        if (this.postponed_macro) {
            CSL.expandMacro.call(state, this);
        } else {
            if (!this.variables_real) {
                this.variables_real = [];
            }
            if (!this.variables) {
                this.variables = [];
            }
            form = "long";
            plural = 0;
            if (this.strings.form) {
                form = this.strings.form;
            }
            if (this.strings.plural) {
                plural = this.strings.plural;
            }
            if ("citation-number" === this.variables_real[0] || "year-suffix" === this.variables_real[0] || "citation-label" === this.variables_real[0]) {
                if (this.variables_real[0] === "citation-number") {
                    if (state.build.root === "citation") {
                        state.opt.update_mode = CSL.NUMERIC;
                    }
                    if (state.build.root === "bibliography") {
                        state.opt.bib_mode = CSL.NUMERIC;
                    }
                    if (state.build.area === "bibliography_sort") {
                        state.opt.citation_number_sort_used = true;
                    }
                    if ("citation-number" === state[state.tmp.area].opt.collapse) {
                        this.range_prefix = state.getTerm("citation-range-delimiter");
                    }
                    this.successor_prefix = state[state.build.area].opt.layout_delimiter;
                    this.splice_prefix = state[state.build.area].opt.layout_delimiter;
                    func = function (state, Item, item) {
                        id = "" + Item.id;
                        if (!state.tmp.just_looking) {
                            if (item && item["author-only"]) {
                                state.tmp.element_trace.replace("do-not-suppress-me");
                                var reference_term = state.getTerm("reference", "long", "singular");
                                if ("undefined" === typeof reference_term) {
                                    reference_term = "reference";
                                }
                                term = CSL.Output.Formatters["capitalize-first"](state, reference_term);
                                state.output.append(term + " ");
                                state.tmp.last_element_trace = true;
                            }
                            if (item && item["suppress-author"]) {
                                if (state.tmp.last_element_trace) {
                                    state.tmp.element_trace.replace("suppress-me");
                                }
                                state.tmp.last_element_trace = false;
                            }
                            num = state.registry.registry[id].seq;
                            if (state.opt.citation_number_slug) {
                                state.output.append(state.opt.citation_number_slug, this);
                            } else {
                                number = new CSL.NumericBlob(num, this, Item.id);
                                state.output.append(number, "literal");
                            }
                        }
                    };
                    this.execs.push(func);
                } else if (this.variables_real[0] === "year-suffix") {
                    state.opt.has_year_suffix = true;
                    if (state[state.tmp.area].opt.collapse === "year-suffix-ranged") {
                        this.range_prefix = state.getTerm("citation-range-delimiter");
                    }
                    this.successor_prefix = state[state.build.area].opt.layout_delimiter;
                    if (state[state.tmp.area].opt["year-suffix-delimiter"]) {
                        this.successor_prefix = state[state.build.area].opt["year-suffix-delimiter"];
                    }
                    func = function (state, Item) {
                        if (state.registry.registry[Item.id] && state.registry.registry[Item.id].disambig.year_suffix !== false && !state.tmp.just_looking) {
                            num = parseInt(state.registry.registry[Item.id].disambig.year_suffix, 10);
                            number = new CSL.NumericBlob(num, this, Item.id);
                            formatter = new CSL.Util.Suffixator(CSL.SUFFIX_CHARS);
                            number.setFormatter(formatter);
                            state.output.append(number, "literal");
                            firstoutput = false;
                            len = state.tmp.group_context.mystack.length;
                            for (pos = 0; pos < len; pos += 1) {
                                flag = state.tmp.group_context.mystack[pos];
                                if (!flag[2] && (flag[1] || (!flag[1] && !flag[0]))) {
                                    firstoutput = true;
                                    break;
                                }
                            }
                            specialdelimiter = state[state.tmp.area].opt["year-suffix-delimiter"];
                            if (firstoutput && specialdelimiter && !state.tmp.sort_key_flag) {
                                state.tmp.splice_delimiter = state[state.tmp.area].opt["year-suffix-delimiter"];
                            }
                        }
                    };
                    this.execs.push(func);
                } else if (this.variables_real[0] === "citation-label") {
                    state.opt.has_year_suffix = true;
                    func = function (state, Item) {
                        label = Item["citation-label"];
                        if (!label) {
                            label = state.getCitationLabel(Item);
                        }
                        suffix = "";
                        if (state.registry.registry[Item.id] && state.registry.registry[Item.id].disambig.year_suffix !== false) {
                            num = parseInt(state.registry.registry[Item.id].disambig.year_suffix, 10);
                            suffix = state.fun.suffixator.format(num);
                        }
                        label += suffix;
                        state.output.append(label, this);
                    };
                    this.execs.push(func);
                }
            } else {
                if (this.strings.term) {
                    func = function (state, Item, item) {
                        var gender = state.opt.gender[Item.type];
                        var term = this.strings.term;
                        term = state.getTerm(term, form, plural, gender);
                        var myterm;
                        if (term !== "") {
                            flag = state.tmp.group_context.value();
                            flag[0] = true;
                            state.tmp.group_context.replace(flag);
                        }
                        if (!state.tmp.term_predecessor) {
                            myterm = CSL.Output.Formatters["capitalize-first"](state, term);
                        } else {
                            myterm = term;
                        }
                        if (state.tmp.strip_periods) {
                            myterm = myterm.replace(/\./g, "");
                        } else {
                            for (var i = 0, ilen = this.decorations.length; i < ilen; i += 1) {
                                if ("@strip-periods" === this.decorations[i][0] && "true" === this.decorations[i][1]) {
                                    myterm = myterm.replace(/\./g, "");
                                    break;
                                }
                            }
                        }
                        state.output.append(myterm, this);
                    };
                    this.execs.push(func);
                    state.build.term = false;
                    state.build.form = false;
                    state.build.plural = false;
                } else if (this.variables_real.length) {
                    func = function (state, Item, item) {
                        var parallel_variable = this.variables[0];
                        if (parallel_variable === "title" && form === "short") {
                            parallel_variable = "shortTitle";
                        }
                        state.parallel.StartVariable(parallel_variable);
                        state.parallel.AppendToVariable(Item[parallel_variable]);
                    };
                    this.execs.push(func);
                    if (CSL.MULTI_FIELDS.indexOf(this.variables_real[0]) > -1) {
                        var abbrevfam = this.variables[0];
                        var abbrfall = false;
                        var altvar = false;
                        var transfall = false;
                        if (form === "short") {
                            if (this.variables_real[0] === "container-title") {
                                altvar = "journalAbbreviation";
                            } else if (this.variables_real[0] === "title") {
                                altvar = "shortTitle";
                            }
                        } else {
                            abbrevfam = false;
                        }
                        if (state.build.extension) {
                            transfall = true;
                        } else {
                            transfall = true;
                            abbrfall = true;
						}
                        func = state.transform.getOutputFunction(this.variables, abbrevfam, abbrfall, altvar, transfall);
                    } else {
                        if (CSL.CITE_FIELDS.indexOf(this.variables_real[0]) > -1) {
                            func = function (state, Item, item) {
                                if (item && item[this.variables[0]]) {
                                    var value = "" + item[this.variables[0]];
                                    value = value.replace(/([^\\])--*/g,"$1"+state.getTerm("page-range-delimiter"));
                                    value = value.replace(/\\-/g,"-");
                                    state.output.append(value, this, false, false, true);
                                    if (this.variables[0] === "locator-revision") { 
                                        state.tmp.done_vars.push("locator-revision");
                                    }
                                }
                            };
                        } else if (this.variables_real[0] === "page-first") {
                            func = function (state, Item) {
                                var idx, value;
                                value = state.getVariable(Item, "page-first", form);
                                if (value) {
                                    value = value.replace("\\", "");
                                    state.output.append(value, this, false, false, true);
                                }
                            };
                        } else  if (this.variables_real[0] === "page") {
                            func = function (state, Item) {
                                var value = state.getVariable(Item, "page", form);
                                if (value) {
                                    value = ""+value;
                                    value = value.replace(/([^\\])--*/g,"$1"+state.getTerm("page-range-delimiter"));
                                    value = value.replace(/\\-/g,"-");
                                    value = state.fun.page_mangler(value);
                                    state.output.append(value, this, false, false, true);
                                }
                            };
                        } else if (this.variables_real[0] === "volume") {
                            func = function (state, Item) {
                                if (this.variables[0]) {
                                    var value = state.getVariable(Item, this.variables[0], form);
                                    if (value) {
                                        state.output.append(value, this);
                                    }
                                }
                            };
                        } else if (this.variables_real[0] === "hereinafter") {
                            func = function (state, Item) {
                                var hereinafter_info = state.transform.getHereinafter(Item);
                                if (state.transform.abbrevs[hereinafter_info[0]]) {
                                    var value = state.transform.abbrevs[hereinafter_info[0]].hereinafter[hereinafter_info[1]];
                                    if (value) {
                                        state.tmp.group_context.value()[2] = true;
                                        state.output.append(value, this);
                                    }
                                }
                            }
                        } else if (["URL", "DOI"].indexOf(this.variables_real[0]) > -1) {
                            func = function (state, Item) {
                                var value;
                                if (this.variables[0]) {
                                    value = state.getVariable(Item, this.variables[0], form);
                                    if (value) {
                                        if (state.opt.development_extensions.wrap_url_and_doi) {
                                            if (!this.decorations.length || this.decorations[0][0] !== "@" + this.variables[0]) {
                                                this.decorations = [["@" + this.variables[0], "true"]].concat(this.decorations);
                                            }
                                        }
                                        state.output.append(value, this, false, false, true);
                                    }
                                }
                            };
                        } else if (this.variables_real[0] === "section") {
                            func = function (state, Item) {
                                var value;
                                value = state.getVariable(Item, this.variables[0], form);
                                if (value) {
                                    state.output.append(value, this);
                                }
                            };
                        } else {
                            func = function (state, Item) {
                                var value;
                                if (this.variables[0]) {
                                    value = state.getVariable(Item, this.variables[0], form);
                                    if (value) {
                                        value = "" + value;
                                        value = value.replace("\\", "", "g");
                                        state.output.append(value, this);
                                    }
                                }
                            };
                        }
                    }
                    this.execs.push(func);
                    func = function (state, Item) {
                        state.parallel.CloseVariable("text");
                    };
                    this.execs.push(func);
                } else if (this.strings.value) {
                    func = function (state, Item) {
                        var flag;
                        flag = state.tmp.group_context.value();
                        flag[0] = true;
                        state.tmp.group_context.replace(flag);
                        state.output.append(this.strings.value, this);
                    };
                    this.execs.push(func);
                }
            }
            target.push(this);
        }
        CSL.Util.substituteEnd.call(this, state, target);
    }
};
CSL.Attributes = {};
CSL.Attributes["@cslid"] = function (state, arg) {
    this.cslid = parseInt(arg, 10);
}
CSL.Attributes["@is-parallel"] = function (state, arg) {
    var values = arg.split(" ");
    for (var i = 0, ilen = values.length; i < ilen; i += 1) {
        if (values[i] === "true") {
            values[i] = true;
        } else if (values[i] === "false") {
            values[i] = false;
        }
    }
    this.strings.set_parallel_condition = values;
}
CSL.Attributes["@is-plural"] = function (state, arg) {
    var func = function (state, Item, item) {
        var nameList = Item[arg];
        var ret = false;
        if (nameList && nameList.length) {
            var persons = 0;
            var institutions = 0;
            var last_is_person = false;
            for (var i = 0, ilen = nameList.length; i < ilen; i += 1) {
                if (nameList[i].isInstitution && (nameList[i].literal || (nameList[i].family && !nameList[i].given))) {
                    institutions += 1;
                    last_is_person = false;
                } else {
                    persons += 1;
                    last_is_person = true;
                }
            }
            if (persons > 1) {
                ret = true;
            } else if (institutions > 1) {
                ret = true;
            } else if (institutions && last_is_person) {
                ret = true;
            }
        }
        return ret;
    }
    this.tests.push(func);
}
CSL.Attributes["@subjurisdictions"] = function (state, arg) {
    var trysubjurisdictions = parseInt(arg, 10);
    var func = function (state, Item, item) {
        var subjurisdictions = 0;
        if (Item.jurisdiction) {
            var subjurisdictions = Item.jurisdiction.split(";").length;
        }
        if (subjurisdictions) {
            subjurisdictions += -1;
        }
        var ret = false;
        if (subjurisdictions >= trysubjurisdictions) {
            ret = true;
        }
        return [ret];
    };
    this.tests.push(func);
}
CSL.Attributes["@label-form"] = function (state, arg) {
    this.strings.label_form_override = arg;
}
CSL.Attributes["@has-year-only"] = function (state, arg) {
    var trydates = arg.split(/\s+/);
    var func = function (state, Item, item) {
        var ret = [];
        for (var i = 0, ilen = trydates.length; i < ilen; i += 1) {
            var trydate = Item[trydates[i]];
            if (!trydate || trydate.month || trydate.season) {
                ret.push(false)
            } else {
                ret.push(true)
            }
        }
        return ret;
    };
    this.tests.push(func);
}
CSL.Attributes["@has-month-or-season-only"] = function (state, arg) {
    var trydates = arg.split(/\s+/);
    var func = function (state, Item, item) {
        var ret = [];
        for (var i = 0, ilen = trydates.length; i < ilen; i += 1) {
            var trydate = Item[trydates[i]];
            if (!trydate || (!trydate.month && !trydate.season) || trydate.day) {
                ret.push(false)
            } else {
                ret.push(true)
            }
        }
        return ret;
    };
    this.tests.push(func);
}
CSL.Attributes["@has-day-only"] = function (state, arg) {
    var trydates = arg.split(/\s+/);
    var func = function (state, Item, item) {
        var ret = [];
        for (var i = 0, ilen = trydates.length; i < ilen; i += 1) {
            var trydate = Item[trydates[i]];
            if (!trydate || !trydate.day) {
                ret.push(false)
            } else {
                ret.push(true)
            }
        }
        return ret;
    };
    this.tests.push(func);
}
CSL.Attributes["@part-separator"] = function (state, arg) {
    this.strings["part-separator"] = arg;
}
CSL.Attributes["@context"] = function (state, arg) {
    var func = function (state, Item) {
		var area = state.tmp.area.slice(0, arg.length);
		var result = false;
		if (area === arg) {
			result = true;
		}
		return result;
    };
    this.tests.push(func);
};
CSL.Attributes["@trigger-fields"] = function (state, arg) {
    var mylst = arg.split(/\s+/);
    this.generate_trigger_fields = mylst;
};
CSL.Attributes["@type-map"] = function (state, arg) {
    var mymap = arg.split(/\s+/);
    this.generate_type_map = {};
    this.generate_type_map.from = mymap[0];
    this.generate_type_map.to = mymap[1];
};
CSL.Attributes["@leading-noise-words"] = function (state, arg) {
    this["leading-noise-words"] = arg;
};
CSL.Attributes["@class"] = function (state, arg) {
    state.opt["class"] = arg;
};
CSL.Attributes["@version"] = function (state, arg) {
    state.opt.version = arg;
};
CSL.Attributes["@value"] = function (state, arg) {
    this.strings.value = arg;
};
CSL.Attributes["@name"] = function (state, arg) {
    this.strings.name = arg;
};
CSL.Attributes["@form"] = function (state, arg) {
    this.strings.form = arg;
};
CSL.Attributes["@date-parts"] = function (state, arg) {
    this.strings["date-parts"] = arg;
};
CSL.Attributes["@range-delimiter"] = function (state, arg) {
    this.strings["range-delimiter"] = arg;
};
CSL.Attributes["@macro"] = function (state, arg) {
    this.postponed_macro = arg;
};
CSL.Attributes["@term"] = function (state, arg) {
    if (arg === "sub verbo") {
        this.strings.term = "sub-verbo";
    } else {
        this.strings.term = arg;
    }
};
CSL.Attributes["@xmlns"] = function (state, arg) {};
CSL.Attributes["@lang"] = function (state, arg) {
    if (arg) {
        state.build.lang = arg;
    }
};
CSL.Attributes["@type"] = function (state, arg) {
    var types, ret, func, len, pos;
    func = function (state, Item) {
        types = arg.split(/\s+/);
        ret = [];
        len = types.length;
        for (pos = 0; pos < len; pos += 1) {
            ret.push(Item.type === types[pos]);
        }
        return ret;
    };
    this.tests.push(func);
};
CSL.Attributes["@variable"] = function (state, arg) {
    var variables, pos, len, func, output, variable, varlen, needlen, ret, myitem, key, flag;
    this.variables = arg.split(/\s+/);
    this.variables_real = arg.split(/\s+/);
    if ("label" === this.name && this.variables[0]) {
        this.strings.term = this.variables[0];
    } else if (["names", "date", "text", "number"].indexOf(this.name) > -1) {
        func = function (state, Item, item) {
            variables = this.variables_real.slice();
            for (var i = this.variables.length - 1; i > -1; i += -1) {
                this.variables.pop();
            }
            len = variables.length;
            for (pos = 0; pos < len; pos += 1) {
                if (state.tmp.done_vars.indexOf(variables[pos]) === -1 && !(item && Item.type === "legal_case" && item["suppress-author"] && variables[pos] === "title")) {
                    this.variables.push(variables[pos]);
                }
                if ("hereinafter" === variables[pos] && state.sys.getAbbreviation) {
                    var hereinafter_info = state.transform.getHereinafter(Item);
                    state.transform.loadAbbreviation(hereinafter_info[0], "hereinafter", hereinafter_info[1]);
                }
                if (state.tmp.can_block_substitute) {
                    state.tmp.done_vars.push(variables[pos]);
                }
            }
        };
        this.execs.push(func);
        func = function (state, Item, item) {
            var mydate;
            output = false;
            len = this.variables.length;
            for (pos = 0; pos < len; pos += 1) {
                variable = this.variables[pos];
                if (variable === "authority"
                    && "string" === typeof Item[variable]
                    && "names" === this.name) {
                    Item[variable] = [{family:Item[variable],isInstitution:true}]
                }
                if (this.strings.form === "short" && !Item[variable]) {
                    if (variable === "title") {
                        variable = "shortTitle";
                    } else if (variable === "container-title") {
                        variable = "journalAbbreviation";
                    }
                }
                if (variable === "year-suffix") {
                    output = true;
                    break;
                } else if (CSL.DATE_VARIABLES.indexOf(variable) > -1) {
                    if (state.opt.development_extensions.locator_date_and_revision && "locator-date" === variable) {
                        output = true;
                        break;
                    }
                    if (Item[variable]) {
                        for (var key in Item[variable]) {
                            if (this.dateparts.indexOf(key) === -1 && "literal" !== key) {
                                continue;
                            }
                            if (Item[variable][key]) {
                                output = true;
                                break;
                            }
                        }
                        if (output) {
                            break;
                        }
                    }
                } else if ("locator" === variable) {
                    if (item && item.locator) {
                        output = true;
                    }
                    break;
                } else if ("locator-revision" === variable) {
                    if (item && item["locator-revision"]) {
                        output = true;
                    }
                    break;
                } else if (["citation-number","citation-label"].indexOf(variable) > -1) {
                    output = true;
                    break;
                } else if ("first-reference-note-number" === variable) {
                    if (item && item["first-reference-note-number"]) {
                        output = true;
                    }
                    break;
                } else if ("object" === typeof Item[variable]) {
                    if (Item[variable].length) {
                    }
                    break;
                } else if ("string" === typeof Item[variable] && Item[variable]) {
                    output = true;
                    break;
                } else if ("number" === typeof Item[variable]) {
                    output = true;
                    break;
                }
                if (output) {
                    break;
                }
            }
            flag = state.tmp.group_context.value();
            if (output) {
                if (variable !== "citation-number" || state.tmp.area !== "bibliography") {
                    state.tmp.cite_renders_content = true;
                }
                flag[2] = true;
                state.tmp.group_context.replace(flag);
                state.tmp.can_substitute.replace(false,  CSL.LITERAL);
            } else {
                flag[1] = true;
            }
        };
        this.execs.push(func);
    } else if (["if",  "else-if"].indexOf(this.name) > -1) {
        func = function (state, Item, item) {
            var key, x;
            ret = [];
            len = this.variables.length;
            for (pos = 0; pos < len; pos += 1) {
                variable = this.variables[pos];
                x = false;
                myitem = Item;
                if (item && ["locator", "locator-revision", "first-reference-note-number", "locator-date"].indexOf(variable) > -1) {
                    myitem = item;
                }
                if (variable === "hereinafter" && state.sys.getAbbreviation) {
                    var hereinafter_info = state.transform.getHereinafter(myitem);
                    state.transform.loadAbbreviation(hereinafter_info[0], "hereinafter", hereinafter_info[1]);
                    if (state.transform.abbrevs[hereinafter_info[0]].hereinafter[hereinafter_info[1]]) {
                        x = true
                    }
                } else if (myitem[variable]) {
                    if ("number" === typeof myitem[variable] || "string" === typeof myitem[variable]) {
                        x = true;
                    } else if ("object" === typeof myitem[variable]) {
                        for (key in myitem[variable]) {
                            if (myitem[variable][key]) {
                                x = true;
                                break;
                            } else {
                                x = false;
                            }
                        }
                    }
                }
                ret.push(x);
            }
            return ret;
        };
        this.tests.push(func);
    }
};
CSL.Attributes["@lingo"] = function (state, arg) {
};
CSL.Attributes["@macro-has-date"] = function (state, arg) {
    this["macro-has-date"] = true;
};
CSL.Attributes["@locale"] = function (state, arg) {
    var func, ret, len, pos, variable, myitem, langspec, lang, lst, i, ilen, fallback;
    if (this.name === "layout") {
        this.locale_raw = arg;
    } else {
        lst = arg.split(/\s+/);
        this.locale_bases = [];
        for (i = 0, ilen = lst.length; i < ilen; i += 1) {
            lang = CSL.localeParse(lst[i]);
            langspec = CSL.localeResolve(lang);
            if (lst[i].length === 2) {
                this.locale_bases.push(langspec.base);
            }
            state.localeConfigure(langspec);
            lst[i] = langspec;
        }
        this.locale_default = state.opt["default-locale"][0];
        this.locale = lst[0].best;
        this.locale_list = lst.slice();
        func = function (state, Item, item) {
            var key, res;
            ret = [];
            if (Item.language) {
                lang = CSL.localeParse(Item.language);
                langspec = CSL.localeResolve(lang);
                res = false;
                for (i = 0, ilen = this.locale_list.length; i < ilen; i += 1) {
                    if (langspec.best === this.locale_list[i].best) {
                        state.opt.lang = this.locale;
                        state.tmp.last_cite_locale = this.locale;
                        state.output.openLevel("empty");
                        state.output.current.value().new_locale = this.locale;
                        res = true;
                        break;
                    }
                }
                if (!res && this.locale_bases.indexOf(langspec.base) > -1) {
                    state.opt.lang = this.locale;
                    state.tmp.last_cite_locale = this.locale;
                    state.output.openLevel("empty");
                    state.output.current.value().new_locale = this.locale;
                    res = true;
                }
            }
            ret.push(res);
            return ret;
        };
        this.tests.push(func);
    }
};
CSL.Attributes["@suffix"] = function (state, arg) {
    this.strings.suffix = arg;
};
CSL.Attributes["@prefix"] = function (state, arg) {
    this.strings.prefix = arg;
};
CSL.Attributes["@delimiter"] = function (state, arg) {
    if ("name" == this.name) {
        this.strings.name_delimiter = arg;
    } else {
        this.strings.delimiter = arg;
    }
};
CSL.Attributes["@match"] = function (state, arg) {
    var evaluator;
    if (this.tokentype === CSL.START || CSL.SINGLETON) {
        if ("none" === arg) {
            evaluator = state.fun.match.none;
        } else if ("any" === arg) {
            evaluator = state.fun.match.any;
        } else if ("all" === arg) {
            evaluator = state.fun.match.all;
        } else {
            throw "Unknown match condition \"" + arg + "\" in @match";
        }
        this.evaluator = evaluator;
    }
};
CSL.Attributes["@jurisdiction"] = function (state, arg) {
    var lex = arg.split(/\s+/);
    var func = function (state, Item) {
        var mylex = false;
        var ret = false;
        if (Item.jurisdiction) {
            mylex = Item.jurisdiction;
        } else if (Item.language) {
            var m = Item.language.match(/^.*-x-lex-([.;a-zA-Z]+).*$/);
            if (m) {
                mylex = m[1];
            }
        }
        if (mylex) {
            var mylexlst = mylex.split(";");
            outerLoop: for (var i = 0, ilen = lex.length; i < ilen; i += 1) {
                if (!lex[i]) {
                    continue;
                }
                var lexlst = lex[i].split(";");
                innerLoop: for (var j = 0, jlen = lexlst.length; j < jlen; j += 1) {
                    if (mylexlst[j] && mylexlst[j] === lexlst[j] && j === lexlst.length - 1) {
                        ret = true;
                        break outerLoop;
                    }
                }
            }
        }
        return ret;
    };
    this.tests.push(func);
};
CSL.Attributes["@is-uncertain-date"] = function (state, arg) {
    var variables, len, pos, func, variable, ret;
    variables = arg.split(/\s+/);
    len = variables.length;
    func = function (state, Item) {
        ret = [];
        for (pos = 0; pos < len; pos += 1) {
            variable = variables[pos];
            if (Item[variable] && Item[variable].circa) {
                ret.push(true);
            } else {
                ret.push(false);
            }
        }
        return ret;
    };
    this.tests.push(func);
};
CSL.Attributes["@is-numeric"] = function (state, arg) {
    var variables, variable, func, val, pos, len, ret;
    variables = arg.split(/\s+/);
    len = variables.length;
    func = function (state, Item, item) {
        var numeric_variable, counter_variable;
        ret = [];
        var numeric = true;
        for (pos = 0; pos < len; pos += 1) {
            if (!state.tmp.shadow_numbers[variables[pos]]) {
                if ("locator" === variables[pos]) {
                    state.processNumber(false, item, "locator", Item.type);
                } else {
                    state.processNumber(false, Item, variables[pos], Item.type);
                }
            }
            var myitem = Item;
            if (["locator-revision"].indexOf(variables[pos]) > -1) {
                myitem = item;
            }
            if (!state.tmp.shadow_numbers[variables[pos]].numeric
                && !(['title', 'locator-revision'].indexOf(variables[pos]) > -1
                     && myitem[variables[pos]] 
                     && myitem[variables[pos]].slice(-1) === "" + parseInt(myitem[variables[pos]].slice(-1)))) {
                numeric = false;
                break;
            }
        }
        return numeric;
    };
    this.tests.push(func);
};
CSL.Attributes["@names-min"] = function (state, arg) {
    var val = parseInt(arg, 10);
    if (state.opt.max_number_of_names < val) {
        state.opt.max_number_of_names = val;
    }
    this.strings["et-al-min"] = val;
};
CSL.Attributes["@names-use-first"] = function (state, arg) {
    this.strings["et-al-use-first"] = parseInt(arg, 10);
};
CSL.Attributes["@names-use-last"] = function (state, arg) {
    if (arg === "true") {
        this.strings["et-al-use-last"] = true;
    } else {
        this.strings["et-al-use-last"] = false;
    }
};
CSL.Attributes["@sort"] = function (state, arg) {
    if (arg === "descending") {
        this.strings.sort_direction = CSL.DESCENDING;
    }
};
CSL.Attributes["@plural"] = function (state, arg) {
    if ("always" === arg || "true" === arg) {
        this.strings.plural = 1;
    } else if ("never" === arg || "false" === arg) {
        this.strings.plural = 0;
    } else if ("contextual" === arg) {
        this.strings.plural = false;
    }
};
CSL.Attributes["@locator"] = function (state, arg) {
    var func;
    var trylabels = arg.replace("sub verbo", "sub-verbo");
    trylabels = trylabels.split(/\s+/);
    if (["if",  "else-if"].indexOf(this.name) > -1) {
        func = function (state, Item, item) {
            var ret = [];
            var label;
            if ("undefined" === typeof item || !item.label) {
                label = "page";
            } else if (item.label === "sub verbo") {
                label = "sub-verbo";
            } else {
                label = item.label;
            }
            for (var i = 0, ilen = trylabels.length; i < ilen; i += 1) {
                if (trylabels[i] === label) {
                    ret.push(true);
                } else {
                    ret.push(false);
                }
            }
            return ret;
        };
        this.tests.push(func);
    }
};
CSL.Attributes["@page"] = function (state, arg) {
    var func;
    var trylabels = arg.replace("sub verbo", "sub-verbo");
    trylabels = trylabels.split(/\s+/);
    if (["if",  "else-if"].indexOf(this.name) > -1) {
        func = function (state, Item, item) {
            var ret = [];
            var label;
            state.processNumber(false, Item, "page", Item.type);
            if (!state.tmp.shadow_numbers["page"].label) {
                label = "page";
            } else if (state.tmp.shadow_numbers["page"].label === "sub verbo") {
                label = "sub-verbo";
            } else {
                label = state.tmp.shadow_numbers["page"].label;
            }
            for (var i = 0, ilen = trylabels.length; i < ilen; i += 1) {
                if (trylabels[i] === label) {
                    ret.push(true);
                } else {
                    ret.push(false);
                }
            }
            return ret;
        };
        this.tests.push(func);
    }
};
CSL.Attributes["@number"] = function (state, arg) {
    var func;
    var trylabels = arg.replace("sub verbo", "sub-verbo");
    trylabels = trylabels.split(/\s+/);
    if (["if",  "else-if"].indexOf(this.name) > -1) {
        func = function (state, Item, item) {
            var ret = [];
            var label;
            state.processNumber(false, Item, "number", Item.type);
            if (!state.tmp.shadow_numbers["number"].label) {
                label = "number";
            } else if (state.tmp.shadow_numbers["number"].label === "sub verbo") {
                label = "sub-verbo";
            } else {
                label = state.tmp.shadow_numbers["number"].label;
            }
            for (var i = 0, ilen = trylabels.length; i < ilen; i += 1) {
                if (trylabels[i] === label) {
                    ret.push(true);
                } else {
                    ret.push(false);
                }
            }
            return ret;
        };
        this.tests.push(func);
    }
};
CSL.Attributes["@has-publisher-and-publisher-place"] = function (state, arg) {
    this.strings["has-publisher-and-publisher-place"] = true;
};
CSL.Attributes["@publisher-delimiter-precedes-last"] = function (state, arg) {
    this.strings["publisher-delimiter-precedes-last"] = arg;
};
CSL.Attributes["@publisher-delimiter"] = function (state, arg) {
    this.strings["publisher-delimiter"] = arg;
};
CSL.Attributes["@publisher-and"] = function (state, arg) {
    this.strings["publisher-and"] = arg;
};
CSL.Attributes["@newdate"] = function (state, arg) {
};
CSL.Attributes["@position"] = function (state, arg) {
    var tryposition;
    state.opt.update_mode = CSL.POSITION;
    if ("near-note" === arg) {
        var near_note_func = function (state, Item, item) {
            if (item && item["position"] === CSL.POSITION_SUBSEQUENT && item["near-note"]) {
                return true;
            }
            return false;
        };
        this.tests.push(near_note_func);
    } else {
        var factory = function (tryposition) {
            return  function (state, Item, item) {
                if (state.tmp.area === "bibliography") {
                    return false;
                }
                if (item && "undefined" === typeof item.position) {
                    item.position = 0;
                }
                if (item && typeof item.position === "number") {
                    if (item.position === 0 && tryposition === 0) {
                        return true;
                    } else if (tryposition > 0 && item.position >= tryposition) {
                        return true;
                    }
                } else if (tryposition === 0) {
                    return true;
                }
                return false;
            };
        };
        var lst = arg.split(/\s+/);
        for (var i = 0, ilen = lst.length; i < ilen; i += 1) {
            if (lst[i] === "first") {
                tryposition = CSL.POSITION_FIRST;
            } else if (lst[i] === "subsequent") {
                tryposition = CSL.POSITION_SUBSEQUENT;
            } else if (lst[i] === "ibid") {
                tryposition = CSL.POSITION_IBID;
            } else if (lst[i] === "ibid-with-locator") {
                tryposition = CSL.POSITION_IBID_WITH_LOCATOR;
            }
            var func = factory(tryposition);
            this.tests.push(func);
        }
    }
}
CSL.Attributes["@disambiguate"] = function (state, arg) {
    if (this.tokentype === CSL.START && ["if", "else-if"].indexOf(this.name) > -1) {
        if (arg === "true") {
            state.opt.has_disambiguate = true;
            var func = function (state, Item) {
                if (state.tmp.disambig_settings.disambiguate) {
                    return true;
                }
                return false;
            };
            this.tests.push(func);
        }
    }
};
CSL.Attributes["@givenname-disambiguation-rule"] = function (state, arg) {
    if (CSL.GIVENNAME_DISAMBIGUATION_RULES.indexOf(arg) > -1) {
        state.opt["givenname-disambiguation-rule"] = arg;
    }
};
CSL.Attributes["@collapse"] = function (state, arg) {
    if (arg) {
        state[this.name].opt.collapse = arg;
    }
};
CSL.Attributes["@names-delimiter"] = function (state, arg) {
    state.setOpt(this, "names-delimiter", arg);
};
CSL.Attributes["@name-form"] = function (state, arg) {
    state.setOpt(this, "name-form", arg);
};
CSL.Attributes["@subgroup-delimiter"] = function (state, arg) {
    this.strings["subgroup-delimiter"] = arg;
};
CSL.Attributes["@subgroup-delimiter-precedes-last"] = function (state, arg) {
    this.strings["subgroup-delimiter-precedes-last"] = arg;
};
CSL.Attributes["@name-delimiter"] = function (state, arg) {
    state.setOpt(this, "name-delimiter", arg);
};
CSL.Attributes["@et-al-min"] = function (state, arg) {
    var val = parseInt(arg, 10);
    if (state.opt.max_number_of_names < val) {
        state.opt.max_number_of_names = val;
    }
    state.setOpt(this, "et-al-min", val);
};
CSL.Attributes["@et-al-use-first"] = function (state, arg) {
    state.setOpt(this, "et-al-use-first", parseInt(arg, 10));
};
CSL.Attributes["@et-al-use-last"] = function (state, arg) {
    if (arg === "true") {
        state.setOpt(this, "et-al-use-last", true);
    } else {
        state.setOpt(this, "et-al-use-last", false);
    }
};
CSL.Attributes["@et-al-subsequent-min"] = function (state, arg) {
    var val = parseInt(arg, 10);
    if (state.opt.max_number_of_names < val) {
        state.opt.max_number_of_names = val;
    }
    state.setOpt(this, "et-al-subsequent-min", val);
};
CSL.Attributes["@et-al-subsequent-use-first"] = function (state, arg) {
    state.setOpt(this, "et-al-subsequent-use-first", parseInt(arg, 10));
};
CSL.Attributes["@suppress-min"] = function (state, arg) {
    this.strings["suppress-min"] = parseInt(arg, 10);
};
CSL.Attributes["@suppress-max"] = function (state, arg) {
    this.strings["suppress-max"] = parseInt(arg, 10);
};
CSL.Attributes["@and"] = function (state, arg) {
    state.setOpt(this, "and", arg);
};
CSL.Attributes["@delimiter-precedes-last"] = function (state, arg) {
    state.setOpt(this, "delimiter-precedes-last", arg);
};
CSL.Attributes["@delimiter-precedes-et-al"] = function (state, arg) {
    state.setOpt(this, "delimiter-precedes-et-al", arg);
};
CSL.Attributes["@initialize-with"] = function (state, arg) {
    state.setOpt(this, "initialize-with", arg);
};
CSL.Attributes["@initialize"] = function (state, arg) {
    if (arg === "false") {
        state.setOpt(this, "initialize", false);
    }
};
CSL.Attributes["@name-as-sort-order"] = function (state, arg) {
    state.setOpt(this, "name-as-sort-order", arg);
};
CSL.Attributes["@sort-separator"] = function (state, arg) {
    state.setOpt(this, "sort-separator", arg);
};
CSL.Attributes["@year-suffix-delimiter"] = function (state, arg) {
    state[this.name].opt["year-suffix-delimiter"] = arg;
};
CSL.Attributes["@after-collapse-delimiter"] = function (state, arg) {
    state[this.name].opt["after-collapse-delimiter"] = arg;
};
CSL.Attributes["@subsequent-author-substitute"] = function (state, arg) {
    state[this.name].opt["subsequent-author-substitute"] = arg;
};
CSL.Attributes["@subsequent-author-substitute-rule"] = function (state, arg) {
    state[this.name].opt["subsequent-author-substitute-rule"] = arg;
};
CSL.Attributes["@disambiguate-add-names"] = function (state, arg) {
    if (arg === "true") {
        state.opt["disambiguate-add-names"] = true;
    }
};
CSL.Attributes["@disambiguate-add-givenname"] = function (state, arg) {
    if (arg === "true") {
        state.opt["disambiguate-add-givenname"] = true;
    }
};
CSL.Attributes["@disambiguate-add-year-suffix"] = function (state, arg) {
    if (arg === "true") {
        state.opt["disambiguate-add-year-suffix"] = true;
    }
};
CSL.Attributes["@second-field-align"] = function (state, arg) {
    if (arg === "flush" || arg === "margin") {
        state[this.name].opt["second-field-align"] = arg;
    }
};
CSL.Attributes["@hanging-indent"] = function (state, arg) {
    if (arg === "true") {
        state[this.name].opt.hangingindent = 2;
    }
};
CSL.Attributes["@line-spacing"] = function (state, arg) {
    if (arg && arg.match(/^[.0-9]+$/)) {
        state[this.name].opt["line-spacing"] = parseFloat(arg, 10);
    }
};
CSL.Attributes["@entry-spacing"] = function (state, arg) {
    if (arg && arg.match(/^[.0-9]+$/)) {
        state[this.name].opt["entry-spacing"] = parseFloat(arg, 10);
    }
};
CSL.Attributes["@near-note-distance"] = function (state, arg) {
    state[this.name].opt["near-note-distance"] = parseInt(arg, 10);
};
CSL.Attributes["@text-case"] = function (state, arg) {
    var func = function (state, Item) {
        if (arg === "normal") {
            this.text_case_normal = true;
        } else {
            this.strings["text-case"] = arg;
            if (arg === "title") {
                var m = false;
                var default_locale = state.opt["default-locale"][0].slice(0, 2);
                if (Item.jurisdiction) {
                    this.strings["text-case"] = "passthrough";
                } else if (Item.language) {
                    m = Item.language.match(/^\s*([A-Za-z]{2})(?:$|-| )/);
                    if (!m) {
                        this.strings["text-case"] = "passthrough";
                    } else if (m[1].toLowerCase() !== "en") {
                        this.strings["text-case"] = "passthrough";
                        for (var i = 0, ilen = state.opt.english_locale_escapes.length; i < ilen; i += 1) {
                            var escaper = state.opt.english_locale_escapes[i];
                            if (m[1].slice(0, escaper.length).toLowerCase() === escaper) {
                                this.strings["text-case"] = arg;
                            }
                        }
                    }
                } else if (default_locale !== "en") {
                    this.strings["text-case"] = "passthrough";
                }
            }
        }
    };
    this.execs.push(func);
};
CSL.Attributes["@page-range-format"] = function (state, arg) {
    state.opt["page-range-format"] = arg;
};
CSL.Attributes["@year-range-format"] = function (state, arg) {
    state.opt["year-range-format"] = arg;
};
CSL.Attributes["@default-locale"] = function (state, arg) {
    var lst, len, pos, m, ret;
    m = arg.match(/-x-(sort|translit|translat)-/g);
    if (m) {
        for (pos = 0, len = m.length; pos < len; pos += 1) {
            m[pos] = m[pos].replace(/^-x-/, "").replace(/-$/, "");
        }
    }
    lst = arg.split(/-x-(?:sort|translit|translat)-/);
    ret = [lst[0]];
    for (pos = 1, len = lst.length; pos < len; pos += 1) {
        ret.push(m[pos - 1]);
        ret.push(lst[pos]);
    }
    lst = ret.slice();
    len = lst.length;
    for (pos = 1; pos < len; pos += 2) {
        state.opt[("locale-" + lst[pos])].push(lst[(pos + 1)].replace(/^\s*/g, "").replace(/\s*$/g, ""));
    }
    if (lst.length) {
        state.opt["default-locale"] = lst.slice(0, 1);
    } else {
        state.opt["default-locale"] = ["en"];
    }
};
CSL.Attributes["@demote-non-dropping-particle"] = function (state, arg) {
    state.opt["demote-non-dropping-particle"] = arg;
};
CSL.Attributes["@initialize-with-hyphen"] = function (state, arg) {
    if (arg === "false") {
        state.opt["initialize-with-hyphen"] = false;
    }
};
CSL.Attributes["@institution-parts"] = function (state, arg) {
    this.strings["institution-parts"] = arg;
};
CSL.Attributes["@if-short"] = function (state, arg) {
    if (arg === "true") {
        this.strings["if-short"] = true;
    }
};
CSL.Attributes["@substitute-use-first"] = function (state, arg) {
    this.strings["substitute-use-first"] = parseInt(arg, 10);
};
CSL.Attributes["@use-first"] = function (state, arg) {
    this.strings["use-first"] = parseInt(arg, 10);
};
CSL.Attributes["@stop-last"] = function (state, arg) {
    this.strings["stop-last"] = parseInt(arg, 10) * -1;
}
CSL.Attributes["@oops"] = function (state, arg) {
    this.strings.oops = arg;
}
CSL.Attributes["@use-last"] = function (state, arg) {
    this.strings["use-last"] = parseInt(arg, 10);
};
CSL.Attributes["@reverse-order"] = function (state, arg) {
    if ("true" === arg) {
        this.strings["reverse-order"] = true;
    }
};
CSL.Attributes["@display"] = function (state, arg) {
    this.strings.cls = arg;
};
var XML_PARSING;
if ("undefined" !== typeof CSL_IS_NODEJS) {
    XML_PARSING = CSL_NODEJS;
} else if ("undefined" !== typeof CSL_E4X) {
    XML_PARSING = CSL_E4X;
} else {
    XML_PARSING = CSL_CHROME;
}
CSL.System = {};
CSL.System.Xml = {
    "Parsing": XML_PARSING
};
CSL.Stack = function (val, literal) {
    this.mystack = [];
    if (literal || val) {
        this.mystack.push(val);
    }
};
CSL.Stack.prototype.push = function (val, literal) {
    if (literal || val) {
        this.mystack.push(val);
    } else {
        this.mystack.push("");
    }
};
CSL.Stack.prototype.clear = function () {
    this.mystack = [];
};
CSL.Stack.prototype.replace = function (val, literal) {
    if (this.mystack.length === 0) {
        throw "Internal CSL processor error: attempt to replace nonexistent stack item with " + val;
    }
    if (literal || val) {
        this.mystack[(this.mystack.length - 1)] = val;
    } else {
        this.mystack[(this.mystack.length - 1)] = "";
    }
};
CSL.Stack.prototype.pop = function () {
    return this.mystack.pop();
};
CSL.Stack.prototype.value = function () {
    return this.mystack.slice(-1)[0];
};
CSL.Stack.prototype.length = function () {
    return this.mystack.length;
};
CSL.Util = {};
CSL.Util.Match = function () {
    this.any = function (token, state, Item, item) {
        var ret = false;
        for (var i = 0, ilen = token.tests.length; i < ilen; i += 1) {
            var func = token.tests[i];
            var reslist = func.call(token, state, Item, item);
            if ("object" !== typeof reslist) {
                reslist = [reslist];
            }
            for (var j = 0, jlen = reslist.length; j < jlen; j += 1) {
                if (reslist[j]) {
                    ret = true;
                    break;
                }
            }
            if (ret) {
                break;
            }
        }
        if (ret) {
            ret = token.succeed;
            state.tmp.jump.replace("succeed");
        } else {
            ret = token.fail;
            state.tmp.jump.replace("fail");
        }
        return ret;
    };
    this.none = function (token, state, Item, item) {
        var ret = true;
        for (var i = 0, ilen = this.tests.length; i < ilen; i += 1) {
            var func = this.tests[i];
            var reslist = func.call(token, state, Item, item);
            if ("object" !== typeof reslist) {
                reslist = [reslist];
            }
            for (var j = 0, jlen = reslist.length; j < jlen; j += 1) {
                if (reslist[j]) {
                    ret = false;
                    break;
                }
            }
            if (!ret) {
                break;
            }
        }
        if (ret) {
            ret = token.succeed;
            state.tmp.jump.replace("succeed");
        } else {
            ret = token.fail;
            state.tmp.jump.replace("fail");
        }
        return ret;
    };
    this.all = function (token, state, Item, item) {
        var ret = true;
        for (var i = 0, ilen = this.tests.length; i < ilen; i += 1) {
            var func = this.tests[i];
            var reslist = func.call(token, state, Item, item);
            if ("object" !== typeof reslist) {
                reslist = [reslist];
            }
            for (var j = 0, jlen = reslist.length; j < jlen; j += 1) {
                if (!reslist[j]) {
                    ret = false;
                    break;
                }
            }
            if (!ret) {
                break;
            }
        }
        if (ret) {
            ret = token.succeed;
            state.tmp.jump.replace("succeed");
        } else {
            ret = token.fail;
            state.tmp.jump.replace("fail");
        }
        return ret;
    };
};
CSL.Transform = function (state) {
    var debug = false, abbreviations, token, fieldname, abbrev_family, opt;
    this.abbrevs = {};
    this.abbrevs["default"] = new state.sys.AbbreviationSegments();
    function abbreviate(state, Item, altvar, basevalue, myabbrev_family, use_field) {
        var value;
        if (!myabbrev_family) {
            return basevalue;
        }
        if (["publisher-place", "event-place", "jurisdiction"].indexOf(myabbrev_family) > -1) {
            myabbrev_family = "place";
        }
        if (["publisher", "authority"].indexOf(myabbrev_family) > -1) {
            myabbrev_family = "institution-part";
        }
        if (["genre", "event", "medium"].indexOf(myabbrev_family) > -1) {
            myabbrev_family = "title";
        }
        if (["title-short"].indexOf(myabbrev_family) > -1) {
            myabbrev_family = "title";
        }
        value = "";
        if (state.sys.getAbbreviation) {
            var jurisdiction = state.transform.loadAbbreviation(Item.jurisdiction, myabbrev_family, basevalue);
            if (state.transform.abbrevs[jurisdiction][myabbrev_family] && basevalue && state.sys.getAbbreviation) {
                if (state.transform.abbrevs[jurisdiction][myabbrev_family][basevalue]) {
                    value = state.transform.abbrevs[jurisdiction][myabbrev_family][basevalue];
                }
            }
        }
        if (!value && altvar && Item[altvar] && use_field) {
            value = Item[altvar];
        }
        if (!value) {
            value = basevalue;
        }
        return value;
    }
    function getTextSubField(Item, field, locale_type, use_default, stopOrig) {
        var m, lst, opt, o, oo, pos, key, ret, len, myret, opts;
        var usedOrig = stopOrig;
        if (!Item[field]) {
            return {name:"", usedOrig:stopOrig};
        }
        ret = {name:"", usedOrig:stopOrig};
        opts = state.opt[locale_type];
        if (locale_type === 'locale-orig') {
            if (stopOrig) {
                ret = {name:"", usedOrig:stopOrig};
            } else {
                ret = {name:Item[field], usedOrig:false};
            }
            return ret;
        } else if (use_default && ("undefined" === typeof opts || opts.length === 0)) {
            return {name:Item[field], usedOrig:true};
        }
        for (var i = 0, ilen = opts.length; i < ilen; i += 1) {
            opt = opts[i];
            o = opt.split(/[\-_]/)[0];
            if (opt && Item.multi && Item.multi._keys[field] && Item.multi._keys[field][opt]) {
                ret.name = Item.multi._keys[field][opt];
                break;
            } else if (o && Item.multi && Item.multi._keys[field] && Item.multi._keys[field][o]) {
                ret.name = Item.multi._keys[field][o];
                break;
            }
        }
        if (!ret.name && use_default) {
            ret = {name:Item[field], usedOrig:true};
        }
        return ret;
    }
    function loadAbbreviation(jurisdiction, category, orig) {
        var pos, len;
        if (!jurisdiction) {
            jurisdiction = "default";
        }
        if (!orig) {
            if (!this.abbrevs[jurisdiction]) {
                this.abbrevs[jurisdiction] = new state.sys.AbbreviationSegments();
            }
            return jurisdiction;
        }
        if (state.sys.getAbbreviation) {
            var tryList = ['default'];
            if (jurisdiction !== 'default') {
                var workLst = jurisdiction.split(/\s*;\s*/);
                for (var i=0, ilen=workLst.length; i < ilen; i += 1) {
                    tryList.push(workLst.slice(0,i+1).join(';'));
                }
            }
            for (var i=tryList.length - 1; i > -1; i += -1) {
                if (!this.abbrevs[tryList[i]]) {
                    this.abbrevs[tryList[i]] = new state.sys.AbbreviationSegments();
                }
                if (!this.abbrevs[tryList[i]][category][orig]) {
                    state.sys.getAbbreviation(state.opt.styleID, this.abbrevs, tryList[i], category, orig);
                }
                if (this.abbrevs[tryList[i]][category][orig]) {
                    if (i < tryList.length) {
                        this.abbrevs[jurisdiction][category][orig] = this.abbrevs[tryList[i]][category][orig];
                    }
                    break;
                }
            }
        }
        return jurisdiction;
    }
    this.loadAbbreviation = loadAbbreviation;
    function publisherCheck (tok, Item, primary, myabbrev_family) {
        var varname = tok.variables[0];
        if (state.publisherOutput && primary) {
            if (["publisher","publisher-place"].indexOf(varname) === -1) {
                return false;
            } else {
                state.publisherOutput[varname + "-token"] = tok;
                state.publisherOutput.varlist.push(varname);
                var lst = primary.split(/;\s*/);
                if (lst.length === state.publisherOutput[varname + "-list"].length) {
                    state.publisherOutput[varname + "-list"] = lst;
                }
                for (var i = 0, ilen = lst.length; i < ilen; i += 1) {
                    lst[i] = abbreviate(state, Item, false, lst[i], myabbrev_family, true);
                }
                state.tmp[varname + "-token"] = tok;
                return true;
            }
        }
        return false;
    }
    function getOutputFunction(variables, myabbrev_family, abbreviation_fallback, alternative_varname, transform_fallback) {
		var localesets;
        var langPrefs = CSL.LangPrefsMap[variables[0]];
        if (!langPrefs) {
            localesets = false;
        } else {
            localesets = state.opt['cite-lang-prefs'][langPrefs];
        }
        return function (state, Item, item, usedOrig) {
            var primary, secondary, tertiary, primary_tok, group_tok, key;
            if (!variables[0]) {
                return null;
            }
		    var slot = {primary:false, secondary:false, tertiary:false};
		    if (state.tmp.area.slice(-5) === "_sort") {
			    slot.primary = 'locale-sort';
		    } else {
			    if (localesets) {
				    var slotnames = ["primary", "secondary", "tertiary"];
				    for (var i = 0, ilen = slotnames.length; i < ilen; i += 1) {
					    if (localesets.length - 1 <  i) {
						    break;
					    }
                        if (localesets[i]) {
						    slot[slotnames[i]] = 'locale-' + localesets[i];
                        }
				    }
			    } else {
					slot.primary = 'locale-translat';
			    }
            }
			if ((state.tmp.area !== "bibliography"
				 && !(state.tmp.area === "citation"
					  && state.opt.xclass === "note"
					  && item && !item.position))
				|| myabbrev_family) {
				slot.secondary = false;
				slot.tertiary = false;
			}
            if (state.tmp["publisher-list"]) {
                if (variables[0] === "publisher") {
                    state.tmp["publisher-token"] = this;
                } else if (variables[0] === "publisher-place") {
                    state.tmp["publisher-place-token"] = this;
                }
                return null;
            }
            var res = getTextSubField(Item, variables[0], slot.primary, true);
            primary = res.name;
            if (publisherCheck(this, Item, primary, myabbrev_family)) {
                return null;
            }
			secondary = false;
			tertiary = false;
			if (slot.secondary) {
				res = getTextSubField(Item, variables[0], slot.secondary, false, res.usedOrig);
                secondary = res.name;
			}
			if (slot.tertiary) {
				res = getTextSubField(Item, variables[0], slot.tertiary, false, res.usedOrig);
                tertiary = res.name;
			}
            if (myabbrev_family) {
                primary = abbreviate(state, Item, alternative_varname, primary, myabbrev_family, true);
                if (primary) {
                    primary = quashCheck(primary);
                }
                secondary = abbreviate(state, Item, false, secondary, myabbrev_family, true);
                tertiary = abbreviate(state, Item, false, tertiary, myabbrev_family, true);
            }
            if ("demote" === this["leading-noise-words"]) {
                primary = CSL.demoteNoiseWords(state, primary);
                secondary = CSL.demoteNoiseWords(state, secondary);
                tertiary = CSL.demoteNoiseWords(state, tertiary);
            }
            if (secondary || tertiary) {
                primary_tok = CSL.Util.cloneToken(this);
                primary_tok.strings.suffix = "";
                state.output.append(primary, primary_tok);
                group_tok = new CSL.Token();
                group_tok.strings.prefix = " [";
                group_tok.strings.delimiter = ", ";
                group_tok.strings.suffix = "]" + this.strings.suffix;
				state.output.openLevel(group_tok);
				if (secondary) {
					state.output.append(secondary);
				}
				if (tertiary) {
					state.output.append(tertiary);
				}
				state.output.closeLevel();
            } else {
                state.output.append(primary, this);
            }
            return null;
        };
    }
    this.getOutputFunction = getOutputFunction;
    function getHereinafter (Item) {
        var hereinafter_author_title = [];
        if (state.tmp.first_name_string) {
            hereinafter_author_title.push(state.tmp.first_name_string);
        }
        if (Item.title) {
            hereinafter_author_title.push(Item.title);
        }
        var hereinafter_metadata = [];
        if (Item.type) {
            hereinafter_metadata.push("type:" + Item.type);
        }
        var date_segment = Item.issued
        if (["bill","gazette","legislation","legal_case","treaty"].indexOf(Item.type) > -1) {
            date_segment = Item["original-date"];
        }
        if (date_segment) {
            var date = [];
            for (var j = 0, jlen = CSL.DATE_PARTS.length; j < jlen; j += 1) {
                if (date_segment[CSL.DATE_PARTS[j]]) {
                    var element =  date_segment[CSL.DATE_PARTS[j]];
                    while (element.length < 2) {
                        element = "0" + element;
                    }
                    date.push(element);
                }
            }
            date = date.join("-");
            if (date) {
                hereinafter_metadata.push("date:" + date);
            }
        }
        var jurisdiction = "default";
        if (Item.jurisdiction) {
            jurisdiction = Item.jurisdiction;
        }
        hereinafter_metadata = hereinafter_metadata.join(", ");
        if (hereinafter_metadata) {
            hereinafter_metadata = " [" + hereinafter_metadata + "]";
        }
        var hereinafter_key = hereinafter_author_title.join(", ") + hereinafter_metadata;
        return [jurisdiction, hereinafter_key];
    }
    this.getHereinafter = getHereinafter;
    function quashCheck(value) {
        var m = value.match(/^!([-,_a-z]+)<<</);
        if (m) {
            var fields = m[1].split(",");
            value = value.slice(m[0].length);
            for (var i = 0, ilen = fields.length; i < ilen; i += 1) {
                if (state.tmp.done_vars.indexOf(fields[i]) === -1) {
                    state.tmp.done_vars.push(fields[i]);
                }
            }
        }
        return value;
    }
    this.quashCheck = quashCheck;
};
CSL.Parallel = function (state) {
    this.state = state;
    this.sets = new CSL.Stack([]);
    this.try_cite = true;
    this.use_parallels = true;
    this.midVars = ["section", "volume", "container-title", "collection-number", "issue", "page", "page-first", "number"];
    this.ignoreVarsOther = ["first-reference-note-number", "locator", "label"];
    this.ignoreVarsOrders = ["first-reference-note-number"];
};
CSL.Parallel.prototype.isMid = function (variable) {
    return (this.midVars.indexOf(variable) > -1);
};
CSL.Parallel.prototype.StartCitation = function (sortedItems, out) {
    this.parallel_conditional_blobs_list = [];
    if (this.use_parallels) {
        this.sortedItems = sortedItems;
        this.sortedItemsPos = -1;
        this.sets.clear();
        this.sets.push([]);
        this.in_series = true;
        this.delim_counter = 0;
        this.delim_pointers = [];
        if (out) {
            this.out = out;
        } else {
            this.out = this.state.output.queue;
        }
        this.master_was_neutral_cite = true;
    }
};
CSL.Parallel.prototype.StartCite = function (Item, item, prevItemID) {
    var position, len, pos, x, curr, master, last_id, prev_locator, curr_locator, is_master, parallel;
    if (["treaty"].indexOf(Item.type) > -1) {
        this.ignoreVars = this.ignoreVarsOrders;
    } else {
        this.ignoreVars = this.ignoreVarsOther;
    }
    if (this.use_parallels) {
        if (this.sets.value().length && this.sets.value()[0].itemId == Item.id) {
            this.ComposeSet();
        }
        this.sortedItemsPos += 1;
        if (item) {
            position = item.position;
        }
        this.try_cite = true;
        var has_required_var = false;
        for (var i = 0, ilen = CSL.PARALLEL_MATCH_VARS.length; i < ilen; i += 1) {
            if (Item[CSL.PARALLEL_MATCH_VARS[i]]) {
                has_required_var = true;
                break;
            }
        }
        var title_ok = true;
        var last_cite = this.sets.value().slice(-1)[0];
        if (last_cite && (last_cite.Item.title || Item.title)) {
            if (last_cite.Item.title !== Item.title) {
                title_ok = false;
            }
        }
        if (!title_ok || !has_required_var || CSL.PARALLEL_TYPES.indexOf(Item.type) === -1) {
            this.try_cite = true;
            if (this.in_series) {
                this.in_series = false;
            }
        }
        this.cite = {};
        this.cite.front = [];
        this.cite.mid = [];
        this.cite.back = [];
        this.cite.front_collapse = {};
        this.cite.back_forceme = [];
        this.cite.position = position;
        this.cite.Item = Item;
        this.cite.itemId = "" + Item.id;
        this.cite.prevItemID = "" + prevItemID;
        this.target = "front";
        if (this.sortedItems && this.sortedItemsPos > 0 && this.sortedItemsPos < this.sortedItems.length) {
            curr = this.sortedItems[this.sortedItemsPos][1];
            last_id = "" + this.sortedItems[(this.sortedItemsPos - 1)][1].id;
            master = this.state.registry.registry[last_id].parallel;
            prev_locator = false;
            if (master == curr.id) {
                len = this.sortedItemsPos - 1;
                for (pos = len; pos > -1; pos += -1) {
                    if (this.sortedItems[pos][1].id == Item.id) {
                        prev_locator = this.sortedItems[pos][1].locator;
                        break;
                    }
                }
                curr_locator = this.sortedItems[this.sortedItemsPos][1].locator;
                if (!prev_locator && curr_locator) {
                    curr.position = CSL.POSITION_IBID_WITH_LOCATOR;
                } else if (curr_locator === prev_locator) {
                    curr.position = CSL.POSITION_IBID;
                } else {
                    curr.position = CSL.POSITION_IBID_WITH_LOCATOR;
                }
            }
        }
        this.force_collapse = false;
        if (this.state.registry.registry[Item.id].parallel) {
            this.force_collapse = true;
        }
    }
};
CSL.Parallel.prototype.StartVariable = function (variable) {
    if (this.use_parallels && (this.try_cite || this.force_collapse)) {
        if (variable === "names") {
            this.variable = variable + ":" + this.target;
        } else {
            this.variable = variable;
        }
        if (this.ignoreVars.indexOf(variable) > -1) {
            return;
        }
        if (variable === "container-title" && this.sets.value().length === 0) {
            this.master_was_neutral_cite = false;
        }
        this.data = {};
        this.data.value = "";
        this.data.blobs = [];
        var is_mid = this.isMid(variable);
        if (this.target === "front" && is_mid) {
            this.target = "mid";
        } else if (this.target === "mid" && !is_mid && this.cite.Item.title && variable !== "names") {
            this.target = "back";
        } else if (this.target === "back" && is_mid) {
            this.try_cite = true;
            this.in_series = false;
        }
        if (variable === "number") {
            this.cite.front.push(this.variable);
        } else if (CSL.PARALLEL_COLLAPSING_MID_VARSET.indexOf(variable) > -1) {
            this.cite.front.push(this.variable);
        } else {
            this.cite[this.target].push(this.variable);
        }
    }
};
CSL.Parallel.prototype.AppendBlobPointer = function (blob) {
    if (this.ignoreVars.indexOf(this.variable) > -1) {
        return;
    }
    if (this.use_parallels && this.variable && (this.try_cite || this.force_collapse) && blob && blob.blobs) {
        this.data.blobs.push([blob, blob.blobs.length]);
    }
};
CSL.Parallel.prototype.AppendToVariable = function (str, varname) {
    if (this.ignoreVars.indexOf(this.variable) > -1) {
        return;
    }
    if (this.use_parallels && (this.try_cite || this.force_collapse)) {
        if (this.target !== "back" || true) {
            this.data.value += "::" + str;
        } else {
            var prev = this.sets.value()[(this.sets.value().length - 1)];
            if (prev) {
                if (prev[this.variable]) {
                    if (prev[this.variable].value) {
                        this.data.value += "::" + str;
                    }
                }
            }
        }
    }
};
CSL.Parallel.prototype.CloseVariable = function () {
    if (this.ignoreVars.indexOf(this.variable) > -1) {
        return;
    }
    if (this.use_parallels && (this.try_cite || this.force_collapse)) {
        this.cite[this.variable] = this.data;
        if (this.sets.value().length > 0) {
            var prev = this.sets.value()[(this.sets.value().length - 1)];
            if (this.target === "front" && this.variable === "original-date") {
                if (this.data.value && this.master_was_neutral_cite) {
                    this.target = "mid";
                }
            }
            if (this.target === "front") {
                if ((prev[this.variable] || this.data.value) && (!prev[this.variable] || this.data.value !== prev[this.variable].value)) {
                    if ("original-date" !== this.variable) {
                        this.in_series = false;
                    }
                }
            } else if (this.target === "mid") {
                if (CSL.PARALLEL_COLLAPSING_MID_VARSET.indexOf(this.variable) > -1) {
                    if (prev[this.variable]) {
                        if (prev[this.variable].value === this.data.value) {
                            this.cite.front_collapse[this.variable] = true;
                        } else {
                            this.cite.front_collapse[this.variable] = false;
                        }
                    } else {
                        this.cite.front_collapse[this.variable] = false;
                    }
                }
            } else if (this.target === "back") {
                if (prev[this.variable]) {
                    if (this.data.value !== prev[this.variable].value 
                        && this.sets.value().slice(-1)[0].back_forceme.indexOf(this.variable) === -1) {
                        this.in_series = false;
                    }
                }
            }
        }
    }
    this.variable = false;
};
CSL.Parallel.prototype.CloseCite = function () {
    var x, pos, len, has_issued, use_journal_info, volume_pos, container_title_pos, section_pos;
    if (this.use_parallels) {
        use_journal_info = false;
        if (!this.cite.front_collapse["container-title"]) {
            use_journal_info = true;
        }
        if (this.cite.front_collapse.volume === false) {
            use_journal_info = true;
        }
        if (this.cite.front_collapse["collection-number"] === false) {
            use_journal_info = true;
        }
        if (this.cite.front_collapse.section === false) {
            use_journal_info = true;
        }
        if (use_journal_info) {
            this.cite.use_journal_info = true;
            section_pos = this.cite.front.indexOf("section");
            if (section_pos > -1) {
                this.cite.front = this.cite.front.slice(0,section_pos).concat(this.cite.front.slice(section_pos + 1));
            }
            volume_pos = this.cite.front.indexOf("volume");
            if (volume_pos > -1) {
                this.cite.front = this.cite.front.slice(0,volume_pos).concat(this.cite.front.slice(volume_pos + 1));
            }
            container_title_pos = this.cite.front.indexOf("container-title");
            if (container_title_pos > -1) {
                this.cite.front = this.cite.front.slice(0,container_title_pos).concat(this.cite.front.slice(container_title_pos + 1));
            }
            collection_number_pos = this.cite.front.indexOf("collection-number");
            if (collection_number_pos > -1) {
                this.cite.front = this.cite.front.slice(0,collection_number_pos).concat(this.cite.front.slice(collection_number_pos + 1));
            }
        }
        if (!this.in_series && !this.force_collapse) {
            this.ComposeSet(true);
        }
        if (this.sets.value().length === 0) {
            has_date = false;
            for (pos = 0, len = this.cite.back.length; pos < len; pos += 1) {
                x = this.cite.back[pos];
                if (x === "original-date" && this.cite["original-date"] && this.cite["original-date"].value) {
                    has_date = true;
                    break;
                }
            }
            if (!has_date) {
                this.cite.back_forceme.push("original-date");
            }
        } else {
            var idx = this.cite.front.indexOf("original-date");
            if (idx === -1 || this.master_was_neutral_cite) {
                this.cite.back_forceme = this.sets.value().slice(-1)[0].back_forceme;
            }
            if (idx > -1) {
                var prev = this.sets.value()[this.sets.value().length - 1];
                if (!prev["original-date"]) {
                    this.cite.front = this.cite.front.slice(0, idx).concat(this.cite.front.slice(idx + 1));
                }
            }
            if (this.master_was_neutral_cite && this.cite.mid.indexOf("names:mid") > -1) {
                this.cite.front.push("names:mid");
            }
        }
        this.sets.value().push(this.cite);
    }
};
CSL.Parallel.prototype.ComposeSet = function (next_output_in_progress) {
    var cite, pos, master, len;
    if (this.use_parallels) {
        var lengthCheck = this.sets.value().length;
        if (this.sets.value().length === 1) {
            if (!this.in_series) {
                this.sets.value().pop();
                this.delim_counter += 1;
            }
        } else {
            len = this.sets.value().length;
            for (pos = 0; pos < len; pos += 1) {
                cite = this.sets.value()[pos];
                if (pos === 0) {
                    this.delim_counter += 1;
                } else {
                    if (!cite.Item.title && cite.use_journal_info) {
                        this.delim_pointers.push(false);
                    } else {
                        this.delim_pointers.push(this.delim_counter);
                    }
                    this.delim_counter += 1;
                }
                if (CSL.POSITION_FIRST === cite.position) {
                    if (pos === 0) {
                        this.state.registry.registry[cite.itemId].master = true;
                        this.state.registry.registry[cite.itemId].siblings = [];
                    } else {
                        if (cite.prevItemID) {
                            if (!this.state.registry.registry[cite.prevItemID].parallel) {
                                this.state.registry.registry[cite.itemId].parallel = cite.prevItemID;
                            } else {
                                this.state.registry.registry[cite.itemId].parallel = this.state.registry.registry[cite.prevItemID].parallel;
                            }
                            this.state.registry.registry[cite.itemId].siblings = this.state.registry.registry[cite.prevItemID].siblings;
                            if (!this.state.registry.registry[cite.itemId].siblings) {
                                this.state.registry.registry[cite.itemId].siblings = [];
                                CSL.debug("WARNING: adding missing siblings array to registry object");
                            }
                            this.state.registry.registry[cite.itemId].siblings.push(cite.itemId);
                        }
                    }
                }
            }
            this.sets.push([]);
        }
        if (lengthCheck < 2) {
            this.purgeGroupsIfParallel(false);
        } else {
            this.purgeGroupsIfParallel(true);
        }
        this.in_series = true;
    }
};
CSL.Parallel.prototype.PruneOutputQueue = function () {
    var len, pos, series, ppos, llen, cite;
    if (this.use_parallels) {
        len = this.sets.mystack.length;
        for (pos = 0; pos < len; pos += 1) {
            series = this.sets.mystack[pos];
            if (series.length > 1) {
                llen = series.length;
                for (ppos = 0; ppos < llen; ppos += 1) {
                    cite = series[ppos];
                    if (ppos === 0) {
                        this.purgeVariableBlobs(cite, cite.back);
                    } else if (ppos === (series.length - 1)) {
                        this.purgeVariableBlobs(cite, cite.front.concat(cite.back_forceme));
                    } else {
                        this.purgeVariableBlobs(cite, cite.front.concat(cite.back));
                    }
                }
            }
        }
    }
};
CSL.Parallel.prototype.purgeVariableBlobs = function (cite, varnames) {
    var len, pos, varname, b, llen, ppos, out;
    if (this.use_parallels) {
        out = this.state.output.current.value();
        if ("undefined" === typeof out.length) {
            out = out.blobs;
        }
        for (pos = 0, len = this.delim_pointers.length; pos < len; pos += 1) {
            ppos = this.delim_pointers[pos];
            if (ppos !== false) {
                out[ppos].parallel_delimiter = ", ";
            }
        }
        len = varnames.length - 1;
        for (pos = len; pos > -1; pos += -1) {
            varname = varnames[pos];
            if (cite[varname]) {
                llen = cite[varname].blobs.length - 1;
                for (ppos = llen; ppos > -1; ppos += -1) {
                    b = cite[varname].blobs[ppos];
                    b[0].blobs = b[0].blobs.slice(0, b[1]).concat(b[0].blobs.slice((b[1] + 1)));
                    this.state.tmp.has_purged_parallel = true;
                    if (b[0] && b[0].strings && "string" == typeof b[0].strings.oops
                        && b[0].parent && b[0].parent) {
                        b[0].parent.parent.strings.delimiter = b[0].strings.oops;
                    }
                }
            }
        }
    }
};
CSL.Parallel.prototype.purgeGroupsIfParallel = function (original_condition) {
    for (var i = this.parallel_conditional_blobs_list.length - 1; i > -1; i += -1) {
        var obj = this.parallel_conditional_blobs_list[i];
        var purgeme = true;
        for (var j = 0, jlen = obj.conditions.length; j < jlen; j += 1) {
            if (!(!obj.conditions[j] === !!original_condition
                || ("master" === obj.conditions[j]
                    && !this.state.registry.registry[obj.id].master)
                || ("servant" === obj.conditions[j]
                    && !this.state.registry.registry[obj.id].parallel))) {
                var purgeme = false;
                break;
            }
        }
        if (purgeme) {
            var buffer = [];
            while (obj.blobs.length > obj.pos) {
                buffer.push(obj.blobs.pop());
            }
            if (buffer.length) {
                buffer.pop();
            }
            while (buffer.length) {
                obj.blobs.push(buffer.pop());
            }
        }
        this.parallel_conditional_blobs_list.pop();
    }
}
CSL.Token = function (name, tokentype) {
    this.name = name;
    this.strings = {};
    this.strings.delimiter = undefined;
    this.strings.prefix = "";
    this.strings.suffix = "";
    this.decorations = [];
    this.variables = [];
    this.execs = [];
    this.tokentype = tokentype;
    this.evaluator = false;
    this.tests = [];
    this.succeed = false;
    this.fail = false;
    this.next = false;
};
CSL.Util.cloneToken = function (token) {
    var newtok, key, pos, len;
    if ("string" === typeof token) {
        return token;
    }
    newtok = new CSL.Token(token.name, token.tokentype);
    for (key in token.strings) {
        if (token.strings.hasOwnProperty(key)) {
            newtok.strings[key] = token.strings[key];
        }
    }
    if (token.decorations) {
        newtok.decorations = [];
        for (pos = 0, len = token.decorations.length; pos < len; pos += 1) {
            newtok.decorations.push(token.decorations[pos].slice());
        }
    }
    if (token.variables) {
        newtok.variables = token.variables.slice();
    }
    if (token.execs) {
        newtok.execs = token.execs.slice();
        newtok.tests = token.tests.slice();
    }
    return newtok;
};
CSL.AmbigConfig = function () {
    this.maxvals = [];
    this.minval = 1;
    this.names = [];
    this.givens = [];
    this.year_suffix = false;
    this.disambiguate = 0;
};
CSL.Blob = function (str, token, levelname) {
    var len, pos, key;
    this.levelname = levelname;
    if (token) {
        this.strings = {"prefix":"","suffix":""};
        for (key in token.strings) {
            if (token.strings.hasOwnProperty(key)) {
                this.strings[key] = token.strings[key];
            }
        }
        this.decorations = [];
        if (token.decorations === undefined) {
            len = 0;
        } else {
            len = token.decorations.length;
        }
        for (pos = 0; pos < len; pos += 1) {
            this.decorations.push(token.decorations[pos].slice());
        }
    } else {
        this.strings = {};
        this.strings.prefix = "";
        this.strings.suffix = "";
        this.strings.delimiter = "";
        this.decorations = [];
    }
    if ("string" === typeof str) {
        this.blobs = str;
    } else if (str) {
        this.blobs = [str];
    } else {
        this.blobs = [];
    }
    this.alldecor = [this.decorations];
};
CSL.Blob.prototype.push = function (blob) {
    if ("string" === typeof this.blobs) {
        throw "Attempt to push blob onto string object";
    } else {
        blob.alldecor = blob.alldecor.concat(this.alldecor);
        this.blobs.push(blob);
    }
};
CSL.NumericBlob = function (num, mother_token, id) {
    this.id = id;
    this.alldecor = [];
    this.num = num;
    this.blobs = num.toString();
    this.status = CSL.START;
    this.strings = {};
    if (mother_token) {
        this.gender = mother_token.gender;
        this.decorations = mother_token.decorations;
        this.strings.prefix = mother_token.strings.prefix;
        this.strings.suffix = mother_token.strings.suffix;
        this.strings["text-case"] = mother_token.strings["text-case"];
        this.successor_prefix = mother_token.successor_prefix;
        this.range_prefix = mother_token.range_prefix;
        this.splice_prefix = mother_token.splice_prefix;
        this.formatter = mother_token.formatter;
        if (!this.formatter) {
            this.formatter =  new CSL.Output.DefaultFormatter();
        }
        if (this.formatter) {
            this.type = this.formatter.format(1);
        }
    } else {
        this.decorations = [];
        this.strings.prefix = "";
        this.strings.suffix = "";
        this.successor_prefix = "";
        this.range_prefix = "";
        this.splice_prefix = "";
        this.formatter = new CSL.Output.DefaultFormatter();
    }
};
CSL.NumericBlob.prototype.setFormatter = function (formatter) {
    this.formatter = formatter;
    this.type = this.formatter.format(1);
};
CSL.Output.DefaultFormatter = function () {};
CSL.Output.DefaultFormatter.prototype.format = function (num) {
    return num.toString();
};
CSL.NumericBlob.prototype.checkNext = function (next) {
    if (next && this.id == next.id) {
        this.status = CSL.START;
    } else if (! next || !next.num || this.type !== next.type || next.num !== (this.num + 1)) {
        if (this.status === CSL.SUCCESSOR_OF_SUCCESSOR) {
            this.status = CSL.END;
        }
        if ("object" === typeof next) {
            next.status = CSL.SEEN;
        }
    } else { // next number is in the sequence
        if (this.status === CSL.START || this.status === CSL.SEEN) {
            next.status = CSL.SUCCESSOR;
        } else if (this.status === CSL.SUCCESSOR || this.status === CSL.SUCCESSOR_OF_SUCCESSOR) {
            if (this.range_prefix) {
                next.status = CSL.SUCCESSOR_OF_SUCCESSOR;
                this.status = CSL.SUPPRESS;
            } else {
                next.status = CSL.SUCCESSOR;
            }
        }
    }
};
CSL.NumericBlob.prototype.checkLast = function (last) {
    if (this.status === CSL.SEEN 
    || (last.num !== (this.num - 1) && this.status === CSL.SUCCESSOR)) {
        this.status = CSL.SUCCESSOR;
        return true;
    }
    return false;
};
CSL.Util.fixDateNode = function (parent, pos, node) {
    var form, variable, datexml, subnode, partname, attr, val, prefix, suffix, children, key, subchildren, kkey, display;
    form = this.sys.xml.getAttributeValue(node, "form");
    var lingo = this.sys.xml.getAttributeValue(node, "lingo");
    if (!this.state.getDate(form)) {
        return parent;
    }
    var dateparts = this.sys.xml.getAttributeValue(node, "date-parts");
    variable = this.sys.xml.getAttributeValue(node, "variable");
    prefix = this.sys.xml.getAttributeValue(node, "prefix");
    suffix = this.sys.xml.getAttributeValue(node, "suffix");
    display = this.sys.xml.getAttributeValue(node, "display");
    cslid = this.sys.xml.getAttributeValue(node, "cslid");
    datexml = this.sys.xml.nodeCopy(this.state.getDate(form));
    this.sys.xml.setAttribute(datexml, 'lingo', this.state.opt.lang);
    this.sys.xml.setAttribute(datexml, 'form', form);
    this.sys.xml.setAttribute(datexml, 'date-parts', dateparts);
    this.sys.xml.setAttribute(datexml, "cslid", cslid);
    this.sys.xml.setAttribute(datexml, 'variable', variable);
    if (prefix) {
        this.sys.xml.setAttribute(datexml, "prefix", prefix);
    }
    if (suffix) {
        this.sys.xml.setAttribute(datexml, "suffix", suffix);
    }
    if (display) {
        this.sys.xml.setAttribute(datexml, "display", display);
    }
    children = this.sys.xml.children(node);
    for (key in children) {
            subnode = children[key];
            if ("date-part" === this.sys.xml.nodename(subnode)) {
                partname = this.sys.xml.getAttributeValue(subnode, "name");
                subchildren = this.sys.xml.attributes(subnode);
                for (attr in subchildren) {
                    if (subchildren.hasOwnProperty(attr)) {
                        if ("@name" === attr) {
                            continue;
                        }
                        if (lingo && lingo !== this.state.opt.lang) {
                            if (["@suffix", "@prefix", "@form"].indexOf(attr) > -1) {
                                continue;
                            }
                        }
                        val = subchildren[attr];
                        this.sys.xml.setAttributeOnNodeIdentifiedByNameAttribute(datexml, "date-part", partname, attr, val);
                    }
                }
            }
    }
    if ("year" === this.sys.xml.getAttributeValue(node, "date-parts")) {
        this.sys.xml.deleteNodeByNameAttribute(datexml, 'month');
        this.sys.xml.deleteNodeByNameAttribute(datexml, 'day');
    } else if ("year-month" === this.sys.xml.getAttributeValue(node, "date-parts")) {
        this.sys.xml.deleteNodeByNameAttribute(datexml, 'day');
    }
    return this.sys.xml.insertChildNodeAfter(parent, node, pos, datexml);
};
CSL.Util.Names = {};
CSL.Util.Names.compareNamesets = CSL.NameOutput.prototype._compareNamesets;
CSL.Util.Names.unInitialize = function (state, name) {
    var i, ilen, namelist, punctlist, ret;
    if (!name) {
        return "";
    }
    namelist = name.split(/(?:\-|\s+)/);
    punctlist = name.match(/(\-|\s+)/g);
    ret = "";
    for (i = 0, ilen = namelist.length; i < ilen; i += 1) {
        if (CSL.ALL_ROMANESQUE_REGEXP.exec(namelist[i].slice(0,-1)) 
            && namelist[i] 
            && namelist[i] !== namelist[i].toUpperCase()) {
            namelist[i] = namelist[i].slice(0, 1) + namelist[i].slice(1, 2).toLowerCase() + namelist[i].slice(2);
        }
        ret += namelist[i];
        if (i < ilen - 1) {
            ret += punctlist[i];
        }
    }
    return ret;
};
CSL.Util.Names.initializeWith = function (state, name, terminator, normalizeOnly) {
    var i, ilen, j, jlen, n, m, mm, str, lst, ret;
    if (!name) {
        return "";
    }
    if (["Lord", "Lady"].indexOf(name) > -1) {
        return name;
    }
    if (!terminator) {
        terminator = "";
    }
    var namelist = name;
    if (state.opt["initialize-with-hyphen"] === false) {
        namelist = namelist.replace(/\-/g, " ");
    }
    namelist = namelist.replace(/\s*\-\s*/g, "-").replace(/\s+/g, " ");
    namelist = namelist.replace(/-([a-z])/g, "\u2013$1")
    mm = namelist.match(/[\-\s]+/g);
    lst = namelist.split(/[\-\s]+/);
    if (lst.length === 0) {
        namelist = mm;
    } else {
        namelist = [lst[0]];
        for (i = 1, ilen = lst.length; i < ilen; i += 1) {
            namelist.push(mm[i - 1]);
            namelist.push(lst[i]);
        }
    }
    lst = namelist;
    for (i = lst.length -1; i > -1; i += -1) {
        if (lst[i] && lst[i].slice(0, -1).indexOf(".") > -1) {
            var lstend = lst.slice(i + 1);
            var lstmid = lst[i].slice(0, -1).split(".");
            lst = lst.slice(0, i);
            for (j = 0, jlen = lstmid.length; j < jlen; j += 1) {
                lst.push(lstmid[j] + ".");
                if (j < lstmid.length - 1) {
                    lst.push(" ");
                }
            }
            lst = lst.concat(lstend);
        }
    }
    if (normalizeOnly) {
        ret = CSL.Util.Names.doNormalize(state, lst, terminator);
    } else {
        ret = CSL.Util.Names.doInitialize(state, lst, terminator);
    }
    ret = ret.replace(/\u2013([a-z])/g, "-$1")
    return ret;
};
CSL.Util.Names.doNormalize = function (state, namelist, terminator, mode) {
    var i, ilen;
    var isAbbrev = [];
    for (i = 0, ilen = namelist.length; i < ilen; i += 1) {
        if (namelist[i].length > 1 && namelist[i].slice(-1) === ".") {
            namelist[i] = namelist[i].slice(0, -1);
            isAbbrev.push(true);
        } else if (namelist[i].length === 1 && namelist[i].toUpperCase() === namelist[i]) {
            isAbbrev.push(true);
        } else {
            isAbbrev.push(false);
        }
    }
    var ret = [];
    for (i = 0, ilen = namelist.length; i < ilen; i += 2) {
        if (isAbbrev[i]) {
            if (i < namelist.length - 2) {
                namelist[i + 1] = "";
                if ((!terminator || terminator.slice(-1) && terminator.slice(-1) !== " ")
                    && namelist[i].length && namelist[i].match(CSL.ALL_ROMANESQUE_REGEXP)
                    && (namelist[i].length > 1 || namelist[i + 2].length > 1)) {
                    namelist[i + 1] = " ";
                }
                namelist[i] = namelist[i] + terminator;
            }
            if (i === namelist.length - 1) {
                namelist[i] = namelist[i] + terminator;
            }
        }
    }
    return namelist.join("").replace(/\s+$/,"");
};
CSL.Util.Names.doInitialize = function (state, namelist, terminator, mode) {
    var i, ilen, m, j, jlen, lst, n;
    for (i = 0, ilen = namelist.length; i < ilen; i += 2) {
        n = namelist[i];
        if (!n) {
            continue;
        }
        m = n.match(CSL.NAME_INITIAL_REGEXP);
        if (!m && (!n.match(CSL.STARTSWITH_ROMANESQUE_REGEXP) && n.length > 1 && terminator.match("%s"))) {
            m = n.match(/(.)(.*)/);
        }
        if (m && m[1] === m[1].toUpperCase()) {
            var extra = "";
            if (m[2]) {
                var s = "";
                lst = m[2].split("");
                for (j = 0, jlen = lst.length; j < jlen; j += 1) {
                    var c = lst[j];
                    if (c === c.toUpperCase()) {
                        s += c;
                    } else {
                        break;
                    }
                }
                if (s.length < m[2].length) {
                    extra = s.toLocaleLowerCase();
                }
            }
            namelist[i] = m[1].toLocaleUpperCase() + extra;
            if (i < (ilen - 1)) {
                if (terminator.match("%s")) {
                    namelist[i] = terminator.replace("%s", namelist[i]);
                } else {
                    if (namelist[i + 1].indexOf("-") > -1) {
                        namelist[i + 1] = terminator + namelist[i + 1];
                    } else {
                        namelist[i + 1] = terminator;
                    }
                }
            } else {
                if (terminator.match("%s")) {
                    namelist[i] = terminator.replace("%s", namelist[i]);
                } else {
                    namelist.push(terminator);
                }
            }
        } else if (n.match(CSL.ROMANESQUE_REGEXP)) {
            namelist[i] = " " + n;
        }
    }
    var ret = CSL.Util.Names.stripRight(namelist.join(""));
    ret = ret.replace(/\s*\-\s*/g, "-").replace(/\s+/g, " ");
    return ret;
};
CSL.Util.Names.stripRight = function (str) {
    var end, pos, len;
    end = 0;
    len = str.length - 1;
    for (pos = len; pos > -1; pos += -1) {
        if (str[pos] !== " ") {
            end = pos + 1;
            break;
        }
    }
    return str.slice(0, end);
};
CSL.Util.Names.getRawName = function (name) {
    var ret = [];
    if (name.given) {
        ret.push(name.given);
    }
    if (name.family) {
        ret.push(name.family);
    }
    return ret.join(" ");
};
CSL.Util.Dates = {};
CSL.Util.Dates.year = {};
CSL.Util.Dates.year["long"] = function (state, num) {
    if (!num) {
        if ("boolean" === typeof num) {
            num = "";
        } else {
            num = 0;
        }
    }
    return num.toString();
};
CSL.Util.Dates.year["short"] = function (state, num) {
    num = num.toString();
    if (num && num.length === 4) {
        return num.substr(2);
    }
};
CSL.Util.Dates.year.numeric = function (state, num) {
    var m, pre;
    num = "" + num;
    m = num.match(/([0-9]*)$/);
    if (m) {
        pre = num.slice(0, m[1].length * -1);
        num = m[1];
    } else {
        pre = num;
        num = "";
    }
    while (num.length < 4) {
        num = "0" + num;
    }
    return (pre + num);
};
CSL.Util.Dates.month = {};
CSL.Util.Dates.month.numeric = function (state, num) {
    if (num) {
        num = parseInt(num, 10);
        if (num > 12) {
            num = "";
        }
    }
    var ret = "" + num;
    return ret;
};
CSL.Util.Dates.month["numeric-leading-zeros"] = function (state, num) {
    if (!num) {
        num = 0;
    }
    num = parseInt(num, 10);
    if (num > 12) {
        num = 0;
    }
    num = "" + num;
    while (num.length < 2) {
        num = "0" + num;
    }
    return num.toString();
};
CSL.Util.Dates.month["long"] = function (state, num) {
    var stub = "month-";
    num = parseInt(num, 10);
    if (num > 12) {
        stub = "season-";
        if (num > 16) {
            num = num - 16;
        } else {
            num = num - 12;
        }
    }
    num = "" + num;
    while (num.length < 2) {
        num = "0" + num;
    }
    num = stub + num;
    return state.getTerm(num, "long", 0);
};
CSL.Util.Dates.month["short"] = function (state, num) {
    var stub = "month-";
    num = parseInt(num, 10);
    if (num > 12) {
        stub = "season-";
        if (num > 16) {
            num = num - 16;
        } else {
            num = num - 12;
        }
    }
    num = "" + num;
    while (num.length < 2) {
        num = "0" + num;
    }
    num = "month-" + num;
    return state.getTerm(num, "short", 0);
};
CSL.Util.Dates.day = {};
CSL.Util.Dates.day.numeric = function (state, num) {
    return num.toString();
};
CSL.Util.Dates.day["long"] = CSL.Util.Dates.day.numeric;
CSL.Util.Dates.day["numeric-leading-zeros"] = function (state, num) {
    if (!num) {
        num = 0;
    }
    num = num.toString();
    while (num.length < 2) {
        num = "0" + num;
    }
    return num.toString();
};
CSL.Util.Dates.day.ordinal = function (state, num, gender) {
    return state.fun.ordinalizer.format(num, gender);
};
CSL.Util.Sort = {};
CSL.Util.Sort.strip_prepositions = function (str) {
    var m;
    if ("string" === typeof str) {
        m = str.toLocaleLowerCase();
        m = str.match(/^((a|an|the)\s+)/);
    }
    if (m) {
        str = str.substr(m[1].length);
    }
    return str;
};
CSL.Util.substituteStart = function (state, target) {
    var element_trace, display, bib_first, func, choose_start, if_start, nodetypes;
    func = function (state, Item) {
        for (var i = 0, ilen = this.decorations.length; i < ilen; i += 1) {
            if ("@strip-periods" === this.decorations[i][0] && "true" === this.decorations[i][1]) {
                state.tmp.strip_periods += 1;
                break;
            }
        }
    };
    this.execs.push(func);
    if (this.decorations && state.opt.development_extensions.csl_reverse_lookup_support) {
        this.decorations.reverse();
        this.decorations.push(["@showid","true", this.cslid]);
        this.decorations.reverse();
    }
    nodetypes = ["number", "date", "names"];
    if (("text" === this.name && !this.postponed_macro) || nodetypes.indexOf(this.name) > -1) {
        element_trace = function (state, Item, item) {
            if (state.tmp.element_trace.value() === "author" || "names" === this.name) {
                if (item && item["author-only"]) {
                    state.tmp.element_trace.push("do-not-suppress-me");
                } else if (item && item["suppress-author"]) {
                }
            } else {
                if (item && item["author-only"]) {
                    state.tmp.element_trace.push("suppress-me");
                } else if (item && item["suppress-author"]) {
                    state.tmp.element_trace.push("do-not-suppress-me");
                }
            }
        };
        this.execs.push(element_trace);
    }
    display = this.strings.cls;
    this.strings.cls = false;
    if (state.build.render_nesting_level === 0) {
        if (state.build.area === "bibliography" && state.bibliography.opt["second-field-align"]) {
            bib_first = new CSL.Token("group", CSL.START);
            bib_first.decorations = [["@display", "left-margin"]];
            func = function (state, Item) {
                if (!state.tmp.render_seen) {
                    bib_first.strings.first_blob = Item.id;
                    state.output.startTag("bib_first", bib_first);
                }
            };
            bib_first.execs.push(func);
            target.push(bib_first);
        } else if (CSL.DISPLAY_CLASSES.indexOf(display) > -1) {
            bib_first = new CSL.Token("group", CSL.START);
            bib_first.decorations = [["@display", display]];
            func = function (state, Item) {
                bib_first.strings.first_blob = Item.id;
                state.output.startTag("bib_first", bib_first);
            };
            bib_first.execs.push(func);
            target.push(bib_first);
        }
        state.build.cls = display;
    }
    state.build.render_nesting_level += 1;
    if (state.build.substitute_level.value() === 1) {
        choose_start = new CSL.Token("choose", CSL.START);
        CSL.Node.choose.build.call(choose_start, state, target);
        if_start = new CSL.Token("if", CSL.START);
        func = function (state, Item) {
            if (state.tmp.can_substitute.value()) {
                return true;
            }
            return false;
        };
        if_start.tests.push(func);
        if_start.evaluator = state.fun.match.any;
        target.push(if_start);
    }
};
CSL.Util.substituteEnd = function (state, target) {
    var func, bib_first_end, bib_other, if_end, choose_end, toplevel, hasval, author_substitute, str;
    func = function (state, Item) {
        for (var i = 0, ilen = this.decorations.length; i < ilen; i += 1) {
            if ("@strip-periods" === this.decorations[i][0] && "true" === this.decorations[i][1]) {
                state.tmp.strip_periods += -1;
                break;
            }
        }
    };
    this.execs.push(func);
    state.build.render_nesting_level += -1;
    if (state.build.render_nesting_level === 0) {
        if (state.build.cls) {
            func = function (state, Item) {
                state.output.endTag("bib_first");
            };
            this.execs.push(func);
            state.build.cls = false;
        } else if (state.build.area === "bibliography" && state.bibliography.opt["second-field-align"]) {
            bib_first_end = new CSL.Token("group", CSL.END);
            func = function (state, Item) {
                if (!state.tmp.render_seen) {
                    state.output.endTag(); // closes bib_first
                }
            };
            bib_first_end.execs.push(func);
            target.push(bib_first_end);
            bib_other = new CSL.Token("group", CSL.START);
            bib_other.decorations = [["@display", "right-inline"]];
            func = function (state, Item) {
                if (!state.tmp.render_seen) {
                    state.tmp.render_seen = true;
                    state.output.startTag("bib_other", bib_other);
                }
            };
            bib_other.execs.push(func);
            target.push(bib_other);
        }
    }
    if (state.build.substitute_level.value() === 1) {
        if_end = new CSL.Token("if", CSL.END);
        target.push(if_end);
        choose_end = new CSL.Token("choose", CSL.END);
        CSL.Node.choose.build.call(choose_end, state, target);
    }
    toplevel = "names" === this.name && state.build.substitute_level.value() === 0;
    hasval = "string" === typeof state[state.build.area].opt["subsequent-author-substitute"];
    var subrule = state[state.build.area].opt["subsequent-author-substitute-rule"];
    if (toplevel && hasval) {
        author_substitute = new CSL.Token("text", CSL.SINGLETON);
        func = function (state, Item) {
            var i, ilen;
            var printing = !state.tmp.suppress_decorations;
            if (printing && state.tmp.area === "bibliography") {
                if (!state.tmp.rendered_name) {
                    if ("partial-each" === subrule || "partial-first" === subrule) {
                        state.tmp.rendered_name = [];
                        var dosub = true;
                        for (i = 0, ilen = state.tmp.name_node.children.length; i < ilen; i += 1) {
                            var name = state.output.string(state, state.tmp.name_node.children[i].blobs, false);
                            if (dosub
                                && state.tmp.last_rendered_name && state.tmp.last_rendered_name.length > i - 1
                                && state.tmp.last_rendered_name[i] === name) {
                                str = new CSL.Blob(state[state.tmp.area].opt["subsequent-author-substitute"]);
                                state.tmp.name_node.children[i].blobs = [str];
                                if ("partial-first" === subrule) {
                                    dosub = false;
                                }
                            } else {
                                dosub = false;
                            }
                            state.tmp.rendered_name.push(name);
                        }
                        state.tmp.last_rendered_name = state.tmp.rendered_name;
                    } else if ("complete-each" === subrule) {
                        state.tmp.rendered_name = state.output.string(state, state.tmp.name_node.top.blobs, false);
                        if (state.tmp.rendered_name) {
                            if (state.tmp.rendered_name === state.tmp.last_rendered_name) {
                                for (i = 0, ilen = state.tmp.name_node.children.length; i < ilen; i += 1) {
                                    str = new CSL.Blob(state[state.tmp.area].opt["subsequent-author-substitute"]);
                                    state.tmp.name_node.children[i].blobs = [str];
                                }
                            }
                            state.tmp.last_rendered_name = state.tmp.rendered_name;
                        }
                    } else {
                        state.tmp.rendered_name = state.output.string(state, state.tmp.name_node.top.blobs, false);
                        if (state.tmp.rendered_name) {
                            if (state.tmp.rendered_name === state.tmp.last_rendered_name) {
                                str = new CSL.Blob(state[state.tmp.area].opt["subsequent-author-substitute"]);
                                state.tmp.name_node.top.blobs = [str];
                            }
                            state.tmp.last_rendered_name = state.tmp.rendered_name;
                        }
                    }
                }
            }
        };
        author_substitute.execs.push(func);
        target.push(author_substitute);
    }
    if (("text" === this.name && !this.postponed_macro) || ["number", "date", "names"].indexOf(this.name) > -1) {
        func = function (state, Item) {
            state.tmp.element_trace.pop();
        };
        this.execs.push(func);
    }
};
CSL.Util.padding = function (num) {
    var m = num.match(/\s*(-{0,1}[0-9]+)/);
    if (m) {
        num = parseInt(m[1], 10);
        if (num < 0) {
            num = 99999999999999999999 + num;
        }
        num = "" + num;
        while (num.length < 20) {
            num = "0" + num;
        }
    }
    return num;
};
CSL.Util.LongOrdinalizer = function () {};
CSL.Util.LongOrdinalizer.prototype.init = function (state) {
    this.state = state;
};
CSL.Util.LongOrdinalizer.prototype.format = function (num, gender) {
    if (num < 10) {
        num = "0" + num;
    }
    var ret = CSL.Engine.getField(
        CSL.LOOSE, 
        this.state.locale[this.state.opt.lang].terms,
        "long-ordinal-" + num,
        "long", 
        0, 
        gender
    );
    if (!ret) {
        ret = this.state.fun.ordinalizer.format(num, gender);
    }
    this.state.tmp.cite_renders_content = true;
    return ret;
};
CSL.Util.Ordinalizer = function () {};
CSL.Util.Ordinalizer.prototype.init = function (state) {
    this.suffixes = {};
    for (var i = 0, ilen = 3; i < ilen; i += 1) {
        var gender = [undefined, "masculine", "feminine"][i];
        this.suffixes[gender] = [];
        for (var j = 1; j < 5; j += 1) {
            var ordinal = state.getTerm("ordinal-0" + j, "long", false, gender);
            if ("undefined" === typeof ordinal) {
                delete this.suffixes[gender];
                break;
            }
            this.suffixes[gender].push(ordinal);            
        }
    }
};
CSL.Util.Ordinalizer.prototype.format = function (num, gender) {
    var str;
    num = parseInt(num, 10);
    str = num.toString();
    if ((num / 10) % 10 === 1 || (num > 10 && num < 20)) {
        str += this.suffixes[gender][3];
    } else if (num % 10 === 1 && num % 100 !== 11) {
        str += this.suffixes[gender][0];
    } else if (num % 10 === 2 && num % 100 !== 12) {
        str += this.suffixes[gender][1];
    } else if (num % 10 === 3 && num % 100 !== 13) {
        str += this.suffixes[gender][2];
    } else {
        str += this.suffixes[gender][3];
    }
    return str;
};
CSL.Util.Romanizer = function () {};
CSL.Util.Romanizer.prototype.format = function (num) {
    var ret, pos, n, numstr, len;
    ret = "";
    if (num < 6000) {
        numstr = num.toString().split("");
        numstr.reverse();
        pos = 0;
        n = 0;
        len = numstr.length;
        for (pos = 0; pos < len; pos += 1) {
            n = parseInt(numstr[pos], 10);
            ret = CSL.ROMAN_NUMERALS[pos][n] + ret;
        }
    }
    return ret;
};
CSL.Util.Suffixator = function (slist) {
    if (!slist) {
        slist = CSL.SUFFIX_CHARS;
    }
    this.slist = slist.split(",");
};
CSL.Util.Suffixator.prototype.format = function (N) {
    var X;
    N += 1;
    var key = "";
    do {
        X = ((N % 26) === 0) ? 26 : (N % 26);
        key = this.slist[X-1] + key;
        N = (N - X) / 26;
    } while ( N !== 0 );
    return key;
};
CSL.Engine.prototype.processNumber = function (node, ItemObject, variable, type) {
    var num, m, i, ilen, j, jlen;
    var debug = false;
    if (this.tmp.shadow_numbers[variable]) {
        if (this.tmp.shadow_numbers[variable].numeric) {
            for (var i = 0, ilen = this.tmp.shadow_numbers[variable].values.length; i < ilen; i += 2) {
                this.tmp.shadow_numbers[variable].values[i][2] = node;
            }
        }
        return;
    }
    this.tmp.shadow_numbers[variable] = {};
    this.tmp.shadow_numbers[variable].values = [];
    this.tmp.shadow_numbers[variable].plural = 0;
    this.tmp.shadow_numbers[variable].numeric = false;
    this.tmp.shadow_numbers[variable].label = false;
    if (!ItemObject) {
        return;
    }
    num = ItemObject[variable];
    if ("undefined" !== typeof num) {
        if ("number" === typeof num) {
            num = "" + num;
        }
        this.tmp.shadow_numbers[variable].label = variable;
        if (num.slice(0, 1) === '"' && num.slice(-1) === '"') {
            num = num.slice(1, -1);
        }
        if (num.indexOf("&") > -1 || num.indexOf("--") > -1) {
            this.tmp.shadow_numbers[variable].plural = 1;
        }
        if ("locator" === variable
            && ["bill","gazette","legislation","treaty"].indexOf(type) > -1) {
            num = num.split(CSL.STATUTE_SUBDIV_PLAIN_REGEX)[0];
        }
        var rangeType = "page";
        if (["bill","gazette","legislation","legal_case","treaty"].indexOf(type) > -1
            && variable === "collection-number") {
            rangeType = "year";
        }
        if (["page", "page-first"].indexOf(variable) > -1) {
            var m = num.split(" ")[0].match(CSL.STATUTE_SUBDIV_GROUPED_REGEX);
            if (m){
                this.tmp.shadow_numbers[variable].label = CSL.STATUTE_SUBDIV_STRINGS[m[0]];
                var mm = num.match(/[^ ]+\s+(.*)/);
                if (mm) {
                    num = mm[1];
                }
            }
        }
        var lst = num.split(/(?:,\s+|\s*\\*[\-\u2013]+\s*|\s*&\s*)/);
        var m = num.match(/(,\s+|\s*\\*[\-\u2013]+\s*|\s*&\s*)/g);
        var elements = [];
        for (var i = 0, ilen = lst.length - 1; i < ilen; i += 1) {
            elements.push(lst[i]);
            elements.push(m[i]);
        }
        elements.push(lst[lst.length - 1]);
        var count = 0;
        var numeric = true;
        for (var i = 0, ilen = elements.length; i < ilen; i += 1) {
            var odd = ((i%2) === 0);
            if (odd) {
                if (elements[i]) {
                    if (elements[i].match(/[0-9]/)) {
                        if (elements[i - 1] && elements[i - 1].match(/^\s*\\*[\-\u2013]+\s*$/)) {
                            var middle = this.tmp.shadow_numbers[variable].values.slice(-1);
                            if (middle[0][1].indexOf("\\") == -1) {
                                if (elements[i - 2] && ("" + elements[i - 2]).match(/[a-zA-Z]*[0-9]+$/)
                                    && elements[i].match(/^[a-zA-Z]*[0-9]+/)) {
                                    var start = this.tmp.shadow_numbers[variable].values.slice(-2);
                                    middle[0][1] = this.getTerm(rangeType + "-range-delimiter");
                                    if (this.opt[rangeType + "-range-format"] ) {
                                        var newstr = this.fun[rangeType + "_mangler"](start[0][1] +"-"+elements[i]);
                                        newstr = newstr.split(this.getTerm(rangeType + "-range-delimiter"));
                                        elements[i] = newstr[1];
                                    }
                                    count = count + 1;
                                }
                                if (middle[0][1].indexOf("--") > -1) {
                                    middle[0][1] = middle[0][1].replace(/--*/, "\u2013");
                                }
                            } else {
                                middle[0][1] = middle[0][1].replace(/\\/, "", "g");
                            }
                        } else {
                            count = count + 1;
                        }
                    }
                    var subelements = elements[i].split(/\s+/);
                    for (var j = 0, jlen = subelements.length; j < jlen; j += 1) {
                        if (!subelements[j].match(/[0-9]/)) {
                            numeric = false;
                        }
                    }
                    if (i === elements.length - 1) {
                        if ((elements.length > 1 || subelements.length > 1)) {
                            var matchterm = this.getTerm(variable, "long");
                            if (matchterm && !subelements[subelements.length - 1].match(/[0-9]/)) {
                                matchterm = matchterm.replace(".", "").toLowerCase().split(/\s+/)[0];
                                if (subelements[subelements.length - 1].slice(0, matchterm.length).toLowerCase() === matchterm) {
                                    elements[i] = subelements.slice(0, -1).join(" ");
                                    numeric = true;
                                }
                            }
                        }
                    }
                    if (elements[i].match(/^[1-9][0-9]*$/)) {
                        elements[i] = parseInt(elements[i], 10);
                        node.gender = this.opt["noun-genders"][variable];
                        this.tmp.shadow_numbers[variable].values.push(["NumericBlob", elements[i], node]);
                    } else {
                        var str = elements[i];
                        if (this.sys.getAbbreviation) {
                            var jurisdiction = this.transform.loadAbbreviation(ItemObject.jurisdiction, "number", elements[i]);
                            if (this.transform.abbrevs[jurisdiction].number[str]) {
                                str = this.transform.abbrevs[jurisdiction].number[str];
                            }
                        }
                        this.tmp.shadow_numbers[variable].values.push(["Blob", str, node]);
                    }
                }
            } else {
                if (elements[i]) {
                    this.tmp.shadow_numbers[variable].values.push(["Blob", elements[i], undefined]);
                }
            }
                    };
        if (num.indexOf(" ") === -1 && num.match(/[0-9]/)) {
            this.tmp.shadow_numbers[variable].numeric = true;
        } else {
             this.tmp.shadow_numbers[variable].numeric = numeric;
        }
        if (count > 1) {
            this.tmp.shadow_numbers[variable].plural = 1;
        }
        if (ItemObject.force_pluralism === 1) {
            this.tmp.shadow_numbers[variable].plural = 1;
        } else if (ItemObject.force_pluralism === 0) {
            this.tmp.shadow_numbers[variable].plural = 0;
        }
    }
};
CSL.Util.PageRangeMangler = {};
CSL.Util.PageRangeMangler.getFunction = function (state, rangeType) {
    var rangerex, pos, len, stringify, listify, expand, minimize, minimize_internal, chicago, lst, m, b, e, ret, begin, end, ret_func, ppos, llen;
    var range_delimiter = state.getTerm(rangeType + "-range-delimiter");
    rangerex = /([a-zA-Z]*)([0-9]+)\s*-\s*([a-zA-Z]*)([0-9]+)/;
    stringify = function (lst) {
        len = lst.length;
        for (pos = 1; pos < len; pos += 2) {
            if ("object" === typeof lst[pos]) {
                lst[pos] = lst[pos].join("");
            }
        }
        var ret = lst.join("");
        ret = ret.replace(/([^\\])\-/g, "$1"+state.getTerm(rangeType + "-range-delimiter"));
        return ret;
    };
    listify = function (str, hyphens) {
        var m, lst, ret;
        str = str.replace(/([^\\])\u2013/g, "$1-").replace(/\s+\u2013\s+/g, " - ");
        var rexm = new RegExp("([a-zA-Z]*[0-9]+" + hyphens + "[a-zA-Z]*[0-9]+)", "g");
        var rexlst = new RegExp("[a-zA-Z]*[0-9]+" + hyphens + "[a-zA-Z]*[0-9]+");
        m = str.match(rexm);
        lst = str.split(rexlst);
        if (lst.length === 0) {
            ret = m;
        } else {
            ret = [lst[0]];
            for (pos = 1, len = lst.length; pos < len; pos += 1) {
                ret.push(m[pos - 1].replace(/\s*\-\s*/, "-", "g"));
                ret.push(lst[pos]);
            }
        }
        return ret;
    };
    expand = function (str, hyphens) {
        str = "" + str;
        lst = listify(str, hyphens);
        len = lst.length;
        for (pos = 1; pos < len; pos += 2) {
            m = lst[pos].match(rangerex);
            if (m) {
                if (!m[3] || m[1] === m[3]) {
                    if (m[4].length < m[2].length) {
                        m[4] = m[2].slice(0, (m[2].length - m[4].length)) + m[4];
                    }
                    if (parseInt(m[2], 10) < parseInt(m[4], 10)) {
                        m[3] = range_delimiter + m[1];
                        lst[pos] = m.slice(1);
                    }
                }
            }
            if ("string" === typeof lst[pos]) {
                lst[pos] = lst[pos].replace("-", range_delimiter, "g");
            }
        }
        return lst;
    };
    minimize = function (lst, minchars, isyear) {
        len = lst.length;
        for (var i = 1, ilen = lst.length; i < ilen; i += 2) {
            lst[i][3] = minimize_internal(lst[i][1], lst[i][3], minchars, isyear);
            if (lst[i][2].slice(1) === lst[i][0]) {
                lst[i][2] = range_delimiter;
            }
        }
        return stringify(lst);
    };
    minimize_internal = function (begin, end, minchars, isyear) {
        if (!minchars) {
            minchars = 0;
        }
        b = ("" + begin).split("");
        e = ("" + end).split("");
        ret = e.slice();
        ret.reverse();
        if (b.length === e.length) {
            for (var i = 0, ilen = b.length; i < ilen; i += 1) {
                if (b[i] === e[i] && ret.length > minchars) {
                    ret.pop();
                } else {
                    if (minchars && isyear && ret.length === 3) {
                        var front = b.slice(0, i);
                        front.reverse();
                        ret = ret.concat(front);
                    }
                    break;
                }
            }
        }
        ret.reverse();
        return ret.join("");
    };
    chicago = function (lst) {
        len = lst.length;
        for (pos = 1; pos < len; pos += 2) {
            if ("object" === typeof lst[pos]) {
                m = lst[pos];
                begin = parseInt(m[1], 10);
                end = parseInt(m[3], 10);
                if (begin > 100 && begin % 100 && parseInt((begin / 100), 10) === parseInt((end / 100), 10)) {
                    m[3] = "" + (end % 100);
                } else if (begin >= 10000) {
                    m[3] = "" + (end % 1000);
                }
            }
            if (m[2].slice(1) === m[0]) {
                m[2] = range_delimiter;
            }
        }
        return stringify(lst);
    };
    var sniff = function (str, func, minchars, isyear) {
        var ret;
		str = "" + str;
        var lst;
		if (!str.match(/[^\-\u20130-9 ,&]/)) {
			lst = expand(str, "-");
            ret = func(lst, minchars, isyear);
        } else {
			lst = expand(str, "\\s+\\-\\s+");
            ret = func(lst, minchars, isyear);
        }
        return ret;
    }
    if (!state.opt[rangeType + "-range-format"]) {
        ret_func = function (str) {
            return str;
        };
    } else if (state.opt[rangeType + "-range-format"] === "expanded") {
        ret_func = function (str) {
            return sniff(str, stringify);
        };
    } else if (state.opt[rangeType + "-range-format"] === "minimal") {
        ret_func = function (str) {
            return sniff(str, minimize);
        };
    } else if (state.opt[rangeType + "-range-format"] === "minimal-two") {
        ret_func = function (str, isyear) {
            return sniff(str, minimize, 2, isyear);
        };
    } else if (state.opt[rangeType + "-range-format"] === "chicago") {
        ret_func = function (str) {
            return sniff(str, chicago);
        };
    }
    return ret_func;
};
CSL.Util.FlipFlopper = function (state) {
    var tagdefs, pos, len, p, entry, allTags, ret, def, esc, makeHashes, closeTags, flipTags, openToClose, openToDecorations, okReverse, hashes, allTagsLst, lst;
    this.state = state;
    this.blob = false;
    this.quotechars = ['"', "'"];
    tagdefs = [
        ["<i>", "</i>", "italics", "@font-style", ["italic", "normal","normal"], true],
        ["<b>", "</b>", "bold", "@font-weight", ["bold", "normal","normal"], true],
        ["<sup>", "</sup>", "superscript", "@vertical-align", ["sup", "sup","baseline"], true],
        ["<sub>", "</sub>", "subscript", "@vertical-align", ["sub", "sub","baseline"], true],
        ["<sc>", "</sc>", "smallcaps", "@font-variant", ["small-caps", "small-caps","normal"], true],
        ["<span class=\"nocase\">", "</span>", "passthrough", "@passthrough", ["true", "true","true"], true],
        ["<span class=\"nodecor\">", "</span>", "passthrough", "@passthrough", ["true", "true","true"], true],
        ['"',  '"',  "quotes",  "@quotes",  ["true",  "inner","true"],  "'"],
        [" '",  "'",  "quotes",  "@quotes",  ["inner",  "true","true"],  '"']
    ];
    for (pos = 0; pos < 2; pos += 1) {
        p = ["-", "-inner-"][pos];
        entry = [];
        var openq = state.getTerm(("open" + p + "quote"));
        entry.push(openq);
        this.quotechars.push(openq);
        var closeq = state.getTerm(("close" + p + "quote"));
        entry.push(closeq);
        this.quotechars.push(closeq);
        entry.push(("quote" + "s"));
        entry.push(("@" + "quote" + "s"));
        if ("-" === p) {
            entry.push(["true", "inner"]);
        } else {
            entry.push(["inner", "true"]);
        }
        entry.push(true);
        if ("-" === p) {
            entry.push(state.getTerm(("close-inner-quote")));
        } else {
            entry.push(state.getTerm(("close-quote")));
        }
        tagdefs.push(entry);
    }
    allTags = function (tagdefs) {
        ret = [];
        len = tagdefs.length;
        for (pos = 0; pos < len; pos += 1) {
            def = tagdefs[pos];
            if (ret.indexOf(def[0]) === -1) {
                esc = "";
                if (["(", ")", "[", "]"].indexOf(def[0]) > -1) {
                    esc = "\\";
                }
                ret.push(esc + def[0]);
            }
            if (ret.indexOf(def[1]) === -1) {
                esc = "";
                if (["(", ")", "[", "]"].indexOf(def[1]) > -1) {
                    esc = "\\";
                }
                ret.push(esc + def[1]);
            }
        }
        return ret;
    };
    allTagsLst = allTags(tagdefs);
    lst = [];
    for (pos = 0, len = allTagsLst.length; pos < len; pos += 1) {
        if (allTagsLst[pos]) {
            lst.push(allTagsLst[pos]);
        }
    }
    allTagsLst = lst.slice();
    this.allTagsRexMatch = new RegExp("(" + allTagsLst.join("|") + ")", "g");
    this.allTagsRexSplit = new RegExp("(?:" + allTagsLst.join("|") + ")");
    makeHashes = function (tagdefs) {
        closeTags = {};
        flipTags = {};
        openToClose = {};
        openToDecorations = {};
        okReverse = {};
        len = tagdefs.length;
        for (pos = 0; pos < len; pos += 1) {
            closeTags[tagdefs[pos][1]] = true;
            flipTags[tagdefs[pos][1]] = tagdefs[pos][5];
            openToClose[tagdefs[pos][0]] = tagdefs[pos][1];
            openToDecorations[tagdefs[pos][0]] = [tagdefs[pos][3], tagdefs[pos][4]];
            okReverse[tagdefs[pos][3]] = [tagdefs[pos][3], [tagdefs[pos][4][2], tagdefs[pos][1]]];
        }
        return [closeTags, flipTags, openToClose, openToDecorations, okReverse];
    };
    hashes = makeHashes(tagdefs);
    this.closeTagsHash = hashes[0];
    this.flipTagsHash = hashes[1];
    this.openToCloseHash = hashes[2];
    this.openToDecorations = hashes[3];
    this.okReverseHash = hashes[4];
};
CSL.Util.FlipFlopper.prototype.init = function (str, blob) {
    this.txt_esc = CSL.getSafeEscape(this.state);
    if (!blob) {
        this.strs = this.getSplitStrings(str);
        this.blob = new CSL.Blob();
    } else {
        this.blob = blob;
        this.strs = this.getSplitStrings(this.blob.blobs);
        this.blob.blobs = [];
    }
    this.blobstack = new CSL.Stack(this.blob);
};
CSL.Util.FlipFlopper.prototype._normalizeString = function (str) {
    if (str.indexOf(this.quotechars[0]) > -1) {
        for (var i = 0, ilen = 2; i < ilen; i += 1) {
            if (this.quotechars[i + 2]) {
                str = str.replace(this.quotechars[i + 2], this.quotechars[0]);
            }
        }
    }
    if (str.indexOf(this.quotechars[1]) > -1) {
        for (var i = 0, ilen = 2; i < ilen; i += 1) {
            if (this.quotechars[i + 4]) {
                if (i === 0) {
                    str = str.replace(this.quotechars[i + 4], " " + this.quotechars[1]);
                } else {
                    str = str.replace(this.quotechars[i + 4], this.quotechars[1]);
                }
            }
        }
    }
    return str;
};
CSL.Util.FlipFlopper.prototype.getSplitStrings = function (str) {
    var strs, pos, len, newstr, head, tail, expected_closers, expected_openers, expected_flips, tagstack, badTagStack, posA, sameAsOpen, openRev, flipRev, tag, ibeenrunned, posB, wanted_closer, posC, sep, resplice, params, lenA, lenB, lenC, badTagPos, mx, myret;
    str = this._normalizeString(str);
    mx = str.match(this.allTagsRexMatch);
    strs = str.split(this.allTagsRexSplit);
    myret = [strs[0]];
    for (pos = 1, len = strs.length; pos < len; pos += 1) {
        myret.push(mx[pos - 1]);
        myret.push(strs[pos]);
    }
    strs = myret.slice();
    len = strs.length - 2;
    for (pos = len; pos > 0; pos += -2) {
        if (strs[(pos - 1)].slice((strs[(pos - 1)].length - 1)) === "\\") {
            newstr = strs[(pos - 1)].slice(0, (strs[(pos - 1)].length - 1)) + strs[pos] + strs[(pos + 1)];
            head = strs.slice(0, (pos - 1));
            tail = strs.slice((pos + 2));
            head.push(newstr);
            strs = head.concat(tail);
        }
    }
    expected_closers = [];
    expected_openers = [];
    expected_flips = [];
    tagstack = [];
    badTagStack = [];
    lenA = strs.length - 1;
    for (posA = 1; posA < lenA; posA += 2) {
        tag = strs[posA];
        if (this.closeTagsHash[tag]) {
            expected_closers.reverse();
            sameAsOpen = this.openToCloseHash[tag];
            openRev = expected_closers.indexOf(tag);
            flipRev = expected_flips.indexOf(tag);
            expected_closers.reverse();
            if (!sameAsOpen || (openRev > -1 && (openRev < flipRev || flipRev === -1))) {
                ibeenrunned = false;
                lenB = expected_closers.length - 1;
                for (posB = lenB; posB > -1; posB += -1) {
                    ibeenrunned = true;
                    wanted_closer = expected_closers[posB];
                    if (tag === wanted_closer) {
                        expected_closers.pop();
                        expected_openers.pop();
                        expected_flips.pop();
                        tagstack.pop();
                        break;
                    }
                    badTagStack.push(posA);
                }
                if (!ibeenrunned) {
                    badTagStack.push(posA);
                }
                continue;
            }
        }
        if (this.openToCloseHash[tag]) {
            expected_closers.push(this.openToCloseHash[tag]);
            expected_openers.push(tag);
            expected_flips.push(this.flipTagsHash[tag]);
            tagstack.push(posA);
        }
    }
    lenC = expected_closers.length - 1;
    for (posC = lenC; posC > -1; posC += -1) {
        expected_closers.pop();
        expected_flips.pop();
        expected_openers.pop();
        badTagStack.push(tagstack.pop());
    }
    badTagStack.sort(
        function (a, b) {
            if (a < b) {
                return 1;
            } else if (a > b) {
                return -1;
            }
            return 0;
        }
    );
    len = badTagStack.length;
    for (pos = 0; pos < len; pos += 1) {
        badTagPos = badTagStack[pos];
        head = strs.slice(0, (badTagPos - 1));
        tail = strs.slice((badTagPos + 2));
        sep = strs[badTagPos];
        if (sep.length && sep[0] !== "<" && this.openToDecorations[sep] && this.quotechars.indexOf(sep.replace(/\s+/g,"")) === -1) {
            params = this.openToDecorations[sep];
            sep = this.state.fun.decorate[params[0]][params[1][0]](this.state);
        }
        resplice = strs[(badTagPos - 1)] + sep + strs[(badTagPos + 1)];
        head.push(resplice);
        strs = head.concat(tail);
    }
    len = strs.length;
    for (pos = 0; pos < len; pos += 2) {
        strs[pos] = strs[pos].replace("'", "\u2019", "g");
    }
    return strs;
};
CSL.Util.FlipFlopper.prototype.processTags = function () {
    var expected_closers, expected_openers, expected_flips, expected_rendering, str, posA, tag, prestr, newblob, blob, sameAsOpen, openRev, flipRev, posB, wanted_closer, newblobnest, param, fulldecor, level, decor, lenA, lenB, posC, lenC;
    expected_closers = [];
    expected_openers = [];
    expected_flips = [];
    expected_rendering = [];
    str = "";
    if (this.strs.length === 1) {
        this.blob.blobs = this.strs[0];
    } else if (this.strs.length > 2) {
        lenA = (this.strs.length - 1);
        for (posA = 1; posA < lenA; posA += 2) {
            tag = this.strs[posA];
            prestr = this.strs[(posA - 1)];
            if (prestr) {
                newblob = new CSL.Blob(prestr);
                blob = this.blobstack.value();
                blob.push(newblob);
            }
            if (this.closeTagsHash[tag]) {
                expected_closers.reverse();
                sameAsOpen = this.openToCloseHash[tag];
                openRev = expected_closers.indexOf(tag);
                flipRev = expected_flips.indexOf(tag);
                expected_closers.reverse();
                if (!sameAsOpen || (openRev > -1 && (openRev < flipRev || flipRev === -1))) {
                    lenB = expected_closers.length;
                    for (posB = lenB; posB > -1; posB += -1) {
                        wanted_closer = expected_closers[posB];
                        if (tag === wanted_closer) {
                            expected_closers.pop();
                            expected_openers.pop();
                            expected_flips.pop();
                            expected_rendering.pop();
                            this.blobstack.pop();
                            break;
                        }
                    }
                    continue;
                }
            }
            if (this.openToCloseHash[tag]) {
                expected_closers.push(this.openToCloseHash[tag]);
                expected_openers.push(tag);
                expected_flips.push(this.flipTagsHash[tag]);
                blob = this.blobstack.value();
                newblobnest = new CSL.Blob();
                blob.push(newblobnest);
                param = this.addFlipFlop(newblobnest, this.openToDecorations[tag]);
                if (tag === "<span class=\"nodecor\">") {
                    fulldecor = this.state[this.state.tmp.area].opt.topdecor.concat(this.blob.alldecor).concat([[["@quotes", "inner"]]]);
                    lenB = fulldecor.length;
                    for (posB = 0; posB < lenB; posB += 1) {
                        level = fulldecor[posB];
                        lenC = level.length;
                        for (posC = 0; posC < lenC; posC += 1) {
                            decor = level[posC];
                            if (["@font-style", "@font-weight", "@font-variant"].indexOf(decor[0]) > -1) {
                                param = this.addFlipFlop(newblobnest, this.okReverseHash[decor[0]]);
                            }
                        }
                    }
                }
                expected_rendering.push(this.state.fun.decorate[param[0]][param[1]](this.state));
                this.blobstack.push(newblobnest);
            }
        }
        if (this.strs.length > 2) {
            str = this.strs[(this.strs.length - 1)];
            if (str) {
                blob = this.blobstack.value();
                newblob = new CSL.Blob(str);
                blob.push(newblob);
            }
        }
    }
    return this.blob;
};
CSL.Util.FlipFlopper.prototype.addFlipFlop = function (blob, fun) {
    var posA, posB, fulldecor, lenA, decorations, breakme, decor, posC, newdecor, lenC;
    posB = 0;
    fulldecor = this.state[this.state.tmp.area].opt.topdecor.concat(blob.alldecor).concat([[["@quotes", "inner"]]]);
    lenA = fulldecor.length;
    for (posA = 0; posA < lenA; posA += 1) {
        decorations = fulldecor[posA];
        breakme = false;
        lenC = decorations.length - 1;
        for (posC = lenC; posC > -1; posC += -1) {
            decor = decorations[posC];
            if (decor[0] === fun[0]) {
                if (decor[1] === fun[1][0]) {
                    posB = 1;
                }
                breakme = true;
                break;
            }
        }
        if (breakme) {
            break;
        }
    }
    newdecor = [fun[0], fun[1][posB]];
    blob.decorations.reverse();
    blob.decorations.push(newdecor);
    blob.decorations.reverse();
    return newdecor;
};
CSL.Output.Formatters = {};
CSL.getSafeEscape = function(state) {
    if (["bibliography", "citation"].indexOf(state.tmp.area) > -1) {
        return CSL.Output.Formats[state.opt.mode].text_escape;
    } else {
        return function (txt) { return txt; };
    }
};
CSL.Output.Formatters.passthrough = function (state, string) {
    return string;
};
CSL.Output.Formatters.lowercase = function (state, string) {
    var str = CSL.Output.Formatters.doppelString(string, CSL.TAG_USEALL);
    str.string = str.string.toLowerCase();
    return CSL.Output.Formatters.undoppelString(str);
};
CSL.Output.Formatters.uppercase = function (state, string) {
    var str = CSL.Output.Formatters.doppelString(string, CSL.TAG_USEALL);
    str.string = str.string.toUpperCase();
    return CSL.Output.Formatters.undoppelString(str);
};
CSL.Output.Formatters["capitalize-first"] = function (state, string) {
    var str = CSL.Output.Formatters.doppelString(string, CSL.TAG_ESCAPE);
    if (str.string.length) {
        str.string = str.string.slice(0, 1).toUpperCase() + str.string.substr(1);
        return CSL.Output.Formatters.undoppelString(str);
    } else {
        return "";
    }
};
CSL.Output.Formatters.sentence = function (state, string) {
    var str = CSL.Output.Formatters.doppelString(string, CSL.TAG_ESCAPE);
    str.string = str.string.slice(0, 1).toUpperCase() + str.string.substr(1).toLowerCase();
    return CSL.Output.Formatters.undoppelString(str);
};
CSL.Output.Formatters["capitalize-all"] = function (state, string) {
    var str, strings, len, pos;
    str = CSL.Output.Formatters.doppelString(string, CSL.TAG_ESCAPE);
    strings = str.string.split(" ");
    len = strings.length;
    for (pos = 0; pos < len; pos += 1) {
        if (strings[pos].length > 1) {
            strings[pos] = strings[pos].slice(0, 1).toUpperCase() + strings[pos].substr(1).toLowerCase();
        } else if (strings[pos].length === 1) {
            strings[pos] = strings[pos].toUpperCase();
        }
    }
    str.string = strings.join(" ");
    return CSL.Output.Formatters.undoppelString(str);
};
CSL.Output.Formatters.title = function (state, string) {
    var str, words, isAllUpperCase, newString, lastWordIndex, previousWordIndex, upperCaseVariant, lowerCaseVariant, pos, skip, notfirst, notlast, aftercolon, len, idx, tmp, skipword, ppos, mx, lst, myret;
    var SKIP_WORDS = state.locale[state.opt.lang].opts["skip-words"];
    str = CSL.Output.Formatters.doppelString(string, CSL.TAG_ESCAPE);
    if (!string) {
        return "";
    }
    mx = str.string.match(/(\s+)/g);
    lst = str.string.split(/\s+/);
    myret = [lst[0]];
    for (pos = 1, len = lst.length; pos < len; pos += 1) {
        myret.push(mx[pos - 1]);
        myret.push(lst[pos]);
    }
    words = myret.slice();
    isAllUpperCase = str.string.toUpperCase() === string && !str.string.match(/[0-9]/);
    newString = "";
    lastWordIndex = words.length - 1;
    previousWordIndex = -1;
    for (pos = 0; pos <= lastWordIndex;  pos += 2) {
        if (words[pos].length !== 0 && words[pos].length !== 1 && !/\s+/.test(words[pos])) {
            upperCaseVariant = words[pos].toUpperCase();
            lowerCaseVariant = words[pos].toLowerCase();
            var totallyskip = false;
            if (!isAllUpperCase || (words.length === 1 && words[pos].length < 4)) {
                if (words[pos] !== lowerCaseVariant) {
                    totallyskip = true;
                }
            }
            if (isAllUpperCase || words[pos] === lowerCaseVariant) {
                skip = false;
                for (var i = 0, ilen = SKIP_WORDS.length; i < ilen; i += 1) {
                    skipword = SKIP_WORDS[i];
                    idx = lowerCaseVariant.indexOf(skipword);
                    if (idx > -1) {
                        tmp = lowerCaseVariant.slice(0, idx) + lowerCaseVariant.slice(idx + skipword.length);
                        if (!tmp.match(/[a-zA-Z]/)) {
                            skip = true;
                        }
                    }
                }
                notfirst = pos !== 0;
                notlast = pos !== lastWordIndex;
                if (words[previousWordIndex]) {
                    aftercolon = words[previousWordIndex].slice(-1) === ":";
                } else {
                    aftercolon = false;
                }
                if (!totallyskip) {
                    if (skip && notfirst && notlast && !aftercolon) {
                        words[pos] = lowerCaseVariant;
                    } else {
                        words[pos] = upperCaseVariant.slice(0, 1) + lowerCaseVariant.substr(1);
                    }
                }
            }
            previousWordIndex = pos;
        }
    }
    str.string = words.join("");
    return CSL.Output.Formatters.undoppelString(str);
};
CSL.Output.Formatters.doppelString = function (string, rex) {
    var ret, pos, len;
    ret = {};
    ret.array = rex(string);
    ret.string = "";
    len = ret.array.length;
    for (pos = 0; pos < len; pos += 2) {
        ret.string += ret.array[pos];
    }
    return ret;
};
CSL.Output.Formatters.undoppelString = function (str) {
    var ret, len, pos;
    ret = "";
    len = str.array.length;
    for (pos = 0; pos < len; pos += 1) {
        if ((pos % 2)) {
            ret += str.array[pos];
        } else {
            ret += str.string.slice(0, str.array[pos].length);
            str.string = str.string.slice(str.array[pos].length);
        }
    }
    return ret;
};
CSL.Output.Formatters.serializeItemAsRdf = function (Item) {
    return "";
};
CSL.Output.Formatters.serializeItemAsRdfA = function (Item) {
    return "";
};
CSL.demoteNoiseWords = function (state, fld) {
    var SKIP_WORDS = state.locale[state.opt.lang].opts["skip-words"];
    if (fld) {
        fld = fld.split(/\s+/);
        fld.reverse();
        var toEnd = [];
        for (var j  = fld.length - 1; j > -1; j += -1) {
            if (SKIP_WORDS.indexOf(fld[j].toLowerCase()) > -1) {
                toEnd.push(fld.pop());
            } else {
                break;
            }
        }
        fld.reverse();
        var start = fld.join(" ");
        var end = toEnd.join(" ");
        fld = [start, end].join(", ");
    }
    return fld;
};
CSL.Output.Formats = function () {};
CSL.Output.Formats.prototype.html = {
    "text_escape": function (text) {
        if (!text) {
            text = "";
        }
        return text.replace(/&/g, "&#38;")
            .replace(/</g, "&#60;")
            .replace(/>/g, "&#62;")
            .replace("  ", "&#160; ", "g")
            .replace(CSL.SUPERSCRIPTS_REGEXP,
                     function(aChar) {
                         return "<sup>" + CSL.SUPERSCRIPTS[aChar] + "</sup>";
                     });
    },
    "bibstart": "<div class=\"csl-bib-body\">\n",
    "bibend": "</div>",
    "@font-style/italic": "<i>%%STRING%%</i>",
    "@font-style/oblique": "<em>%%STRING%%</em>",
    "@font-style/normal": "<span style=\"font-style:normal;\">%%STRING%%</span>",
    "@font-variant/small-caps": "<span style=\"font-variant:small-caps;\">%%STRING%%</span>",
    "@passthrough/true": CSL.Output.Formatters.passthrough,
    "@font-variant/normal": "<span style=\"font-variant:normal;\">%%STRING%%</span>",
    "@font-weight/bold": "<b>%%STRING%%</b>",
    "@font-weight/normal": "<span style=\"font-weight:normal;\">%%STRING%%</span>",
    "@font-weight/light": false,
    "@text-decoration/none": "<span style=\"text-decoration:none;\">%%STRING%%</span>",
    "@text-decoration/underline": "<span style=\"text-decoration:underline;\">%%STRING%%</span>",
    "@vertical-align/sup": "<sup>%%STRING%%</sup>",
    "@vertical-align/sub": "<sub>%%STRING%%</sub>",
    "@vertical-align/baseline": "<span style=\"baseline\">%%STRING%%</span>",
    "@strip-periods/true": CSL.Output.Formatters.passthrough,
    "@strip-periods/false": CSL.Output.Formatters.passthrough,
    "@quotes/true": function (state, str) {
        if ("undefined" === typeof str) {
            return state.getTerm("open-quote");
        }
        return state.getTerm("open-quote") + str + state.getTerm("close-quote");
    },
    "@quotes/inner": function (state, str) {
        if ("undefined" === typeof str) {
            return "\u2019";
        }
        return state.getTerm("open-inner-quote") + str + state.getTerm("close-inner-quote");
    },
    "@quotes/false": false,
    "@bibliography/entry": function (state, str) {
        var insert = "";
        if (state.sys.embedBibliographyEntry) {
            insert = state.sys.embedBibliographyEntry(this.item_id) + "\n";
        }
        return "  <div class=\"csl-entry\">" + str + "</div>\n" + insert;
    },
    "@display/block": function (state, str) {
        return "\n\n    <div class=\"csl-block\">" + str + "</div>\n";
    },
    "@display/left-margin": function (state, str) {
        return "\n    <div class=\"csl-left-margin\">" + str + "</div>";
    },
    "@display/right-inline": function (state, str) {
        return "<div class=\"csl-right-inline\">" + str + "</div>\n  ";
    },
    "@display/indent": function (state, str) {
        return "<div class=\"csl-indent\">" + str + "</div>\n  ";
    },
    "@showid/true": function (state, str, cslid) {
        return "<span class=\"" + state.opt.nodenames[cslid] + "\" cslid=\"" + cslid + "\">" + str + "</span>";
    },
    "@URL/true": function (state, str) {
        return "<a href=\"" + str + "\">" + str + "</a>";
    },
    "@DOI/true": function (state, str) {
        return "<a href=\"http://dx.doi.org/" + str + "\">" + str + "</a>";
    }
};
CSL.Output.Formats.prototype.text = {
    "text_escape": function (text) {
        if (!text) {
            text = "";
        }
        return text;
    },
    "bibstart": "",
    "bibend": "",
    "@font-style/italic": false,
    "@font-style/oblique": false,
    "@font-style/normal": false,
    "@font-variant/small-caps": false,
    "@passthrough/true": CSL.Output.Formatters.passthrough,
    "@font-variant/normal": false,
    "@font-weight/bold": false,
    "@font-weight/normal": false,
    "@font-weight/light": false,
    "@text-decoration/none": false,
    "@text-decoration/underline": false,
    "@vertical-align/baseline": false,
    "@vertical-align/sup": false,
    "@vertical-align/sub": false,
    "@strip-periods/true": CSL.Output.Formatters.passthrough,
    "@strip-periods/false": CSL.Output.Formatters.passthrough,
    "@quotes/true": function (state, str) {
        if ("undefined" === typeof str) {
            return state.getTerm("open-quote");
        }
        return state.getTerm("open-quote") + str + state.getTerm("close-quote");
    },
    "@quotes/inner": function (state, str) {
        if ("undefined" === typeof str) {
            return "\u2019";
        }
        return state.getTerm("open-inner-quote") + str + state.getTerm("close-inner-quote");
    },
    "@quotes/false": false,
    "@bibliography/entry": function (state, str) {
        return str+"\n";
    },
    "@display/block": function (state, str) {
        return "\n"+str;
    },
    "@display/left-margin": function (state, str) {
        return str;
    },
    "@display/right-inline": function (state, str) {
        return str;
    },
    "@display/indent": function (state, str) {
        return "\n    "+str;
    },
    "@url/true": function (state, str) {
        return str;
    },
    "@doi/true": function (state, str) {
        return str;
    }
};
CSL.Output.Formats.prototype.rtf = {
    "text_escape": function (text) {
        if (!text) {
            text = "";
        }
        return text
        .replace(/([\\{}])/g, "\\$1", "g")
        .replace(CSL.SUPERSCRIPTS_REGEXP,
                 function(aChar) {
                     return "\\super " + CSL.SUPERSCRIPTS[aChar] + "\\nosupersub{}";
                 })
        .replace(/[\x7F-\uFFFF]/g,
                 function(aChar) { return "\\uc0\\u"+aChar.charCodeAt(0).toString()+"{}"; })
        .replace("\t", "\\tab{}", "g");
    },
    "@passthrough/true": CSL.Output.Formatters.passthrough,
    "@font-style/italic":"\\i %%STRING%%\\i0{}",
    "@font-style/normal":"\\i0{}%%STRING%%\\i{}",
    "@font-style/oblique":"\\i %%STRING%%\\i0{}",
    "@font-variant/small-caps":"\\scaps %%STRING%%\\scaps0{}",
    "@font-variant/normal":"\\scaps0{}%%STRING%%\\scaps{}",
    "@font-weight/bold":"\\b %%STRING%%\\b0{}",
    "@font-weight/normal":"\\b0{}%%STRING%%\\b{}",
    "@font-weight/light":false,
    "@text-decoration/none":false,
    "@text-decoration/underline":"\\ul %%STRING%%\\ul0{}",
    "@vertical-align/baseline":false,
    "@vertical-align/sup":"\\super %%STRING%%\\nosupersub{}",
    "@vertical-align/sub":"\\sub %%STRING%%\\nosupersub{}",
    "@strip-periods/true": CSL.Output.Formatters.passthrough,
    "@strip-periods/false": CSL.Output.Formatters.passthrough,
    "@quotes/true": function (state, str) {
        if ("undefined" === typeof str) {
            return CSL.Output.Formats.rtf.text_escape(state.getTerm("open-quote"));
        }
        return CSL.Output.Formats.rtf.text_escape(state.getTerm("open-quote")) + str + CSL.Output.Formats.rtf.text_escape(state.getTerm("close-quote"));
    },
    "@quotes/inner": function (state, str) {
        if ("undefined" === typeof str) {
            return CSL.Output.Formats.rtf.text_escape("\u2019");
        }
        return CSL.Output.Formats.rtf.text_escape(state.getTerm("open-inner-quote")) + str + CSL.Output.Formats.rtf.text_escape(state.getTerm("close-inner-quote"));
    },
    "@quotes/false": false,
    "bibstart":"{\\rtf ",
    "bibend":"}",
    "@display/block":"%%STRING%%\\line\r\n",
    "@bibliography/entry": function(state,str){
        return str;
    },
    "@display/left-margin": function(state,str){
        return str+"\\tab ";
    },
    "@display/right-inline": function (state, str) {
        return str+"\n";
    },
    "@display/indent": function (state, str) {
        return "\n\\tab "+str;
    },
    "@url/true": function (state, str) {
        return str;
    },
    "@doi/true": function (state, str) {
        return str;
    }
};
CSL.Output.Formats = new CSL.Output.Formats();
CSL.Registry = function (state) {
    var pos, len, ret, i, ilen;
    this.debug = false;
    this.state = state;
    this.registry = {};
    this.reflist = [];
    this.namereg = new CSL.Registry.NameReg(state);
    this.citationreg = new CSL.Registry.CitationReg(state);
    this.authorstrings = {};
    this.generate = {};
    this.generate.origIDs = {};
    this.generate.genIDs = {};
    this.generate.rules = [];
    this.mylist = [];
    this.myhash = {};
    this.deletes = [];
    this.inserts = [];
    this.uncited = [];
    this.refreshes = {};
    this.akeys = {};
    this.oldseq = {};
    this.return_data = {};
    this.ambigcites = {};
    this.sorter = new CSL.Registry.Comparifier(state, "bibliography_sort");
    this.getSortedIds = function () {
        ret = [];
        for (i = 0, ilen = this.reflist.length; i < ilen; i += 1) {
            ret.push("" + this.reflist[i].id);
        }
        return ret;
    };
    this.getSortedRegistryItems = function () {
        ret = [];
        for (i = 0, ilen = this.reflist.length; i < ilen; i += 1) {
            ret.push(this.reflist[i]);
        }
        return ret;
    };
};
CSL.Registry.prototype.init = function (myitems, uncited_flag) {
    var i, ilen;
    this.oldseq = {};
	var tmphash = {};
	for (i = myitems.length - 1; i > -1; i += -1) {
		if (tmphash[myitems[i]]) {
			myitems = myitems.slice(0, i).concat(myitems.slice(i + 1));
		} else {
			tmphash[myitems[i]] = true;
		}
	}
    if (uncited_flag && this.mylist && this.mylist.length) {
        this.uncited = myitems;
        for (i = 0, ilen = myitems.length; i < ilen; i += 1) {
            myitems[i] = "" + myitems[i];
            if (!this.myhash[myitems[i]] && this.mylist.indexOf(myitems[i]) === -1) {
                this.mylist.push(myitems[i]);
            }
        }
    } else {
        this.mylist = myitems.concat(this.uncited);
    }
    this.myhash = {};
    for (i = 0, ilen = this.mylist.length; i < ilen; i += 1) {
        this.mylist[i] = "" + this.mylist[i];
        this.myhash[this.mylist[i]] = true;
    }
    this.refreshes = {};
    this.touched = {};
};
CSL.Registry.prototype.dodeletes = function (myhash) {
    var otheritems, key, ambig, pos, len, items, kkey, mypos, id;
    if ("string" === typeof myhash) {
        myhash = {};
        myhash[myhash] = true;
    }
    for (key in this.registry) {
        if (this.registry.hasOwnProperty(key) && !myhash[key]) {
            if (this.registry[key].uncited) {
                continue;
            }
            otheritems = this.namereg.delitems(key);
            for (kkey in otheritems) {
                if (otheritems.hasOwnProperty(kkey)) {
                    this.refreshes[kkey] = true;
                }
            }
            ambig = this.registry[key].ambig;
            mypos = this.ambigcites[ambig].indexOf(key);
            if (mypos > -1) {
                items = this.ambigcites[ambig].slice();
                this.ambigcites[ambig] = items.slice(0, mypos).concat(items.slice([(mypos + 1)], items.length));
            }
            len = this.ambigcites[ambig].length;
            for (pos = 0; pos < len; pos += 1) {
                id = "" + this.ambigcites[ambig][pos];
                this.refreshes[id] = true;
            }
            delete this.registry[key];
            if (this.generate.origIDs[key]) {
                delete this.generate.origIDs[key];
                delete this.generate.genIDs[key + ":gen"];
            }
            this.return_data.bibchange = true;
        }
    }
};
CSL.Registry.prototype.doinserts = function (mylist) {
    var len, pos, item, Item, akey, newitem, abase, j, jlen, k, klen, i, ilen;
    if ("string" === typeof mylist) {
        mylist = [mylist];
    }
    for (i = 0, ilen = mylist.length; i < ilen; i += 1) {
        item = mylist[i];
        if (!this.registry[item]) {
            Item = this.state.retrieveItem(item);
            for (j = 0, jlen = this.generate.rules.length; j < jlen; j += 1) {
                if (Item.type === this.generate.rules[j].from) {
                    var needsRule = true;
                    for (k = 0, klen = this.generate.rules[j].triggers.length; k < klen; k += 1) {
                        if (!Item[this.generate.rules[j].triggers[k]]) {
                            needsRule = false;
                            break;
                        }
                    }
                    if (needsRule) {
                        this.generate.origIDs[item] = this.generate.rules[j];
                        this.generate.genIDs[item + ":gen"] = this.generate.rules[j];
                    }
                }
            }
            akey = CSL.getAmbiguousCite.call(this.state, Item);
            if (!Item.legislation_id) {
                this.akeys[akey] = true;
            }
            newitem = {
                "id": "" + item,
                "seq": 0,
                "offset": 0,
                "sortkeys": false,
                "ambig": false,
                "rendered": false,
                "disambig": false,
                "ref": Item
            };
            this.registry[item] = newitem;
            abase = CSL.getAmbigConfig.call(this.state);
            this.registerAmbigToken(akey, item, abase);
            this.touched[item] = true;
            this.return_data.bibchange = true;
        }
    }
};
CSL.Registry.prototype.douncited = function () {
    var pos, len;
    for (pos = 0, len = this.mylist.length; pos < len; pos += 1) {
        this.registry[this.mylist[pos]].uncited = false;
    }
    for (pos = 0, len = this.uncited.length; pos < len; pos += 1) {
        this.registry[this.mylist[pos]].uncited = true;
    }
};
CSL.Registry.prototype.rebuildlist = function () {
    var count, len, pos, item;
    this.reflist = [];
    if (this.state.opt.citation_number_sort_direction === CSL.DESCENDING
       && this.state.opt.citation_number_sort_used) {
    }
    len = this.mylist.length;
    for (pos = 0; pos < len; pos += 1) {
        item = this.mylist[pos];
        this.reflist.push(this.registry[item]);
        this.oldseq[item] = this.registry[item].seq;
        this.registry[item].seq = (pos + 1);
    }
    if (this.state.opt.citation_number_sort_direction === CSL.DESCENDING
       && this.state.opt.citation_number_sort_used) {
    }
};
CSL.Registry.prototype.dorefreshes = function () {
    var key, regtoken, Item, old_akey, akey, abase;
    for (key in this.refreshes) {
        if (this.refreshes.hasOwnProperty(key)) {
            regtoken = this.registry[key];
            delete this.registry[key];
            if (!regtoken) {
                continue;
            }
            regtoken.disambig = undefined;
            regtoken.sortkeys = undefined;
            regtoken.ambig = undefined;
            Item = this.state.retrieveItem(key);
            var akey = regtoken.ambig;
            if ("undefined" === typeof akey) {
                akey = CSL.getAmbiguousCite.call(this.state, Item);
                this.state.tmp.taintedItemIDs[key] = true;
            }
            this.registry[key] = regtoken;
            abase = CSL.getAmbigConfig.call(this.state);
            this.registerAmbigToken(akey, key, abase);
            if (!Item.legislation_id) {
                this.akeys[akey] = true;
            }
            this.touched[key] = true;
        }
    }
};
CSL.Registry.prototype.setdisambigs = function () {
    var akey, leftovers, key, pos, len, id;
    this.leftovers = [];
    for (akey in this.akeys) {
        this.state.disambiguate.run(akey);
    }
    this.akeys = {};
};
CSL.Registry.prototype.renumber = function () {
    var len, pos, item;
    if (this.state.opt.citation_number_sort_direction === CSL.DESCENDING
       && this.state.opt.citation_number_sort_used) {
    }
    len = this.reflist.length;
    for (pos = 0; pos < len; pos += 1) {
        item = this.reflist[pos];
        item.seq = (pos + 1);
        var hasTaints = false;
        for (var key in this.state.tmp.taintedItemIDs) {
            hasTaints = true;
            break;
        }
        if (hasTaints && item.seq != this.oldseq[item.id]) {
            if (this.state.opt.update_mode === CSL.NUMERIC) {
                this.state.tmp.taintedItemIDs[item.id] = true;
            }
            if (this.state.opt.bib_mode === CSL.NUMERIC) {
                this.return_data.bibchange = true;
            }
        }
    }
    if (this.state.opt.citation_number_sort_direction === CSL.DESCENDING
       && this.state.opt.citation_number_sort_used) {
        this.reflist.reverse();
    }
};
CSL.Registry.prototype.setsortkeys = function () {
    var key;
    for (key in this.touched) {
        if (this.touched.hasOwnProperty(key)) {
            this.registry[key].sortkeys = CSL.getSortKeys.call(this.state, this.state.retrieveItem(key), "bibliography_sort");
        }
    }
};
CSL.Registry.prototype.sorttokens = function () {
    this.reflist.sort(this.sorter.compareKeys);
};
CSL.Registry.Comparifier = function (state, keyset) {
    var sort_directions, len, pos, compareKeys;
    var sortCompare = CSL.getSortCompare();
    sort_directions = state[keyset].opt.sort_directions;
    this.compareKeys = function (a, b) {
        len = a.sortkeys.length;
        for (pos = 0; pos < len; pos += 1) {
            var cmp = 0;
            if (a.sortkeys[pos] === b.sortkeys[pos]) {
                cmp = 0;
            } else if ("undefined" === typeof a.sortkeys[pos]) {
                cmp = sort_directions[pos][1];
            } else if ("undefined" === typeof b.sortkeys[pos]) {
                cmp = sort_directions[pos][0];
            } else {
                cmp = sortCompare(a.sortkeys[pos], b.sortkeys[pos]);
            }
            if (0 < cmp) {
                return sort_directions[pos][1];
            } else if (0 > cmp) {
                return sort_directions[pos][0];
            }
        }
        if (a.seq > b.seq) {
            return 1;
        } else if (a.seq < b.seq) {
            return -1;
        }
        return 0;
    };
    compareKeys = this.compareKeys;
    this.compareCompositeKeys = function (a, b) {
        return compareKeys(a[1], b[1]);
    };
};
CSL.Registry.prototype.compareRegistryTokens = function (a, b) {
    if (a.seq > b.seq) {
        return 1;
    } else if (a.seq < b.seq) {
        return -1;
    }
    return 0;
};
CSL.Registry.prototype.registerAmbigToken = function (akey, id, ambig_config) {
    if (this.registry[id] && this.registry[id].disambig && this.registry[id].disambig.names) {
        for (var i = 0, ilen = ambig_config.names.length; i < ilen; i += 1) {
            var new_names_params = ambig_config.names[i];
            var old_names_params = this.registry[id].disambig.names[i];
            if (new_names_params !== old_names_params) {
                this.state.tmp.taintedItemIDs[id] = true;
            }
        }
    }
    if (!this.ambigcites[akey]) {
        this.ambigcites[akey] = [];
    }
    if (this.ambigcites[akey].indexOf("" + id) === -1) {
        this.ambigcites[akey].push("" + id);
    }
    this.registry[id].ambig = akey;
    var dome = false;
    this.registry[id].disambig = CSL.cloneAmbigConfig(ambig_config);
};
CSL.getSortKeys = function (Item, key_type) {
    var area, extension, strip_prepositions, use_parallels, len, pos;
    area = this.tmp.area;
    extension = this.tmp.extension;
    strip_prepositions = CSL.Util.Sort.strip_prepositions;
    this.tmp.area = key_type;
    this.tmp.extension = "_sort";
    this.tmp.disambig_override = true;
    this.tmp.disambig_request = false;
    use_parallels = this.parallel.use_parallels;
    this.parallel.use_parallels = false;
    this.tmp.suppress_decorations = true;
    CSL.getCite.call(this, Item);
    this.tmp.suppress_decorations = false;
    this.parallel.use_parallels = use_parallels;
    this.tmp.disambig_override = false;
    len = this[key_type].keys.length;
    for (pos = 0; pos < len; pos += 1) {
        this[key_type].keys[pos] = strip_prepositions(this[key_type].keys[pos]);
    }
    this.tmp.area = area;
    this.tmp.extension = extension;
    return this[key_type].keys;
};
CSL.Registry.NameReg = function (state) {
    var pkey, ikey, skey, floor, ceiling, dagopt, gdropt, ret, pos, items, strip_periods, set_keys, evalname, delitems, addname, key, myitems;
    this.state = state;
    this.namereg = {};
    this.nameind = {};
    this.nameindpkeys = {};
    this.itemkeyreg = {};
    strip_periods = function (str) {
        if (!str) {
            str = "";
        }
        return str.replace(".", " ", "g").replace(/\s+/g, " ").replace(/\s+$/,"");
    };
    set_keys = function (state, itemid, nameobj) {
        pkey = strip_periods(nameobj.family);
        skey = strip_periods(nameobj.given);
        var m = skey.match(/,\!* [^,]$/);
        if (m && m[1] === m[1].toLowerCase()) {
            skey = skey.replace(/,\!* [^,]$/, "");
        }
        ikey = CSL.Util.Names.initializeWith(state, skey, "%s");
        if (state.opt["givenname-disambiguation-rule"] === "by-cite") {
            pkey = "" + itemid + pkey;
        }
    };
    evalname = function (item_id, nameobj, namenum, request_base, form, initials) {
        var pos, len, items, param;
        if (state.tmp.area === "bibliography" && !form && "string" !== typeof initials) {
              return 2;
        }
        var res = state.nameOutput.getName(nameobj, "locale-translit", true);
        nameobj = res.name;
        set_keys(this.state, "" + item_id, nameobj);
        param = 2;
        dagopt = state.opt["disambiguate-add-givenname"];
        gdropt = state.opt["givenname-disambiguation-rule"];
        var gdropt_orig = gdropt;
        if (gdropt === "by-cite") {
            gdropt = "all-names";
        }
        if ("short" === form) {
            param = 0;
        } else if ("string" === typeof initials) {
            param = 1;
        }
        if ("undefined" === typeof this.namereg[pkey] || "undefined" === typeof this.namereg[pkey].ikey[ikey]) {
            return param;
        }
        if (gdropt_orig === "by-cite" && param <= request_base) {
            return request_base;
        }
        if (!dagopt) {
            return param;
        }
        if ("string" === typeof gdropt && gdropt.slice(0, 12) === "primary-name" && namenum > 0) {
            return param;
        }
        if (!gdropt || gdropt === "all-names" || gdropt === "primary-name") {
            if (this.namereg[pkey].count > 1) {
                param = 1;
            }
            if ((this.namereg[pkey].ikey 
                 && this.namereg[pkey].ikey[ikey].count > 1)
                || (this.namereg[pkey].count > 1 
                    && "string" !== typeof initials)) {
                param = 2;
            }
        } else if (gdropt === "all-names-with-initials" || gdropt === "primary-name-with-initials") {
            if (this.namereg[pkey].count > 1) {
                param = 1;
            } else {
                param = 0;
            }
        }
        if (param === 0) {
            pos = this.namereg[pkey].ikey[ikey].items.indexOf("" + item_id);
            items = this.namereg[pkey].ikey[ikey].items;
            if (pos > -1) {
                items = items.slice(0, pos).concat(items.slice(pos + 1));
            }
            for (pos = 0, len = items.length; pos < len; pos += 1) {
                this.state.tmp.taintedItemIDs[items[pos]] = true;
            }
            pos = this.namereg[pkey].ikey[ikey].skey[skey].items.indexOf("" + item_id);
            items = this.namereg[pkey].ikey[ikey].skey[skey].items;
            if (pos > -1) {
                items = items.slice(0, pos).concat(items.slice(pos + 1));
            }
            for (pos = 0, len = items.length; pos < len; pos += 1) {
                this.state.tmp.taintedItemIDs[items[pos]] = true;
            }
            if (this.namereg[pkey].items.indexOf("" + item_id) === -1) {
                this.namereg[pkey].items.push("" + item_id);
            }
        } else if (param === 1) {
            pos = this.namereg[pkey].items.indexOf("" + item_id);
            items = this.namereg[pkey].items;
            if (pos > -1) {
                items = items.slice(0, pos).concat(items.slice(pos + 1));
            }
            for (pos = 0, len = items.length; pos < len; pos += 1) {
                this.state.tmp.taintedItemIDs[items[pos]] = true;
            }
            pos = this.namereg[pkey].ikey[ikey].skey[skey].items.indexOf("" + item_id);
            items = this.namereg[pkey].ikey[ikey].skey[skey].items;
            if (pos > -1) {
                items = items.slice(0, pos).concat(items.slice(pos + 1));
            }
            for (pos = 0, len = items.length; pos < len; pos += 1) {
                this.state.tmp.taintedItemIDs[items[pos]] = true;
            }
            if (this.namereg[pkey].ikey[ikey].items.indexOf("" + item_id) === -1) {
                this.namereg[pkey].ikey[ikey].items.push("" + item_id);
            }
        } else if (param === 2) {
            pos = this.namereg[pkey].items.indexOf("" + item_id);
            items = this.namereg[pkey].items;
            if (pos > -1) {
                items = items.slice(0, pos).concat(items.slice(pos + 1));
            }
            for (pos = 0, len = items.length; pos < len; pos += 1) {
                this.state.tmp.taintedItemIDs[items[pos]] = true;
            }
            pos = this.namereg[pkey].ikey[ikey].items.indexOf("" + item_id);
            items = this.namereg[pkey].ikey[ikey].items;
            if (pos > -1) {
                items = items.slice(0, pos).concat(items.slice(pos + 1));
            }
            for (pos = 0, len = items.length; pos < len; pos += 1) {
                this.state.tmp.taintedItemIDs[items[pos]] = true;
            }
            if (this.namereg[pkey].ikey[ikey].skey[skey].items.indexOf("" + item_id) === -1) {
                this.namereg[pkey].ikey[ikey].skey[skey].items.push("" + item_id);
            }
        }
        if (!state.registry.registry[item_id]) {
            if (form == "short") {
                return 0;
            } else if ("string" == typeof initials) {
                return 1;
            }
        } else {
            return param;
        }
    };
    delitems = function (ids) {
        var i, item, pos, len, posA, posB, id, fullkey, llen, ppos, otherid;
        if ("string" === typeof ids || "number" === typeof ids) {
            ids = ["" + ids];
        }
        ret = {};
        len = ids.length;
        for (pos = 0; pos < len; pos += 1) {
            id = "" + ids[pos];
            if (!this.nameind[id]) {
                continue;
            }
            for (fullkey in this.nameind[id]) {
                if (this.nameind[id].hasOwnProperty(fullkey)) {
                    key = fullkey.split("::");
                    pkey = key[0];
                    ikey = key[1];
                    skey = key[2];
                    if ("undefined" === typeof this.namereg[pkey]) {
                        continue;
                    }
                    items = this.namereg[pkey].items;
                    if (skey && this.namereg[pkey].ikey[ikey] && this.namereg[pkey].ikey[ikey].skey[skey]) {
                        myitems = this.namereg[pkey].ikey[ikey].skey[skey].items;
                        posB = myitems.indexOf("" + id);
                        if (posB > -1) {
                            this.namereg[pkey].ikey[ikey].skey[skey].items = myitems.slice(0, posB).concat(myitems.slice([(posB + 1)]));
                        }
                        if (this.namereg[pkey].ikey[ikey].skey[skey].items.length === 1) {
                            this.namereg[pkey].ikey[ikey].items.push(this.namereg[pkey].ikey[ikey].skey[skey].items[0]);
                            this.namereg[pkey].ikey[ikey].skey[skey].items = [];
                        }
                        for (ppos = 0, llen = this.namereg[pkey].ikey[ikey].skey[skey].items.length; ppos < llen; ppos += 1) {
                            ret[this.namereg[pkey].ikey[ikey].items[ppos]] = true;
                        }
                    }
                    if (ikey && this.namereg[pkey].ikey[ikey]) {
                        posB = this.namereg[pkey].ikey[ikey].items.indexOf("" + id);
                        if (posB > -1) {
                            items = this.namereg[pkey].ikey[ikey].items.slice();
                            this.namereg[pkey].ikey[ikey].items = items.slice(0, posB).concat(items.slice([posB + 1]));
                        }
                        if (this.namereg[pkey].ikey[ikey].items.length === 1) {
                            this.namereg[pkey].items.push(this.namereg[pkey].ikey[ikey].items[0]);
                            this.namereg[pkey].ikey[ikey].items = [];
                        }
                        for (ppos = 0, llen = this.namereg[pkey].ikey[ikey].items.length; ppos < llen; ppos += 1) {
                            ret[this.namereg[pkey].ikey[ikey].items[ppos]] = true;
                        }
                    }
                    if (pkey) {
                        posB = this.namereg[pkey].items.indexOf("" + id);
                        if (posB > -1) {
                            items = this.namereg[pkey].items.slice();
                            this.namereg[pkey].items = items.slice(0, posB).concat(items.slice([posB + 1], items.length));
                        }
                        for (ppos = 0, llen = this.namereg[pkey].items.length; ppos < llen; ppos += 1) {
                            ret[this.namereg[pkey].items[ppos]] = true;
                        }
                        if (this.namereg[pkey].items.length < 2) {
                            delete this.namereg[pkey];
                        }
                    }
                    delete this.nameind[id][fullkey];
                }
            }
            delete this.nameind[id];
            delete this.nameindpkeys[id];
        }
        return ret;
    };
    addname = function (item_id, nameobj, pos) {
        var res = state.nameOutput.getName(nameobj, "locale-translit", true);
        nameobj = res.name;
        if (state.opt["givenname-disambiguation-rule"]
            && state.opt["givenname-disambiguation-rule"].slice(0, 8) === "primary-"
            && pos !== 0) {
                return;
        }
        set_keys(this.state, "" + item_id, nameobj);
        if (pkey) {
            if ("undefined" === typeof this.namereg[pkey]) {
                this.namereg[pkey] = {};
                this.namereg[pkey].count = 0;
                this.namereg[pkey].ikey = {};
                this.namereg[pkey].items = [];
            }
        }
        if (pkey && ikey) {
            if ("undefined" === typeof this.namereg[pkey].ikey[ikey]) {
                this.namereg[pkey].ikey[ikey] = {};
                this.namereg[pkey].ikey[ikey].count = 0;
                this.namereg[pkey].ikey[ikey].skey = {};
                this.namereg[pkey].ikey[ikey].items = [];
                this.namereg[pkey].count += 1;
            }
        }
        if (pkey && ikey && skey) {
            if ("undefined" === typeof this.namereg[pkey].ikey[ikey].skey[skey]) {
                this.namereg[pkey].ikey[ikey].skey[skey] = {};
                this.namereg[pkey].ikey[ikey].skey[skey].items = [];
                this.namereg[pkey].ikey[ikey].count += 1;
            }
        }
        if ("undefined" === typeof this.nameind[item_id]) {
            this.nameind[item_id] = {};
            this.nameindpkeys[item_id] = {};
        }
        if (pkey) {
            this.nameind[item_id][pkey + "::" + ikey + "::" + skey] = true;
            this.nameindpkeys[item_id][pkey] = this.namereg[pkey];
        }
    };
    this.addname = addname;
    this.delitems = delitems;
    this.evalname = evalname;
};
CSL.Disambiguation = function (state) {
    this.state = state;
    this.sys = this.state.sys;
    this.registry = state.registry.registry;
    this.ambigcites = state.registry.ambigcites;
    this.configModes();
    this.debug = false;
};
CSL.Disambiguation.prototype.run = function(akey) {
    if (!this.modes.length) {
        return;
    }
    this.initVars(akey);
    this.runDisambig();
};
CSL.Disambiguation.prototype.runDisambig = function () {
    var pos, len, ppos, llen, pppos, lllen, ismax;
    this.initGivens = true;
    for (pos = 0; pos < this.lists.length; pos += 1) {
        this.gnameset = 0;
        this.gname = 0;
        this.clashes = [1, 0];
        while(this.lists[pos][1].length) {
            this.listpos = pos;
            if (!this.base) {
                this.base = this.lists[pos][0];
            }
            var names_used = [];
            var ismax = this.incrementDisambig();
            this.scanItems(this.lists[pos]);
            this.evalScan(ismax);
        }
    }
};
CSL.Disambiguation.prototype.scanItems = function (list) {
    var pos, len, Item, otherItem, ItemCite, ignore, base;
    this.Item = list[1][0];
    this.ItemCite = CSL.getAmbiguousCite.call(this.state, this.Item, this.base);
    this.scanlist = list[1];
    this.partners = [];
    this.partners.push(this.Item);
    this.nonpartners = [];
    var clashes = 0;
    for (pos = 1, len = list[1].length; pos < len; pos += 1) {
        otherItem = list[1][pos];
        var otherItemCite = CSL.getAmbiguousCite.call(this.state, otherItem, this.base);
        if (this.ItemCite === otherItemCite) {
            clashes += 1;
            this.partners.push(otherItem);
        } else {
            this.nonpartners.push(otherItem);
        }
    }
    this.clashes[0] = this.clashes[1];
    this.clashes[1] = clashes;
};
CSL.Disambiguation.prototype.evalScan = function (maxed) {
    this[this.modes[this.modeindex]](maxed);
    if (maxed) {
        if (this.modeindex < this.modes.length - 1) {
            this.modeindex += 1;
        } else {
            this.lists[this.listpos + 1] = [this.base, []];
        }
    }
};
CSL.Disambiguation.prototype.disNames = function (ismax) {
    var pos, len, mybase;
    if (this.clashes[1] === 0 && this.nonpartners.length === 1) {
        this.captureStepToBase();
        this.state.registry.registerAmbigToken(this.akey, "" + this.nonpartners[0].id, this.betterbase);
        this.state.registry.registerAmbigToken(this.akey, "" + this.partners[0].id, this.betterbase);
        this.lists[this.listpos] = [this.betterbase, []];
    } else if (this.clashes[1] === 0) {
        this.captureStepToBase();
        this.state.registry.registerAmbigToken(this.akey, "" + this.partners[0].id, this.betterbase);
        this.lists[this.listpos] = [this.betterbase, this.nonpartners];
        if (this.nonpartners.length) {
            this.initGivens = true;
        }
    } else if (this.nonpartners.length === 1) {
        this.captureStepToBase();
        this.state.registry.registerAmbigToken(this.akey, "" + this.nonpartners[0].id, this.betterbase);
        this.lists[this.listpos] = [this.betterbase, this.partners];
    } else if (this.clashes[1] < this.clashes[0]) {
        this.captureStepToBase();
        this.lists[this.listpos] = [this.betterbase, this.partners];
        this.lists.push([this.betterbase, this.nonpartners])
    } else {
        if (ismax) {
            this.lists[this.listpos] = [this.betterbase, this.nonpartners];
            this.lists.push([this.betterbase, this.partners]);
            if (this.modeindex === this.modes.length - 1) {
                for (var i = 0, ilen = this.partners.length; i < ilen; i += 1) {
                    this.state.registry.registerAmbigToken(this.akey, "" + this.partners[i].id, this.betterbase);
                }
                this.lists[this.listpos] = [this.betterbase, []];
            }
        }
    }
};
CSL.Disambiguation.prototype.disExtraText = function () {
    var pos, len, mybase;
    if (this.modes.length > 1 && !this.base.disambiguate) {
        this.modeindex = 0;
        this.base = CSL.cloneAmbigConfig(this.betterbase);
    }
    if (!this.betterbase.disambiguate) {
        this.base.disambiguate = true;
        this.betterbase.disambiguate = true;
        this.initGivens = true;
    } else {
        if (this.modeindex === this.modes.length - 1) {
            var base = this.lists[this.listpos][0];
            for (var i = 0, ilen = this.lists[this.listpos][1].length; i < ilen; i += 1) {
                this.state.registry.registerAmbigToken(this.akey, "" + this.lists[this.listpos][1][i].id, base);
            }
            this.lists[this.listpos] = [this.betterbase, []];
        }
    }
};
CSL.Disambiguation.prototype.disYears = function () {
    var pos, len, tokens, token, item;
    tokens = [];
    var base = this.lists[this.listpos][0];
    if (this.clashes[1]) {
        for (pos = 0, len = this.lists[this.listpos][1].length; pos < len; pos += 1) {
            token = this.registry[this.lists[this.listpos][1][pos].id];
            tokens.push(token);
        }
    }
    tokens.sort(this.state.registry.sorter.compareKeys);
    for (pos = 0, len = tokens.length; pos < len; pos += 1) {
        base.year_suffix = ""+pos;
        var oldBase = this.state.registry.registry[tokens[pos].id].disambig;
        this.state.registry.registerAmbigToken(this.akey, "" + tokens[pos].id, base);
        if (CSL.ambigConfigDiff(oldBase,base)) {
            this.state.tmp.taintedItemIDs[tokens[pos].id] = true;
        }
    }
    this.lists[this.listpos] = [this.betterbase, []];
};
CSL.Disambiguation.prototype.incrementDisambig = function () {
    var val;
    if (this.initGivens) {
        this.initGivens = false;
        return false;
    }
    maxed = false;
    increment_names = true;
    increment_givens = true;
    if ("disNames" === this.modes[this.modeindex]) {
        increment_names = false;
        if ("number" !== typeof this.givensMax) {
            increment_names = true;
        }
        var increment_namesets = false;
        if ("number" !== typeof this.namesMax) {
            increment_namesets = true;
        }
        if ("number" === typeof this.givensMax) {
            if (this.base.givens[this.gnameset][this.gname] < this.givensMax) {
                this.base.givens[this.gnameset][this.gname] += 1;
            } else {
                var increment_names = true;
            }
        }
        if ("number" === typeof this.namesMax && increment_names) {
            increment_namesets = false;
            if (this.base.names[this.gnameset] < this.namesMax) {
                this.base.names[this.gnameset] += 1;
                this.gname += 1;
            } else {
                var increment_namesets = true;
            }
        }
        if ("number" === typeof this.namesetsMax && increment_namesets) {
            if (this.gnameset < this.namesetsMax) {
                this.gnameset += 1;
                this.base.names[this.gnameset] = 1;
                this.gname = 0;
            } else {
                var increment_mode = true;
            }
        }
        if (("number" !== typeof this.namesetsMax || this.namesetsMax === -1 || this.gnameset === this.namesetsMax)
            && ("number" !== typeof this.namesMax || this.base.names[this.gnameset] === this.namesMax)
            && ("number" != typeof this.givensMax || "undefined" === typeof this.base.givens[this.gnameset][this.gname] || this.base.givens[this.gnameset][this.gname] === this.givensMax)) {
            maxed = true;
        }
    }
    if ("disYears" === this.modes[this.modeindex]) {
    }
    return maxed;
};
CSL.Disambiguation.prototype.initVars = function (akey) {
    var i, ilen, myIds, myItemBundles, myItems;
    this.lists = [];
    this.base = false;
    this.betterbase = false;
    this.akey = akey;
    this.maxNamesByItemId = {};
    myItemBundles = [];
    myIds = this.ambigcites[akey];
    var Item = false;
    var myItem = this.state.retrieveItem("" + myIds[0]);
    this.getCiteData(myItem);
    this.base = CSL.getAmbigConfig.call(this.state);
    if (myIds && myIds.length > 1) {
        myItemBundles.push([this.maxNamesByItemId[myItem.id], myItem]);
        for (i = 1, ilen = myIds.length; i < ilen; i += 1) {
            myItem = this.state.retrieveItem("" + myIds[i]);
            this.getCiteData(myItem, this.base);
            myItemBundles.push([this.maxNamesByItemId[myItem.id], myItem]);
        }
        myItemBundles.sort(
            function (a, b) {
                if (a[0] > b[0]) {
                    return 1;
                } else if (a[0] < b[0]) {
                    return -1;
                } else {
                    if (a[1].id > b[1].id) {
                        return 1;
                    } else if (a[1].id < b[1].id) {
                        return -1;
                    } else {
                        return 0;
                    }
                }
            }
        );
        myItems = [];
        for (i = 0, ilen = myItemBundles.length; i < ilen; i += 1) {
            myItems.push(myItemBundles[i][1]);
        }
        this.lists.push([this.base, myItems]);
        this.Item = this.lists[0][1][0];
    } else {
        this.Item = this.state.retrieveItem("" + myIds[0]);
    }
    this.modeindex = 0;
    this.namesMax = this.maxNamesByItemId[this.Item.id][0];
    for (var i = 0, ilen = this.base.givens.length; i < ilen; i += 1) {
        for (var j = 0, jlen = this.namesMax; j < jlen; j += 1) {
            if (!this.base.givens[i][j]) {
                this.base.givens[i][j] = 0;
                this.betterbase.givens[i][j] = 0;
            }
        }
    }
    this.base.year_suffix = false;
    this.base.disambiguate = false;
    this.betterbase.year_suffix = false;
    this.betterbase.disambiguate = false;
    if (this.state.opt["givenname-disambiguation-rule"] === "by-cite") {
        this.givensMax = 2;
    }
};
CSL.Disambiguation.prototype.configModes = function () {
    var dagopt, gdropt;
    this.modes = [];
    dagopt = this.state.opt["disambiguate-add-givenname"];
    gdropt = this.state.opt["givenname-disambiguation-rule"];
    if (this.state.opt['disambiguate-add-names'] || (dagopt && gdropt === "by-cite")) {
        this.modes.push("disNames");
    }
    if (this.state.opt.has_disambiguate) {
        this.modes.push("disExtraText");
    }
    if (this.state.opt["disambiguate-add-year-suffix"]) {
        this.modes.push("disYears");
    }
};
CSL.Disambiguation.prototype.getCiteData = function(Item, base) {
    if (!this.maxNamesByItemId[Item.id]) {
        CSL.getAmbiguousCite.call(this.state, Item, base);
        base = CSL.getAmbigConfig.call(this.state);
        this.maxNamesByItemId[Item.id] = CSL.getMaxVals.call(this.state);
        this.state.registry.registry[Item.id].disambig.givens = this.state.tmp.disambig_settings.givens.slice();
        this.namesetsMax = this.state.registry.registry[Item.id].disambig.names.length - 1;
        if (!this.base) {
            this.base = base;
            this.betterbase = CSL.cloneAmbigConfig(base);
        }
        if (base.names.length < this.base.names.length) {
            this.base = base;
        }
        var update = false;
        for (var i = 0, ilen = base.names.length; i < ilen; i += 1) {
            if (base.names[i] > this.base.names[i]) {
                this.base.givens[i] = this.base.givens[i].concat(this.base.givens[i].slice(this.base.names[i]));
                this.base.names[i] = base.names[i];
                this.betterbase.names = this.base.names.slice();
            }
        }
        this.betterbase.givens = this.base.givens.slice();
        for (var j = 0, jlen = this.base.givens.length; j < jlen; j += 1) {
            this.betterbase.givens[j] = this.base.givens[j].slice();
        }
    }
};
CSL.Disambiguation.prototype.captureStepToBase = function() {
    if (this.state.opt["givenname-disambiguation-rule"] === "by-cite") {
        this.betterbase.givens[this.gnameset][this.gname] = this.base.givens[this.gnameset][this.gname];
    }
    this.betterbase.names[this.gnameset] = this.base.names[this.gnameset];
};
CSL.Registry.CitationReg = function (state) {
    this.citationById = {};
    this.citationByIndex = [];
};
CSL.Node.generate = {
    build: function (state, target) {
        if (state.build.area === "bibliography") {
            var obj = this.generate_type_map;
            obj.triggers = this.generate_trigger_fields;
            state.registry.generate.rules.push(obj);
        }
    }
};

define("external/citeproc/citeproc", ["external/citeproc/xmldom","src/citeprocLoadSys"], (function (global) {
    return function () {
        return global.CSL;
    }
}(this)));



define('src/citationEngine',[	'src/storage',
			'src/options',
			'src/cslData',
			'src/exampleCitations',
			'src/diff',
			'src/debug',
			'external/citeproc/citeproc',
			'src/citeprocLoadSys'
		],
		function (
			CSLEDIT_storage,
			CSLEDIT_options,
			CSLEDIT_data,
			CSLEDIT_exampleCitations,
			CSLEDIT_diff,
			debug,
			CSL,
			citeprocSys
		) {
	var oldFormattedCitation = "",
		newFormattedCitation = "",
		oldFormattedBibliography = "",
		newFormattedBibliography = "",
		diffTimeout,
		dmp = null, // for diff_match_patch object
		previousStyle = "", // to skip initializing citeproc when using the same style
		citeproc;

	var stripTags = function (html, tag) {
		var stripRegExp = new RegExp("<" + tag + ".*?>|</\s*" + tag + "\s*?\>", "g");

		// creating new string because of bug where some html from generateExampleCitations.js
		// was type object instead of string and didn't have the replace() function
		var stripped = new String(html);
		stripped = stripped.replace(stripRegExp, "");
		return stripped;
	};

	var formatCitations = function (style, documents, citationClusters, taggedOutput) {
		var bibliography,
			result,
			citations,
			cluster,
			inLineCitations,
			inLineCitationArray,
			i,
			pos,
			makeBibliographyArgument,
			hangingindent,
			has_bibliography,
			index,
			enumerateCitations;

		citeprocSys.setJsonDocuments(documents);

		result = { "statusMessage":"", "formattedCitations":[], "formattedBibliography": [] };
		result.statusMessage = "";
		if (style !== previousStyle) {
			try
			{
				citeproc = new CSL.Engine(citeprocSys, style);
				citeproc.opt.development_extensions.csl_reverse_lookup_support = true;
				previousStyle = style;
			}
			catch(err)
			{
				result.statusMessage = "Citeproc initialisation exception: " + err;
				return result;
			}
		} else {
			citeproc.restoreProcessorState([]);
		}
		
		inLineCitations = "";
		inLineCitationArray = new Array();
		
		for (cluster=0; cluster<citationClusters.length; cluster++)
		{
			try
			{
				citations = citeproc.appendCitationCluster(citationClusters[cluster],false);
			}
			catch(err)
			{
				result.statusMessage = "Citeproc exception: " + err;
				return result;
			}
			
			for (i = 0; i < citations.length; i++)
			{
				pos = citations[i][0];
				
				if (inLineCitations != "")
				{
					inLineCitations += "<br>";
				}
				
				if (taggedOutput !== true) {
					citations[i][1] = stripTags(citations[i][1], "span");
				}

				inLineCitations += citations[i][1];

				if (citations[i][1] !== "") {
					inLineCitationArray.push(citations[i][1]);
				}
			}
		}
		result.formattedCitations = inLineCitationArray;
		
		enumerateCitations = true;
		if (enumerateCitations === true) {
			makeBibliographyArgument = undefined;
		}
		else {
			makeBibliographyArgument = "citation-number";
		}
		
		try
		{
			bibliography = citeproc.makeBibliography(makeBibliographyArgument);
		}
		catch(err)
		{
			result.statusMessage = "Citeproc exception: " + err;
			return result;
		}

		hangingindent = false;
		has_bibliography = (bibliography !== false);

		if (has_bibliography)
		{
			hangingindent = (bibliography[0].hangingindent != 0 && "undefined" !== typeof(bibliography[0].hangingindent));
			bibliography = bibliography[1];
		}
		else
		{
			bibliography = [[(citations[0][1])]];
		}

		if (taggedOutput !== true) {
			for (index = 0; index < bibliography.length; index++) {
				bibliography[index] = stripTags(bibliography[index], "span");
			}
		}

		result.formattedBibliography = bibliography;
		return result;
	};

	var runCiteprocAndDisplayOutput = function (
			statusOut, exampleOut, citationsOut, bibliographyOut, callback) {

		console.time("runCiteprocAndDisplayOutput");

		var style = CSLEDIT_data.getCslCode(),
			inLineCitations = "",
			citations = [],
			formattedResult,
			citationTagStart = "<p>",
			citationTagEnd = "</p>",
			bibliographyTagStart = "<p>",
			bibliographyTagEnd = "</p>",
			startTime,
			citationDiffs,
			bibliographyDiffs,
			diffFormattedCitation,
			diffFormattedBibliography,
			cslData = CSLEDIT_data.get(),
			citationNode = CSLEDIT_data.getNodesFromPath("style/citation/layout", cslData),
			bibliographyNode = CSLEDIT_data.getNodesFromPath("style/bibliography/layout", cslData);

		statusOut.html("<i>Re-formatting citations...</i>");
	
		console.time("formatCitations");

		formattedResult = formatCitations(
			style, CSLEDIT_exampleCitations.getCiteprocReferences(), CSLEDIT_exampleCitations.getCitations(), true);
		
		console.timeEnd("formatCitations");

		statusOut.html(formattedResult.statusMessage);

		// add syntax highlighting at highest level
		if (citationNode.length > 0) {
			citationTagStart = '<p><span cslid="' + citationNode[0].cslId + '">';
			citationTagEnd = '</span></p>';
		}
		if (bibliographyNode.length > 0) {
			bibliographyTagStart = '<p><span cslid="' + bibliographyNode[0].cslId + '">';
			bibliographyTagEnd = '</span></p>';
		}

		oldFormattedCitation = newFormattedCitation;
		newFormattedCitation = citationTagStart;
		newFormattedCitation += formattedResult.formattedCitations.join(
			citationTagEnd + citationTagStart);
		newFormattedCitation += citationTagEnd;

		oldFormattedBibliography = newFormattedBibliography;
		newFormattedBibliography = bibliographyTagStart;
		newFormattedBibliography += formattedResult.formattedBibliography.join(
			bibliographyTagEnd + bibliographyTagStart);
		newFormattedBibliography += bibliographyTagEnd;

		if (newFormattedBibliography.indexOf("<second-field-align>") > -1) {
			exampleOut.css({
				// TODO: don't change the whole output panel CSS, just the relevant lines
				"padding-left" : "3em",
				"text-indent" : "-2em"
			});
		} else {
			exampleOut.css({
				"padding-left" : "1em",
				"text-indent" : "0"
			});
		}

		// lazy instantiation of diff_match_patch
		if (dmp === null) {
			dmp = new diff_match_patch();
		}

		citationDiffs =
			dmp.diff_main(stripTags(oldFormattedCitation, "span"), stripTags(newFormattedCitation, "span"));
		dmp.diff_cleanupSemantic(citationDiffs);
		diffFormattedCitation = unescape(CSLEDIT_diff.prettyHtml(citationDiffs));

		bibliographyDiffs =
			dmp.diff_main(stripTags(oldFormattedBibliography, "span"), stripTags(newFormattedBibliography, "span"));
		dmp.diff_cleanupSemantic(bibliographyDiffs);
		diffFormattedBibliography = unescape(CSLEDIT_diff.prettyHtml(bibliographyDiffs));

		if (dmp.diff_levenshtein(citationDiffs) === 0 && dmp.diff_levenshtein(bibliographyDiffs) === 0) {
			citationsOut.html(newFormattedCitation);
			bibliographyOut.html(newFormattedBibliography);
			if (typeof callback !== "undefined") {
				callback();
			}
		} else {
			if (CSLEDIT_storage.getItem('CSLEDIT_options.visualEditorDiffs') === "true") {
				// display the diff
				citationsOut.html(diffFormattedCitation);
				bibliographyOut.html(diffFormattedBibliography);

				// display the new version in 1000ms
				clearTimeout(diffTimeout);
				diffTimeout = setTimeout(
					function () {
						citationsOut.html(newFormattedCitation);
						bibliographyOut.html(newFormattedBibliography);
						if (typeof callback !== "undefined") {
							callback();
						}
					},
				1000);
			} else {
				// display the real result
				citationsOut.html(newFormattedCitation);
				bibliographyOut.html(newFormattedBibliography);
				if (typeof callback !== "undefined") {
					callback();
				}
			}
		}
		
		console.timeEnd("runCiteprocAndDisplayOutput");
	}

	// Return public members:
	return {
		formatCitations : formatCitations,
		runCiteprocAndDisplayOutput : runCiteprocAndDisplayOutput
	};

});



define('src/cslStyles',['src/options', 'src/debug'], function (CSLEDIT_options, debug) {
	var cache = {};

	var getJSONData = function (path) {
		var url;
		if (!(path in cache)) {
			url = CSLEDIT_options.getUrl(path);
			$.ajax({
				url : url,
				dataType : "json",
				async : false,
				success : function (data) {
					console.log("fetched json: " + path);
					cache[path] = data;
				},
				error : function () {
					debug.log("WARNING: error fetching " + url);
				}
			});
		}
		return cache[path];
	};

	return {
		styles : function () {
			return getJSONData('generated/cslStyles.json');
		},
		exampleCitations : function () {
			return getJSONData('generated/preGeneratedExampleCitations.json');
		}
	};
});

/**
* hoverIntent r6 // 2011.02.26 // jQuery 1.5.1+
* <http://cherne.net/brian/resources/jquery.hoverIntent.html>
* 
* @param  f  onMouseOver function || An object with configuration options
* @param  g  onMouseOut function  || Nothing (use configuration options object)
* @author    Brian Cherne brian(at)cherne(dot)net
*/
(function($){$.fn.hoverIntent=function(f,g){var cfg={sensitivity:7,interval:100,timeout:0};cfg=$.extend(cfg,g?{over:f,out:g}:f);var cX,cY,pX,pY;var track=function(ev){cX=ev.pageX;cY=ev.pageY};var compare=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);if((Math.abs(pX-cX)+Math.abs(pY-cY))<cfg.sensitivity){$(ob).unbind("mousemove",track);ob.hoverIntent_s=1;return cfg.over.apply(ob,[ev])}else{pX=cX;pY=cY;ob.hoverIntent_t=setTimeout(function(){compare(ev,ob)},cfg.interval)}};var delay=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);ob.hoverIntent_s=0;return cfg.out.apply(ob,[ev])};var handleHover=function(e){var ev=jQuery.extend({},e);var ob=this;if(ob.hoverIntent_t){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t)}if(e.type=="mouseenter"){pX=ev.pageX;pY=ev.pageY;$(ob).bind("mousemove",track);if(ob.hoverIntent_s!=1){ob.hoverIntent_t=setTimeout(function(){compare(ev,ob)},cfg.interval)}}else{$(ob).unbind("mousemove",track);if(ob.hoverIntent_s==1){ob.hoverIntent_t=setTimeout(function(){delay(ev,ob)},cfg.timeout)}}};return this.bind('mouseenter',handleHover).bind('mouseleave',handleHover)}})(jQuery);
define("jquery.hoverIntent", ["jquery"], function(){});

/*
 jquery.layout 1.3.0 - Release Candidate 30.51
 $Date: 2012-05-12 08:00:00 (Sat, 12 May 2012) $
 $Rev: 303005 $

 Copyright (c) 2012 
   Fabrizio Balliano (http://www.fabrizioballiano.net)
   Kevin Dalman (http://allpro.net)

 Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.

 Changelog: http://layout.jquery-dev.net/changelog.cfm#1.3.0.rc30.5

 Docs: http://layout.jquery-dev.net/documentation.html
 Tips: http://layout.jquery-dev.net/tips.html
 Help: http://groups.google.com/group/jquery-ui-layout
*/
(function($){var min=Math.min,max=Math.max,round=Math.floor;function isStr(v){return $.type(v)==="string"}function runPluginCallbacks(Instance,a_fn){if($.isArray(a_fn))for(var i=0,c=a_fn.length;i<c;i++){var fn=a_fn[i];try{if(isStr(fn))fn=eval(fn);if($.isFunction(fn))fn(Instance)}catch(ex){}}}$.layout={version:"1.3.rc30.51",revision:0.033005,language:{Open:"Open",Close:"Close",Resize:"Resize",Slide:"Slide Open",Pin:"Pin",Unpin:"Un-Pin",noRoomToOpenTip:"Not enough room to show this pane.",minSizeWarning:"Panel has reached its minimum size",
maxSizeWarning:"Panel has reached its maximum size",pane:"pane",selector:"selector",errButton:"Error Adding Button \n\nInvalid ",errContainerMissing:"UI Layout Initialization Error\n\nThe specified layout-container does not exist.",errCenterPaneMissing:"UI Layout Initialization Error\n\nThe center-pane element does not exist.\n\nThe center-pane is a required element.",errContainerHeight:"UI Layout Initialization Warning\n\nThe layout-container \"CONTAINER\" has no height.\n\nTherefore the layout is 0-height and hence 'invisible'!"},
browser:{mozilla:!!$.browser.mozilla,webkit:!!$.browser.webkit||!!$.browser.safari,msie:!!$.browser.msie,isIE6:!!$.browser.msie&&$.browser.version==6,version:$.browser.version},effects:{slide:{all:{duration:"fast"},north:{direction:"up"},south:{direction:"down"},east:{direction:"right"},west:{direction:"left"}},drop:{all:{duration:"slow"},north:{direction:"up"},south:{direction:"down"},east:{direction:"right"},west:{direction:"left"}},scale:{all:{duration:"fast"}},blind:{},clip:{},explode:{},fade:{},
fold:{},puff:{},size:{all:{easing:"swing"}}},config:{optionRootKeys:"effects,panes,north,south,west,east,center".split(","),allPanes:"north,south,west,east,center".split(","),borderPanes:"north,south,west,east".split(","),oppositeEdge:{north:"south",south:"north",east:"west",west:"east"},offscreenCSS:{left:"-99999px",right:"auto"},offscreenReset:"offscreenReset",hidden:{visibility:"hidden"},visible:{visibility:"visible"},resizers:{cssReq:{position:"absolute",padding:0,margin:0,fontSize:"1px",textAlign:"left",
overflow:"hidden"},cssDemo:{background:"#DDD",border:"none"}},togglers:{cssReq:{position:"absolute",display:"block",padding:0,margin:0,overflow:"hidden",textAlign:"center",fontSize:"1px",cursor:"pointer",zIndex:1},cssDemo:{background:"#AAA"}},content:{cssReq:{position:"relative"},cssDemo:{overflow:"auto",padding:"10px"},cssDemoPane:{overflow:"hidden",padding:0}},panes:{cssReq:{position:"absolute",margin:0},cssDemo:{padding:"10px",background:"#FFF",border:"1px solid #BBB",overflow:"auto"}},north:{side:"Top",
sizeType:"Height",dir:"horz",cssReq:{top:0,bottom:"auto",left:0,right:0,width:"auto"}},south:{side:"Bottom",sizeType:"Height",dir:"horz",cssReq:{top:"auto",bottom:0,left:0,right:0,width:"auto"}},east:{side:"Right",sizeType:"Width",dir:"vert",cssReq:{left:"auto",right:0,top:"auto",bottom:"auto",height:"auto"}},west:{side:"Left",sizeType:"Width",dir:"vert",cssReq:{left:0,right:"auto",top:"auto",bottom:"auto",height:"auto"}},center:{dir:"center",cssReq:{left:"auto",right:"auto",top:"auto",bottom:"auto",
height:"auto",width:"auto"}}},callbacks:{},getParentPaneElem:function(el){var $el=$(el),layout=$el.data("layout")||$el.data("parentLayout");if(layout){var $cont=layout.container;if($cont.data("layoutPane"))return $cont;var $pane=$cont.closest("."+$.layout.defaults.panes.paneClass);if($pane.data("layoutPane"))return $pane}return null},getParentPaneInstance:function(el){var $pane=$.layout.getParentPaneElem(el);return $pane?$pane.data("layoutPane"):null},getParentLayoutInstance:function(el){var $pane=
$.layout.getParentPaneElem(el);return $pane?$pane.data("parentLayout"):null},getEventObject:function(evt){return typeof evt==="object"&&evt.stopPropagation?evt:null},parsePaneName:function(evt_or_pane){var evt=$.layout.getEventObject(evt_or_pane);if(evt){evt.stopPropagation();return $(this).data("layoutEdge")}else return evt_or_pane},plugins:{draggable:!!$.fn.draggable,effects:{core:!!$.effects,slide:$.effects&&$.effects.slide}},onCreate:[],onLoad:[],onReady:[],onDestroy:[],onUnload:[],afterOpen:[],
afterClose:[],scrollbarWidth:function(){return window.scrollbarWidth||$.layout.getScrollbarSize("width")},scrollbarHeight:function(){return window.scrollbarHeight||$.layout.getScrollbarSize("height")},getScrollbarSize:function(dim){var $c=$('<div style="position: absolute; top: -10000px; left: -10000px; width: 100px; height: 100px; overflow: scroll;"></div>').appendTo("body");var d={width:$c.width()-$c[0].clientWidth,height:$c.height()-$c[0].clientHeight};$c.remove();window.scrollbarWidth=d.width;
window.scrollbarHeight=d.height;return dim.match(/^(width|height)$/)?d[dim]:d},showInvisibly:function($E,force){if(!$E)return{};if(!$E.jquery)$E=$($E);var CSS={display:$E.css("display"),visibility:$E.css("visibility")};if(force||CSS.display==="none"){$E.css({display:"block",visibility:"hidden"});return CSS}else return{}},getElementDimensions:function($E){var d={},x=d.css={},i={},b,p,N=$.layout.cssNum,off=$E.offset();d.offsetLeft=off.left;d.offsetTop=off.top;$.each("Left,Right,Top,Bottom".split(","),
function(idx,e){b=x["border"+e]=$.layout.borderWidth($E,e);p=x["padding"+e]=$.layout.cssNum($E,"padding"+e);i[e]=b+p;d["inset"+e]=p});d.offsetWidth=$E.innerWidth();d.offsetHeight=$E.innerHeight();d.outerWidth=$E.outerWidth();d.outerHeight=$E.outerHeight();d.innerWidth=max(0,d.outerWidth-i.Left-i.Right);d.innerHeight=max(0,d.outerHeight-i.Top-i.Bottom);x.width=$E.width();x.height=$E.height();x.top=N($E,"top",true);x.bottom=N($E,"bottom",true);x.left=N($E,"left",true);x.right=N($E,"right",true);return d},
getElementCSS:function($E,list){var CSS={},style=$E[0].style,props=list.split(","),sides="Top,Bottom,Left,Right".split(","),attrs="Color,Style,Width".split(","),p,s,a,i,j,k;for(i=0;i<props.length;i++){p=props[i];if(p.match(/(border|padding|margin)$/))for(j=0;j<4;j++){s=sides[j];if(p==="border")for(k=0;k<3;k++){a=attrs[k];CSS[p+s+a]=style[p+s+a]}else CSS[p+s]=style[p+s]}else CSS[p]=style[p]}return CSS},cssWidth:function($E,outerWidth){var b=$.layout.borderWidth,n=$.layout.cssNum;if(outerWidth<=0)return 0;
if(!$.support.boxModel)return outerWidth;var W=outerWidth-b($E,"Left")-b($E,"Right")-n($E,"paddingLeft")-n($E,"paddingRight");return max(0,W)},cssHeight:function($E,outerHeight){var b=$.layout.borderWidth,n=$.layout.cssNum;if(outerHeight<=0)return 0;if(!$.support.boxModel)return outerHeight;var H=outerHeight-b($E,"Top")-b($E,"Bottom")-n($E,"paddingTop")-n($E,"paddingBottom");return max(0,H)},cssNum:function($E,prop,allowAuto){if(!$E.jquery)$E=$($E);var CSS=$.layout.showInvisibly($E),p=$.curCSS($E[0],
prop,true),v=allowAuto&&p=="auto"?p:parseInt(p,10)||0;$E.css(CSS);return v},borderWidth:function(el,side){if(el.jquery)el=el[0];var b="border"+side.substr(0,1).toUpperCase()+side.substr(1);return $.curCSS(el,b+"Style",true)==="none"?0:parseInt($.curCSS(el,b+"Width",true),10)||0},isMouseOverElem:function(evt,el){var $E=$(el||this),d=$E.offset(),T=d.top,L=d.left,R=L+$E.outerWidth(),B=T+$E.outerHeight(),x=evt.pageX,y=evt.pageY;return $.layout.browser.msie&&x<0&&y<0||x>=L&&x<=R&&y>=T&&y<=B},msg:function(info,
popup,debugTitle,debugOpts){if($.isPlainObject(info)&&window.debugData){if(typeof popup==="string"){debugOpts=debugTitle;debugTitle=popup}else if(typeof debugTitle==="object"){debugOpts=debugTitle;debugTitle=null}var t=debugTitle||"log( <object> )",o=$.extend({sort:false,returnHTML:false,display:false},debugOpts);if(popup===true||o.display)debugData(info,t,o);else if(window.console)console.log(debugData(info,t,o))}else if(popup)alert(info);else if(window.console)console.log(info);else{var id="#layoutLogger",
$l=$(id);if(!$l.length)$l=createLog();$l.children("ul").append('<li style="padding: 4px 10px; margin: 0; border-top: 1px solid #CCC;">'+info.replace(/\</g,"&lt;").replace(/\>/g,"&gt;")+"</li>")}function createLog(){var pos=$.support.fixedPosition?"fixed":"absolute",$e=$('<div id="layoutLogger" style="position: '+pos+'; top: 5px; z-index: 999999; max-width: 25%; overflow: hidden; border: 1px solid #000; border-radius: 5px; background: #FBFBFB; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">'+'<div style="font-size: 13px; font-weight: bold; padding: 5px 10px; background: #F6F6F6; border-radius: 5px 5px 0 0; cursor: move;">'+
'<span style="float: right; padding-left: 7px; cursor: pointer;" title="Remove Console" onclick="$(this).closest(\'#layoutLogger\').remove()">X</span>Layout console.log</div>'+'<ul style="font-size: 13px; font-weight: none; list-style: none; margin: 0; padding: 0 0 2px;"></ul>'+"</div>").appendTo("body");$e.css("left",$(window).width()-$e.outerWidth()-5);if($.ui.draggable)$e.draggable({handle:":first-child"});return $e}}};var lang=$.layout.language;$.layout.defaults={name:"",containerSelector:"",
containerClass:"ui-layout-container",scrollToBookmarkOnLoad:true,resizeWithWindow:true,resizeWithWindowDelay:200,resizeWithWindowMaxDelay:0,onresizeall_start:null,onresizeall_end:null,onload_start:null,onload_end:null,onunload_start:null,onunload_end:null,autoBindCustomButtons:false,initPanes:true,showErrorMessages:true,showDebugMessages:false,zIndex:null,zIndexes:{pane_normal:0,content_mask:1,resizer_normal:2,pane_sliding:100,pane_animate:1E3,resizer_drag:1E4},panes:{applyDemoStyles:false,closable:true,
resizable:true,slidable:true,initClosed:false,initHidden:false,contentSelector:".ui-layout-content",contentIgnoreSelector:".ui-layout-ignore",findNestedContent:false,paneClass:"ui-layout-pane",resizerClass:"ui-layout-resizer",togglerClass:"ui-layout-toggler",buttonClass:"ui-layout-button",minSize:0,maxSize:0,spacing_open:6,spacing_closed:6,togglerLength_open:50,togglerLength_closed:50,togglerAlign_open:"center",togglerAlign_closed:"center",togglerTip_open:lang.Close,togglerTip_closed:lang.Open,togglerContent_open:"",
togglerContent_closed:"",resizerDblClickToggle:true,autoResize:true,autoReopen:true,resizerDragOpacity:1,maskContents:false,maskObjects:false,maskZindex:null,resizingGrid:false,livePaneResizing:false,liveContentResizing:false,liveResizingTolerance:1,noRoomToOpenTip:lang.noRoomToOpenTip,resizerTip:lang.Resize,sliderTip:lang.Slide,sliderCursor:"pointer",slideTrigger_open:"click",slideTrigger_close:"mouseleave",slideDelay_open:300,slideDelay_close:300,hideTogglerOnSlide:false,preventQuickSlideClose:$.layout.browser.webkit,
preventPrematureSlideClose:false,showOverflowOnHover:false,enableCursorHotkey:true,customHotkeyModifier:"SHIFT",fxName:"slide",fxSpeed:null,fxSettings:{},fxOpacityFix:true,animatePaneSizing:false,childOptions:null,initChildLayout:true,destroyChildLayout:true,resizeChildLayout:true,triggerEventsOnLoad:false,triggerEventsDuringLiveResize:true,onshow_start:null,onshow_end:null,onhide_start:null,onhide_end:null,onopen_start:null,onopen_end:null,onclose_start:null,onclose_end:null,onresize_start:null,
onresize_end:null,onsizecontent_start:null,onsizecontent_end:null,onswap_start:null,onswap_end:null,ondrag_start:null,ondrag_end:null},north:{paneSelector:".ui-layout-north",size:"auto",resizerCursor:"n-resize",customHotkey:""},south:{paneSelector:".ui-layout-south",size:"auto",resizerCursor:"s-resize",customHotkey:""},east:{paneSelector:".ui-layout-east",size:200,resizerCursor:"e-resize",customHotkey:""},west:{paneSelector:".ui-layout-west",size:200,resizerCursor:"w-resize",customHotkey:""},center:{paneSelector:".ui-layout-center",
minWidth:0,minHeight:0}};$.layout.optionsMap={layout:("stateManagement,effects,zIndexes,"+"name,zIndex,scrollToBookmarkOnLoad,showErrorMessages,"+"resizeWithWindow,resizeWithWindowDelay,resizeWithWindowMaxDelay,"+"onresizeall,onresizeall_start,onresizeall_end,onload,onunload,autoBindCustomButtons").split(","),center:("paneClass,contentSelector,contentIgnoreSelector,findNestedContent,applyDemoStyles,triggerEventsOnLoad,"+"showOverflowOnHover,maskContents,maskObjects,liveContentResizing,"+"childOptions,initChildLayout,resizeChildLayout,destroyChildLayout,"+
"onresize,onresize_start,onresize_end,onsizecontent,onsizecontent_start,onsizecontent_end").split(","),noDefault:"paneSelector,resizerCursor,customHotkey".split(",")};$.layout.transformData=function(hash){var json={panes:{},center:{}},data,branch,optKey,keys,key,val,i,c;if(typeof hash!=="object")return json;for(optKey in hash){branch=json;data=$.layout.optionsMap.layout;val=hash[optKey];keys=optKey.split("__");c=keys.length-1;for(i=0;i<=c;i++){key=keys[i];if(i===c)branch[key]=val;else if(!branch[key])branch[key]=
{};branch=branch[key]}}return json};$.layout.backwardCompatibility={map:{applyDefaultStyles:"applyDemoStyles",resizeNestedLayout:"resizeChildLayout",resizeWhileDragging:"livePaneResizing",resizeContentWhileDragging:"liveContentResizing",triggerEventsWhileDragging:"triggerEventsDuringLiveResize",maskIframesOnResize:"maskContents",useStateCookie:"stateManagement.enabled","cookie.autoLoad":"stateManagement.autoLoad","cookie.autoSave":"stateManagement.autoSave","cookie.keys":"stateManagement.stateKeys",
"cookie.name":"stateManagement.cookie.name","cookie.domain":"stateManagement.cookie.domain","cookie.path":"stateManagement.cookie.path","cookie.expires":"stateManagement.cookie.expires","cookie.secure":"stateManagement.cookie.secure"},renameOptions:function(opts){var map=$.layout.backwardCompatibility.map,oldData,newData,value;for(var itemPath in map){oldData=getBranch(itemPath);value=oldData.branch[oldData.key];if(value!==undefined){newData=getBranch(map[itemPath],true);newData.branch[newData.key]=
value;delete oldData.branch[oldData.key]}}function getBranch(path,create){var a=path.split("."),c=a.length-1,D={branch:opts,key:a[c]},i=0,k,undef;for(;i<c;i++){k=a[i];if(D.branch[k]==undefined)if(create)D.branch=D.branch[k]={};else D.branch={};else D.branch=D.branch[k]}return D}},renameAllOptions:function(opts){var ren=$.layout.backwardCompatibility.renameOptions;ren(opts);if(opts.defaults){if(typeof opts.panes!=="object")opts.panes={};$.extend(true,opts.panes,opts.defaults);delete opts.defaults}if(opts.panes)ren(opts.panes);
$.each($.layout.config.allPanes,function(i,pane){if(opts[pane])ren(opts[pane])});return opts}};$.fn.layout=function(opts){var browser=$.layout.browser,lang=$.layout.language,_c=$.layout.config,cssW=$.layout.cssWidth,cssH=$.layout.cssHeight,elDims=$.layout.getElementDimensions,elCSS=$.layout.getElementCSS,evtObj=$.layout.getEventObject,evtPane=$.layout.parsePaneName,options=$.extend(true,{},$.layout.defaults),effects=options.effects=$.extend(true,{},$.layout.effects),state={id:"layout"+$.now(),initialized:false,
container:{},north:{},south:{},east:{},west:{},center:{}},children={north:null,south:null,east:null,west:null,center:null},timer={data:{},set:function(s,fn,ms){timer.clear(s);timer.data[s]=setTimeout(fn,ms)},clear:function(s){var t=timer.data;if(t[s]){clearTimeout(t[s]);delete t[s]}}},_log=function(msg,popup){$.layout.msg(options.name+" / "+msg,popup&&options.showErrorMessages)},_runCallbacks=function(evtName,pane,skipBoundEvents){var o=pane?options[pane]:options,lng=evtName+(evtName.match(/_/)?"":
"_end"),shrt=lng.match(/_end$/)?lng.substr(0,lng.length-4):"",fn=o[lng],retVal="NC",args=[];if(!fn&&shrt)fn=o[shrt];if(fn){if(isStr(fn))if(fn.match(/,/))args=fn.split(","),fn=eval(args[0]);else fn=eval(fn);if($.isFunction(fn))if(args.length)retVal=fn(args[1]);else if(pane&&$Ps[pane])retVal=fn(pane,$Ps[pane],state[pane],options[pane],options.name);else retVal=fn(Instance,state,options,options.name)}if(!skipBoundEvents&&retVal!==false)if(pane){$Ps[pane].triggerHandler("layoutpane"+lng,[pane,$Ps[pane],
state[pane],options[pane],options.name]);if(shrt)$Ps[pane].triggerHandler("layoutpane"+shrt,[pane,$Ps[pane],state[pane],options[pane],options.name])}else $N.triggerHandler("layout"+lng,[pane,$Ps[pane],state[pane],options[pane],options.name]);if(evtName==="onresize_end"||evtName==="onsizecontent_end")resizeChildLayout(pane);return retVal},_fixIframe=function(pane){if(browser.mozilla)return;var $P=$Ps[pane];if(state[pane].tagName==="IFRAME")$P.css(_c.hidden).css(_c.visible);else $P.find("IFRAME").css(_c.hidden).css(_c.visible)},
cssSize=function(pane,outerSize){var fn=_c[pane].dir=="horz"?cssH:cssW;return fn($Ps[pane],outerSize)},cssMinDims=function(pane){var $P=$Ps[pane],dir=_c[pane].dir,d={minWidth:1001-cssW($P,1E3),minHeight:1001-cssH($P,1E3)};if(dir==="horz")d.minSize=d.minHeight;if(dir==="vert")d.minSize=d.minWidth;return d},setOuterWidth=function(el,outerWidth,autoHide){var $E=el,w;if(isStr(el))$E=$Ps[el];else if(!el.jquery)$E=$(el);w=cssW($E,outerWidth);$E.css({width:w});if(w>0){if(autoHide&&$E.data("autoHidden")&&
$E.innerHeight()>0){$E.show().data("autoHidden",false);if(!browser.mozilla)$E.css(_c.hidden).css(_c.visible)}}else if(autoHide&&!$E.data("autoHidden"))$E.hide().data("autoHidden",true)},setOuterHeight=function(el,outerHeight,autoHide){var $E=el,h;if(isStr(el))$E=$Ps[el];else if(!el.jquery)$E=$(el);h=cssH($E,outerHeight);$E.css({height:h,visibility:"visible"});if(h>0&&$E.innerWidth()>0){if(autoHide&&$E.data("autoHidden")){$E.show().data("autoHidden",false);if(!browser.mozilla)$E.css(_c.hidden).css(_c.visible)}}else if(autoHide&&
!$E.data("autoHidden"))$E.hide().data("autoHidden",true)},setOuterSize=function(el,outerSize,autoHide){if(_c[pane].dir=="horz")setOuterHeight(el,outerSize,autoHide);else setOuterWidth(el,outerSize,autoHide)},_parseSize=function(pane,size,dir){if(!dir)dir=_c[pane].dir;if(isStr(size)&&size.match(/%/))size=size==="100%"?-1:parseInt(size,10)/100;if(size===0)return 0;else if(size>=1)return parseInt(size,10);var o=options,avail=0;if(dir=="horz")avail=sC.innerHeight-($Ps.north?o.north.spacing_open:0)-($Ps.south?
o.south.spacing_open:0);else if(dir=="vert")avail=sC.innerWidth-($Ps.west?o.west.spacing_open:0)-($Ps.east?o.east.spacing_open:0);if(size===-1)return avail;else if(size>0)return round(avail*size);else if(pane=="center")return 0;else{var dim=dir==="horz"?"height":"width",$P=$Ps[pane],$C=dim==="height"?$Cs[pane]:false,vis=$.layout.showInvisibly($P),szP=$P.css(dim),szC=$C?$C.css(dim):0;$P.css(dim,"auto");if($C)$C.css(dim,"auto");size=dim==="height"?$P.outerHeight():$P.outerWidth();$P.css(dim,szP).css(vis);
if($C)$C.css(dim,szC);return size}},getPaneSize=function(pane,inclSpace){var $P=$Ps[pane],o=options[pane],s=state[pane],oSp=inclSpace?o.spacing_open:0,cSp=inclSpace?o.spacing_closed:0;if(!$P||s.isHidden)return 0;else if(s.isClosed||s.isSliding&&inclSpace)return cSp;else if(_c[pane].dir==="horz")return $P.outerHeight()+oSp;else return $P.outerWidth()+oSp},setSizeLimits=function(pane,slide){if(!isInitialized())return;var o=options[pane],s=state[pane],c=_c[pane],dir=c.dir,side=c.side.toLowerCase(),type=
c.sizeType.toLowerCase(),isSliding=slide!=undefined?slide:s.isSliding,$P=$Ps[pane],paneSpacing=o.spacing_open,altPane=_c.oppositeEdge[pane],altS=state[altPane],$altP=$Ps[altPane],altPaneSize=!$altP||altS.isVisible===false||altS.isSliding?0:dir=="horz"?$altP.outerHeight():$altP.outerWidth(),altPaneSpacing=(!$altP||altS.isHidden?0:options[altPane][altS.isClosed!==false?"spacing_closed":"spacing_open"])||0,containerSize=dir=="horz"?sC.innerHeight:sC.innerWidth,minCenterDims=cssMinDims("center"),minCenterSize=
dir=="horz"?max(options.center.minHeight,minCenterDims.minHeight):max(options.center.minWidth,minCenterDims.minWidth),limitSize=containerSize-paneSpacing-(isSliding?0:_parseSize("center",minCenterSize,dir)+altPaneSize+altPaneSpacing),minSize=s.minSize=max(_parseSize(pane,o.minSize),cssMinDims(pane).minSize),maxSize=s.maxSize=min(o.maxSize?_parseSize(pane,o.maxSize):1E5,limitSize),r=s.resizerPosition={},top=sC.insetTop,left=sC.insetLeft,W=sC.innerWidth,H=sC.innerHeight,rW=o.spacing_open;switch(pane){case "north":r.min=
top+minSize;r.max=top+maxSize;break;case "west":r.min=left+minSize;r.max=left+maxSize;break;case "south":r.min=top+H-maxSize-rW;r.max=top+H-minSize-rW;break;case "east":r.min=left+W-maxSize-rW;r.max=left+W-minSize-rW;break}},calcNewCenterPaneDims=function(){var d={top:getPaneSize("north",true),bottom:getPaneSize("south",true),left:getPaneSize("west",true),right:getPaneSize("east",true),width:0,height:0};d.width=sC.innerWidth-d.left-d.right;d.height=sC.innerHeight-d.bottom-d.top;d.top+=sC.insetTop;
d.bottom+=sC.insetBottom;d.left+=sC.insetLeft;d.right+=sC.insetRight;return d},getHoverClasses=function(el,allStates){var $El=$(el),type=$El.data("layoutRole"),pane=$El.data("layoutEdge"),o=options[pane],root=o[type+"Class"],_pane="-"+pane,_open="-open",_closed="-closed",_slide="-sliding",_hover="-hover ",_state=$El.hasClass(root+_closed)?_closed:_open,_alt=_state===_closed?_open:_closed,classes=root+_hover+(root+_pane+_hover)+(root+_state+_hover)+(root+_pane+_state+_hover);if(allStates)classes+=
root+_alt+_hover+(root+_pane+_alt+_hover);if(type=="resizer"&&$El.hasClass(root+_slide))classes+=root+_slide+_hover+(root+_pane+_slide+_hover);return $.trim(classes)},addHover=function(evt,el){var $E=$(el||this);if(evt&&$E.data("layoutRole")==="toggler")evt.stopPropagation();$E.addClass(getHoverClasses($E))},removeHover=function(evt,el){var $E=$(el||this);$E.removeClass(getHoverClasses($E,true))},onResizerEnter=function(evt){if($.fn.disableSelection)$("body").disableSelection()},onResizerLeave=function(evt,
el){var e=el||this,pane=$(e).data("layoutEdge"),name=pane+"ResizerLeave";timer.clear(pane+"_openSlider");timer.clear(name);if(!el)timer.set(name,function(){onResizerLeave(evt,e)},200);else if(!state[pane].isResizing&&$.fn.enableSelection)$("body").enableSelection()},_create=function(){initOptions();var o=options;state.creatingLayout=true;runPluginCallbacks(Instance,$.layout.onCreate);if(false===_runCallbacks("onload_start"))return"cancel";_initContainer();initHotkeys();$(window).bind("unload."+sID,
unload);runPluginCallbacks(Instance,$.layout.onLoad);if(o.initPanes)_initLayoutElements();delete state.creatingLayout;return state.initialized},isInitialized=function(){if(state.initialized||state.creatingLayout)return true;else return _initLayoutElements()},_initLayoutElements=function(retry){var o=options;if(!$N.is(":visible")){if(!retry&&browser.webkit&&$N[0].tagName==="BODY")setTimeout(function(){_initLayoutElements(true)},50);return false}if(!getPane("center").length){if(options.showErrorMessages)_log(lang.errCenterPaneMissing,
true);return false}state.creatingLayout=true;$.extend(sC,elDims($N));initPanes();if(o.scrollToBookmarkOnLoad){var l=self.location;if(l.hash)l.replace(l.hash)}if(Instance.hasParentLayout)o.resizeWithWindow=false;else if(o.resizeWithWindow)$(window).bind("resize."+sID,windowResize);delete state.creatingLayout;state.initialized=true;runPluginCallbacks(Instance,$.layout.onReady);_runCallbacks("onload_end");return true},_initChildLayouts=function(){$.each(_c.allPanes,function(idx,pane){if(options[pane].initChildLayout)createChildLayout(pane)})},
createChildLayout=function(evt_or_pane,opts){var pane=evtPane.call(this,evt_or_pane),$P=$Ps[pane],C=children;if($P){var $C=$Cs[pane],o=opts||options[pane].childOptions,d="layout",$Cont=o.containerSelector?$P.find(o.containerSelector):$C||$P,containerFound=$Cont.length,child=containerFound?C[pane]=$Cont.data(d)||null:null;if(!child&&containerFound&&o)child=C[pane]=$Cont.eq(0).layout(o)||null;if(child)child.hasParentLayout=true}Instance[pane].child=C[pane]},windowResize=function(){var delay=Number(options.resizeWithWindowDelay);
if(delay<10)delay=100;timer.clear("winResize");timer.set("winResize",function(){timer.clear("winResize");timer.clear("winResizeRepeater");var dims=elDims($N);if(dims.innerWidth!==sC.innerWidth||dims.innerHeight!==sC.innerHeight)resizeAll()},delay);if(!timer.data["winResizeRepeater"])setWindowResizeRepeater()},setWindowResizeRepeater=function(){var delay=Number(options.resizeWithWindowMaxDelay);if(delay>0)timer.set("winResizeRepeater",function(){setWindowResizeRepeater();resizeAll()},delay)},unload=
function(){var o=options;_runCallbacks("onunload_start");runPluginCallbacks(Instance,$.layout.onUnload);_runCallbacks("onunload_end")},_initContainer=function(){var N=$N[0],tag=sC.tagName=N.tagName,id=sC.id=N.id,cls=sC.className=N.className,o=options,name=o.name,fullPage=tag==="BODY",props="overflow,position,margin,padding,border",css="layoutCSS",CSS={},hid="hidden",parent=$N.data("parentLayout"),pane=$N.data("layoutEdge"),isChild=parent&&pane;sC.selector=$N.selector.split(".slice")[0];sC.ref=(o.name?
o.name+" layout / ":"")+tag+(id?"#"+id:cls?".["+cls+"]":"");$N.data({layout:Instance,layoutContainer:sID}).addClass(o.containerClass);var layoutMethods={destroy:"",initPanes:"",resizeAll:"resizeAll",resize:"resizeAll"},name;for(name in layoutMethods)$N.bind("layout"+name.toLowerCase()+"."+sID,Instance[layoutMethods[name]||name]);if(isChild){Instance.hasParentLayout=true;parent[pane].child=parent.children[pane]=$N.data("layout")}if(!$N.data(css)){if(fullPage){CSS=$.extend(elCSS($N,props),{height:$N.css("height"),
overflow:$N.css("overflow"),overflowX:$N.css("overflowX"),overflowY:$N.css("overflowY")});var $H=$("html");$H.data(css,{height:"auto",overflow:$H.css("overflow"),overflowX:$H.css("overflowX"),overflowY:$H.css("overflowY")})}else CSS=elCSS($N,props+",top,bottom,left,right,width,height,overflow,overflowX,overflowY");$N.data(css,CSS)}try{if(fullPage){$("html").css({height:"100%",overflow:hid,overflowX:hid,overflowY:hid});$("body").css({position:"relative",height:"100%",overflow:hid,overflowX:hid,overflowY:hid,
margin:0,padding:0,border:"none"});$.extend(sC,elDims($N))}else{CSS={overflow:hid,overflowX:hid,overflowY:hid};var p=$N.css("position"),h=$N.css("height");if(!isChild)if(!p||!p.match(/fixed|absolute|relative/))CSS.position="relative";$N.css(CSS);if($N.is(":visible")){$.extend(sC,elDims($N));if(o.showErrorMessages&&sC.innerHeight<1)_log(lang.errContainerHeight.replace(/CONTAINER/,sC.ref),true)}}}catch(ex){}},initHotkeys=function(panes){panes=panes?panes.split(","):_c.borderPanes;$.each(panes,function(i,
pane){var o=options[pane];if(o.enableCursorHotkey||o.customHotkey){$(document).bind("keydown."+sID,keyDown);return false}})},initOptions=function(){var data,d,pane,key,val,i,c,o;opts=$.layout.transformData(opts);opts=$.layout.backwardCompatibility.renameAllOptions(opts);if(!$.isEmptyObject(opts.panes)){data=$.layout.optionsMap.noDefault;for(i=0,c=data.length;i<c;i++){key=data[i];delete opts.panes[key]}data=$.layout.optionsMap.layout;for(i=0,c=data.length;i<c;i++){key=data[i];delete opts.panes[key]}}data=
$.layout.optionsMap.layout;var rootKeys=$.layout.config.optionRootKeys;for(key in opts){val=opts[key];if($.inArray(key,rootKeys)<0&&$.inArray(key,data)<0){if(!opts.panes[key])opts.panes[key]=$.isPlainObject(val)?$.extend(true,{},val):val;delete opts[key]}}$.extend(true,options,opts);$.each(_c.allPanes,function(i,pane){_c[pane]=$.extend(true,{},_c.panes,_c[pane]);d=options.panes;o=options[pane];if(pane==="center"){data=$.layout.optionsMap.center;for(i=0,c=data.length;i<c;i++){key=data[i];if(!opts.center[key]&&
(opts.panes[key]||!o[key]))o[key]=d[key]}}else{o=options[pane]=$.extend({},d,o);createFxOptions(pane);if(!o.resizerClass)o.resizerClass="ui-layout-resizer";if(!o.togglerClass)o.togglerClass="ui-layout-toggler"}if(!o.paneClass)o.paneClass="ui-layout-pane"});var zo=opts.zIndex,z=options.zIndexes;if(zo>0){z.pane_normal=zo;z.content_mask=max(zo+1,z.content_mask);z.resizer_normal=max(zo+2,z.resizer_normal)}function createFxOptions(pane){var o=options[pane],d=options.panes;if(!o.fxSettings)o.fxSettings=
{};if(!d.fxSettings)d.fxSettings={};$.each(["_open","_close","_size"],function(i,n){var sName="fxName"+n,sSpeed="fxSpeed"+n,sSettings="fxSettings"+n,fxName=o[sName]=o[sName]||d[sName]||o.fxName||d.fxName||"none";if(fxName==="none"||!$.effects||!$.effects[fxName]||!options.effects[fxName])fxName=o[sName]="none";var fx=options.effects[fxName]||{},fx_all=fx.all||null,fx_pane=fx[pane]||null;o[sSpeed]=o[sSpeed]||d[sSpeed]||o.fxSpeed||d.fxSpeed||null;o[sSettings]=$.extend({},fx_all,fx_pane,d.fxSettings,
o.fxSettings,d[sSettings],o[sSettings])});delete o.fxName;delete o.fxSpeed;delete o.fxSettings}delete options.panes},getPane=function(pane){var sel=options[pane].paneSelector;if(sel.substr(0,1)==="#")return $N.find(sel).eq(0);else{var $P=$N.children(sel).eq(0);return $P.length?$P:$N.children("form:first").children(sel).eq(0)}},initPanes=function(){$.each(_c.allPanes,function(idx,pane){addPane(pane,true)});initHandles();$.each(_c.borderPanes,function(i,pane){if($Ps[pane]&&state[pane].isVisible){setSizeLimits(pane);
makePaneFit(pane)}});sizeMidPanes("center");$.each(_c.allPanes,function(i,pane){var o=options[pane];if($Ps[pane]){if(state[pane].isVisible){sizeContent(pane);if(o.triggerEventsOnLoad)_runCallbacks("onresize_end",pane);else resizeChildLayout(pane)}if(o.initChildLayout&&o.childOptions)createChildLayout(pane)}})},addPane=function(pane,force){if(!force&&!isInitialized())return;var o=options[pane],s=state[pane],c=_c[pane],fx=s.fx,dir=c.dir,spacing=o.spacing_open||0,isCenter=pane==="center",CSS={},$P=$Ps[pane],
size,minSize,maxSize;if($P)removePane(pane,false,true,false);else $Cs[pane]=false;$P=$Ps[pane]=getPane(pane);if(!$P.length){$Ps[pane]=false;return}if(!$P.data("layoutCSS")){var props="position,top,left,bottom,right,width,height,overflow,zIndex,display,backgroundColor,padding,margin,border";$P.data("layoutCSS",elCSS($P,props))}Instance[pane]={name:pane,pane:$Ps[pane],content:$Cs[pane],options:options[pane],state:state[pane],child:children[pane]};$P.data({parentLayout:Instance,layoutPane:Instance[pane],
layoutEdge:pane,layoutRole:"pane"}).css(c.cssReq).css("zIndex",options.zIndexes.pane_normal).css(o.applyDemoStyles?c.cssDemo:{}).addClass(o.paneClass+" "+o.paneClass+"-"+pane).bind("mouseenter."+sID,addHover).bind("mouseleave."+sID,removeHover);var paneMethods={hide:"",show:"",toggle:"",close:"",open:"",slideOpen:"",slideClose:"",slideToggle:"",size:"manualSizePane",sizePane:"manualSizePane",sizeContent:"",sizeHandles:"",enableClosable:"",disableClosable:"",enableSlideable:"",disableSlideable:"",
enableResizable:"",disableResizable:"",swapPanes:"swapPanes",swap:"swapPanes",move:"swapPanes",removePane:"removePane",remove:"removePane",createChildLayout:"",resizeChildLayout:"",resizeAll:"resizeAll",resizeLayout:"resizeAll"},name;for(name in paneMethods)$P.bind("layoutpane"+name.toLowerCase()+"."+sID,Instance[paneMethods[name]||name]);initContent(pane,false);if(!isCenter){size=s.size=_parseSize(pane,o.size);minSize=_parseSize(pane,o.minSize)||1;maxSize=_parseSize(pane,o.maxSize)||1E5;if(size>
0)size=max(min(size,maxSize),minSize);s.isClosed=false;s.isSliding=false;s.isResizing=false;s.isHidden=false;if(!s.pins)s.pins=[]}s.tagName=$P[0].tagName;s.edge=pane;s.noRoom=false;s.isVisible=true;switch(pane){case "north":CSS.top=sC.insetTop;CSS.left=sC.insetLeft;CSS.right=sC.insetRight;break;case "south":CSS.bottom=sC.insetBottom;CSS.left=sC.insetLeft;CSS.right=sC.insetRight;break;case "west":CSS.left=sC.insetLeft;break;case "east":CSS.right=sC.insetRight;break;case "center":}if(dir==="horz")CSS.height=
cssH($P,size);else if(dir==="vert")CSS.width=cssW($P,size);$P.css(CSS);if(dir!="horz")sizeMidPanes(pane,true);if(o.initClosed&&o.closable&&!o.initHidden)close(pane,true,true);else if(o.initHidden||o.initClosed)hide(pane);else if(!s.noRoom)$P.css("display","block");$P.css("visibility","visible");if(o.showOverflowOnHover)$P.hover(allowOverflow,resetOverflow);if(state.initialized){initHandles(pane);initHotkeys(pane);resizeAll();if(s.isVisible)if(o.triggerEventsOnLoad)_runCallbacks("onresize_end",pane);
else resizeChildLayout(pane);if(o.initChildLayout&&o.childOptions)createChildLayout(pane)}},initHandles=function(panes){panes=panes?panes.split(","):_c.borderPanes;$.each(panes,function(i,pane){var $P=$Ps[pane];$Rs[pane]=false;$Ts[pane]=false;if(!$P)return;var o=options[pane],s=state[pane],c=_c[pane],rClass=o.resizerClass,tClass=o.togglerClass,side=c.side.toLowerCase(),spacing=s.isVisible?o.spacing_open:o.spacing_closed,_pane="-"+pane,_state=s.isVisible?"-open":"-closed",I=Instance[pane],$R=I.resizer=
$Rs[pane]=$("<div></div>"),$T=I.toggler=o.closable?$Ts[pane]=$("<div></div>"):false;if(!s.isVisible&&o.slidable)$R.attr("title",o.sliderTip).css("cursor",o.sliderCursor);$R.attr("id",o.paneSelector.substr(0,1)=="#"?o.paneSelector.substr(1)+"-resizer":"").data({parentLayout:Instance,layoutPane:Instance[pane],layoutEdge:pane,layoutRole:"resizer"}).css(_c.resizers.cssReq).css("zIndex",options.zIndexes.resizer_normal).css(o.applyDemoStyles?_c.resizers.cssDemo:{}).addClass(rClass+" "+rClass+_pane).hover(addHover,
removeHover).hover(onResizerEnter,onResizerLeave).appendTo($N);if($T){$T.attr("id",o.paneSelector.substr(0,1)=="#"?o.paneSelector.substr(1)+"-toggler":"").data({parentLayout:Instance,layoutPane:Instance[pane],layoutEdge:pane,layoutRole:"toggler"}).css(_c.togglers.cssReq).css(o.applyDemoStyles?_c.togglers.cssDemo:{}).addClass(tClass+" "+tClass+_pane).hover(addHover,removeHover).bind("mouseenter",onResizerEnter).appendTo($R);if(o.togglerContent_open)$("<span>"+o.togglerContent_open+"</span>").data({layoutEdge:pane,
layoutRole:"togglerContent"}).data("layoutRole","togglerContent").data("layoutEdge",pane).addClass("content content-open").css("display","none").appendTo($T);if(o.togglerContent_closed)$("<span>"+o.togglerContent_closed+"</span>").data({layoutEdge:pane,layoutRole:"togglerContent"}).addClass("content content-closed").css("display","none").appendTo($T);enableClosable(pane)}initResizable(pane);if(s.isVisible)setAsOpen(pane);else{setAsClosed(pane);bindStartSlidingEvent(pane,true)}});sizeHandles()},initContent=
function(pane,resize){if(!isInitialized())return;var o=options[pane],sel=o.contentSelector,I=Instance[pane],$P=$Ps[pane],$C;if(sel)$C=I.content=$Cs[pane]=o.findNestedContent?$P.find(sel).eq(0):$P.children(sel).eq(0);if($C&&$C.length){$C.data("layoutRole","content");if(!$C.data("layoutCSS"))$C.data("layoutCSS",elCSS($C,"height"));$C.css(_c.content.cssReq);if(o.applyDemoStyles){$C.css(_c.content.cssDemo);$P.css(_c.content.cssDemoPane)}state[pane].content={};if(resize!==false)sizeContent(pane)}else I.content=
$Cs[pane]=false},initResizable=function(panes){var draggingAvailable=$.layout.plugins.draggable,side;panes=panes?panes.split(","):_c.borderPanes;$.each(panes,function(idx,pane){var o=options[pane];if(!draggingAvailable||!$Ps[pane]||!o.resizable){o.resizable=false;return true}var s=state[pane],z=options.zIndexes,c=_c[pane],side=c.dir=="horz"?"top":"left",opEdge=_c.oppositeEdge[pane],masks=pane+",center,"+opEdge+(c.dir=="horz"?",west,east":""),$P=$Ps[pane],$R=$Rs[pane],base=o.resizerClass,lastPos=0,
r,live,resizerClass=base+"-drag",resizerPaneClass=base+"-"+pane+"-drag",helperClass=base+"-dragging",helperPaneClass=base+"-"+pane+"-dragging",helperLimitClass=base+"-dragging-limit",helperPaneLimitClass=base+"-"+pane+"-dragging-limit",helperClassesSet=false;if(!s.isClosed)$R.attr("title",o.resizerTip).css("cursor",o.resizerCursor);$R.draggable({containment:$N[0],axis:c.dir=="horz"?"y":"x",delay:0,distance:1,grid:o.resizingGrid,helper:"clone",opacity:o.resizerDragOpacity,addClasses:false,zIndex:z.resizer_drag,
start:function(e,ui){o=options[pane];s=state[pane];live=o.livePaneResizing;if(false===_runCallbacks("ondrag_start",pane))return false;s.isResizing=true;timer.clear(pane+"_closeSlider");setSizeLimits(pane);r=s.resizerPosition;lastPos=ui.position[side];$R.addClass(resizerClass+" "+resizerPaneClass);helperClassesSet=false;$("body").disableSelection();showMasks(masks)},drag:function(e,ui){if(!helperClassesSet){ui.helper.addClass(helperClass+" "+helperPaneClass).css({right:"auto",bottom:"auto"}).children().css("visibility",
"hidden");helperClassesSet=true;if(s.isSliding)$Ps[pane].css("zIndex",z.pane_sliding)}var limit=0;if(ui.position[side]<r.min){ui.position[side]=r.min;limit=-1}else if(ui.position[side]>r.max){ui.position[side]=r.max;limit=1}if(limit){ui.helper.addClass(helperLimitClass+" "+helperPaneLimitClass);window.defaultStatus=limit>0&&pane.match(/north|west/)||limit<0&&pane.match(/south|east/)?lang.maxSizeWarning:lang.minSizeWarning}else{ui.helper.removeClass(helperLimitClass+" "+helperPaneLimitClass);window.defaultStatus=
""}if(live&&Math.abs(ui.position[side]-lastPos)>=o.liveResizingTolerance){lastPos=ui.position[side];resizePanes(e,ui,pane)}},stop:function(e,ui){$("body").enableSelection();window.defaultStatus="";$R.removeClass(resizerClass+" "+resizerPaneClass);s.isResizing=false;resizePanes(e,ui,pane,true,masks)}})});var resizePanes=function(evt,ui,pane,resizingDone,masks){var dragPos=ui.position,c=_c[pane],o=options[pane],s=state[pane],resizerPos;switch(pane){case "north":resizerPos=dragPos.top;break;case "west":resizerPos=
dragPos.left;break;case "south":resizerPos=sC.offsetHeight-dragPos.top-o.spacing_open;break;case "east":resizerPos=sC.offsetWidth-dragPos.left-o.spacing_open;break}var newSize=resizerPos-sC["inset"+c.side];if(!resizingDone){if(Math.abs(newSize-s.size)<o.liveResizingTolerance)return;manualSizePane(pane,newSize,false,true);sizeMasks()}else{if(false!==_runCallbacks("ondrag_end",pane))manualSizePane(pane,newSize,false,true);hideMasks();if(s.isSliding&&masks)showMasks(masks,true)}}},sizeMask=function(){var $M=
$(this),pane=$M.data("layoutMask"),s=state[pane];if(s.tagName=="IFRAME"&&s.isVisible)$M.css({top:s.offsetTop,left:s.offsetLeft,width:s.outerWidth,height:s.outerHeight})},sizeMasks=function(){$Ms.each(sizeMask)},showMasks=function(panes,onlyForObjects){var a=panes?panes.split(","):$.layout.config.allPanes,z=options.zIndexes,o,s;$.each(a,function(i,p){s=state[p];o=options[p];if(s.isVisible&&(!onlyForObjects&&o.maskContents||o.maskObjects))getMasks(p).each(function(){sizeMask.call(this);this.style.zIndex=
s.isSliding?z.pane_sliding+1:z.pane_normal+1;this.style.display="block"})})},hideMasks=function(){var skip;$.each($.layout.config.borderPanes,function(i,p){if(state[p].isResizing){skip=true;return false}});if(!skip)$Ms.hide()},getMasks=function(pane){var $Masks=$([]),$M,i=0,c=$Ms.length;for(;i<c;i++){$M=$Ms.eq(i);if($M.data("layoutMask")===pane)$Masks=$Masks.add($M)}if($Masks.length)return $Masks;else return createMasks(pane)},createMasks=function(pane){var $P=$Ps[pane],s=state[pane],o=options[pane],
z=options.zIndexes,$Masks=$([]),isIframe,el,$M,css,i;if(!o.maskContents&&!o.maskObjects)return $Masks;for(i=0;i<(o.maskObjects?2:1);i++){isIframe=o.maskObjects&&i==0;el=document.createElement(isIframe?"iframe":"div");$M=$(el).data("layoutMask",pane);el.className="ui-layout-mask ui-layout-mask-"+pane;css=el.style;css.display="block";css.position="absolute";if(isIframe){el.frameborder=0;el.src="about:blank";css.opacity=0;css.filter="Alpha(Opacity='0')";css.border=0}if(s.tagName=="IFRAME"){css.zIndex=
z.pane_normal+1;$N.append(el)}else{$M.addClass("ui-layout-mask-inside-pane");css.zIndex=o.maskZindex||z.content_mask;css.top=0;css.left=0;css.width="100%";css.height="100%";$P.append(el)}$Masks=$Masks.add(el);$Ms=$Ms.add(el)}return $Masks},destroy=function(destroyChildren){$(window).unbind("."+sID);$(document).unbind("."+sID);$N.clearQueue().removeData("layout").removeData("layoutContainer").removeClass(options.containerClass).unbind("."+sID);$Ms.remove();$.each(_c.allPanes,function(i,pane){removePane(pane,
false,true,destroyChildren)});var css="layoutCSS";if($N.data(css)&&!$N.data("layoutRole"))$N.css($N.data(css)).removeData(css);if(sC.tagName==="BODY"&&($N=$("html")).data(css))$N.css($N.data(css)).removeData(css);runPluginCallbacks(Instance,$.layout.onDestroy);unload();for(n in Instance)if(!n.match(/^(container|options)$/))delete Instance[n];Instance.destroyed=true;return Instance},removePane=function(evt_or_pane,remove,skipResize,destroyChild){if(!isInitialized())return;var pane=evtPane.call(this,
evt_or_pane),$P=$Ps[pane],$C=$Cs[pane],$R=$Rs[pane],$T=$Ts[pane];if($P&&$.isEmptyObject($P.data()))$P=false;if($C&&$.isEmptyObject($C.data()))$C=false;if($R&&$.isEmptyObject($R.data()))$R=false;if($T&&$.isEmptyObject($T.data()))$T=false;if($P)$P.stop(true,true);var o=options[pane],s=state[pane],d="layout",css="layoutCSS",child=children[pane]||($P?$P.data(d):0)||($C?$C.data(d):0)||null,destroy=destroyChild!==undefined?destroyChild:o.destroyChildLayout;if(destroy&&child&&!child.destroyed){child.destroy(true);
if(child.destroyed)child=null}if($P&&remove&&!child)$P.remove();else if($P&&$P[0]){var root=o.paneClass,pRoot=root+"-"+pane,_open="-open",_sliding="-sliding",_closed="-closed",classes=[root,root+_open,root+_closed,root+_sliding,pRoot,pRoot+_open,pRoot+_closed,pRoot+_sliding];$.merge(classes,getHoverClasses($P,true));$P.removeClass(classes.join(" ")).removeData("parentLayout").removeData("layoutPane").removeData("layoutRole").removeData("layoutEdge").removeData("autoHidden").unbind("."+sID);if($C&&
$C.data(d)){$C.width($C.width());child.resizeAll()}else if($C)$C.css($C.data(css)).removeData(css).removeData("layoutRole");if(!$P.data(d))$P.css($P.data(css)).removeData(css)}if($T)$T.remove();if($R)$R.remove();Instance[pane]=$Ps[pane]=$Cs[pane]=$Rs[pane]=$Ts[pane]=children[pane]=false;s={removed:true};if(!skipResize)resizeAll()},_hidePane=function(pane){var $P=$Ps[pane],o=options[pane],s=$P[0].style;if(o.useOffscreenClose){if(!$P.data(_c.offscreenReset))$P.data(_c.offscreenReset,{left:s.left,right:s.right});
$P.css(_c.offscreenCSS)}else $P.hide().removeData(_c.offscreenReset)},_showPane=function(pane){var $P=$Ps[pane],o=options[pane],off=_c.offscreenCSS,old=$P.data(_c.offscreenReset),s=$P[0].style;$P.show().removeData(_c.offscreenReset);if(o.useOffscreenClose&&old){if(s.left==off.left)s.left=old.left;if(s.right==off.right)s.right=old.right}},hide=function(evt_or_pane,noAnimation){if(!isInitialized())return;var pane=evtPane.call(this,evt_or_pane),o=options[pane],s=state[pane],$P=$Ps[pane],$R=$Rs[pane];
if(!$P||s.isHidden)return;if(state.initialized&&false===_runCallbacks("onhide_start",pane))return;s.isSliding=false;if($R)$R.hide();if(!state.initialized||s.isClosed){s.isClosed=true;s.isHidden=true;s.isVisible=false;if(!state.initialized)_hidePane(pane);sizeMidPanes(_c[pane].dir==="horz"?"":"center");if(state.initialized||o.triggerEventsOnLoad)_runCallbacks("onhide_end",pane)}else{s.isHiding=true;close(pane,false,noAnimation)}},show=function(evt_or_pane,openPane,noAnimation,noAlert){if(!isInitialized())return;
var pane=evtPane.call(this,evt_or_pane),o=options[pane],s=state[pane],$P=$Ps[pane],$R=$Rs[pane];if(!$P||!s.isHidden)return;if(false===_runCallbacks("onshow_start",pane))return;s.isSliding=false;s.isShowing=true;if(openPane===false)close(pane,true);else open(pane,false,noAnimation,noAlert)},toggle=function(evt_or_pane,slide){if(!isInitialized())return;var evt=evtObj(evt_or_pane),pane=evtPane.call(this,evt_or_pane),s=state[pane];if(evt)evt.stopImmediatePropagation();if(s.isHidden)show(pane);else if(s.isClosed)open(pane,
!!slide);else close(pane)},_closePane=function(pane,setHandles){var $P=$Ps[pane],s=state[pane];_hidePane(pane);s.isClosed=true;s.isVisible=false},close=function(evt_or_pane,force,noAnimation,skipCallback){var pane=evtPane.call(this,evt_or_pane);if(!state.initialized&&$Ps[pane]){_closePane(pane);return}if(!isInitialized())return;var $P=$Ps[pane],$R=$Rs[pane],$T=$Ts[pane],o=options[pane],s=state[pane],c=_c[pane],doFX,isShowing,isHiding,wasSliding;$N.queue(function(queueNext){if(!$P||!o.closable&&!s.isShowing&&
!s.isHiding||!force&&s.isClosed&&!s.isShowing)return queueNext();var abort=!s.isShowing&&false===_runCallbacks("onclose_start",pane);isShowing=s.isShowing;isHiding=s.isHiding;wasSliding=s.isSliding;delete s.isShowing;delete s.isHiding;if(abort)return queueNext();doFX=!noAnimation&&!s.isClosed&&o.fxName_close!="none";s.isMoving=true;s.isClosed=true;s.isVisible=false;if(isHiding)s.isHidden=true;else if(isShowing)s.isHidden=false;if(s.isSliding)bindStopSlidingEvents(pane,false);else sizeMidPanes(_c[pane].dir===
"horz"?"":"center",false);setAsClosed(pane);if(doFX){var masks="center"+(c.dir=="horz"?",west,east":"");showMasks(masks,true);lockPaneForFX(pane,true);$P.hide(o.fxName_close,o.fxSettings_close,o.fxSpeed_close,function(){lockPaneForFX(pane,false);if(s.isClosed)close_2();queueNext()})}else{_hidePane(pane);close_2();queueNext()}});function close_2(){s.isMoving=false;bindStartSlidingEvent(pane,true);var altPane=_c.oppositeEdge[pane];if(state[altPane].noRoom){setSizeLimits(altPane);makePaneFit(altPane)}hideMasks();
if(!skipCallback&&(state.initialized||o.triggerEventsOnLoad)){if(!isShowing)_runCallbacks("onclose_end",pane);if(isShowing)_runCallbacks("onshow_end",pane);if(isHiding)_runCallbacks("onhide_end",pane)}}},setAsClosed=function(pane){var $P=$Ps[pane],$R=$Rs[pane],$T=$Ts[pane],o=options[pane],s=state[pane],side=_c[pane].side.toLowerCase(),inset="inset"+_c[pane].side,rClass=o.resizerClass,tClass=o.togglerClass,_pane="-"+pane,_open="-open",_sliding="-sliding",_closed="-closed";$R.css(side,sC[inset]).removeClass(rClass+
_open+" "+rClass+_pane+_open).removeClass(rClass+_sliding+" "+rClass+_pane+_sliding).addClass(rClass+_closed+" "+rClass+_pane+_closed).unbind("dblclick."+sID);if(o.resizable&&$.layout.plugins.draggable)$R.draggable("disable").removeClass("ui-state-disabled").css("cursor","default").attr("title","");if($T){$T.removeClass(tClass+_open+" "+tClass+_pane+_open).addClass(tClass+_closed+" "+tClass+_pane+_closed).attr("title",o.togglerTip_closed);$T.children(".content-open").hide();$T.children(".content-closed").css("display",
"block")}syncPinBtns(pane,false);if(state.initialized)sizeHandles()},open=function(evt_or_pane,slide,noAnimation,noAlert){if(!isInitialized())return;var pane=evtPane.call(this,evt_or_pane),$P=$Ps[pane],$R=$Rs[pane],$T=$Ts[pane],o=options[pane],s=state[pane],c=_c[pane],doFX,isShowing;$N.queue(function(queueNext){if(!$P||!o.resizable&&!o.closable&&!s.isShowing||s.isVisible&&!s.isSliding)return queueNext();if(s.isHidden&&!s.isShowing){queueNext();show(pane,true);return}if(o.autoResize&&s.size!=o.size)sizePane(pane,
o.size,true,true,true);else setSizeLimits(pane,slide);var cbReturn=_runCallbacks("onopen_start",pane);if(cbReturn==="abort")return queueNext();if(cbReturn!=="NC")setSizeLimits(pane,slide);if(s.minSize>s.maxSize){syncPinBtns(pane,false);if(!noAlert&&o.noRoomToOpenTip)alert(o.noRoomToOpenTip);return queueNext()}if(slide)bindStopSlidingEvents(pane,true);else if(s.isSliding)bindStopSlidingEvents(pane,false);else if(o.slidable)bindStartSlidingEvent(pane,false);s.noRoom=false;makePaneFit(pane);isShowing=
s.isShowing;delete s.isShowing;doFX=!noAnimation&&s.isClosed&&o.fxName_open!="none";s.isMoving=true;s.isVisible=true;s.isClosed=false;if(isShowing)s.isHidden=false;if(doFX){var masks="center"+(c.dir=="horz"?",west,east":"");if(s.isSliding)masks+=","+_c.oppositeEdge[pane];showMasks(masks,true);lockPaneForFX(pane,true);$P.show(o.fxName_open,o.fxSettings_open,o.fxSpeed_open,function(){lockPaneForFX(pane,false);if(s.isVisible)open_2();queueNext()})}else{_showPane(pane);open_2();queueNext()}});function open_2(){s.isMoving=
false;_fixIframe(pane);if(!s.isSliding){hideMasks();sizeMidPanes(_c[pane].dir=="vert"?"center":"",false)}setAsOpen(pane)}},setAsOpen=function(pane,skipCallback){var $P=$Ps[pane],$R=$Rs[pane],$T=$Ts[pane],o=options[pane],s=state[pane],side=_c[pane].side.toLowerCase(),inset="inset"+_c[pane].side,rClass=o.resizerClass,tClass=o.togglerClass,_pane="-"+pane,_open="-open",_closed="-closed",_sliding="-sliding";$R.css(side,sC[inset]+getPaneSize(pane)).removeClass(rClass+_closed+" "+rClass+_pane+_closed).addClass(rClass+
_open+" "+rClass+_pane+_open);if(s.isSliding)$R.addClass(rClass+_sliding+" "+rClass+_pane+_sliding);else $R.removeClass(rClass+_sliding+" "+rClass+_pane+_sliding);if(o.resizerDblClickToggle)$R.bind("dblclick",toggle);removeHover(0,$R);if(o.resizable&&$.layout.plugins.draggable)$R.draggable("enable").css("cursor",o.resizerCursor).attr("title",o.resizerTip);else if(!s.isSliding)$R.css("cursor","default");if($T){$T.removeClass(tClass+_closed+" "+tClass+_pane+_closed).addClass(tClass+_open+" "+tClass+
_pane+_open).attr("title",o.togglerTip_open);removeHover(0,$T);$T.children(".content-closed").hide();$T.children(".content-open").css("display","block")}syncPinBtns(pane,!s.isSliding);$.extend(s,elDims($P));if(state.initialized){sizeHandles();sizeContent(pane,true)}if(!skipCallback&&(state.initialized||o.triggerEventsOnLoad)&&$P.is(":visible")){_runCallbacks("onopen_end",pane);if(s.isShowing)_runCallbacks("onshow_end",pane);if(state.initialized)_runCallbacks("onresize_end",pane)}},slideOpen=function(evt_or_pane){if(!isInitialized())return;
var evt=evtObj(evt_or_pane),pane=evtPane.call(this,evt_or_pane),s=state[pane],delay=options[pane].slideDelay_open;if(evt)evt.stopImmediatePropagation();if(s.isClosed&&evt&&evt.type==="mouseenter"&&delay>0)timer.set(pane+"_openSlider",open_NOW,delay);else open_NOW();function open_NOW(){if(!s.isClosed)bindStopSlidingEvents(pane,true);else if(!s.isMoving)open(pane,true)}},slideClose=function(evt_or_pane){if(!isInitialized())return;var evt=evtObj(evt_or_pane),pane=evtPane.call(this,evt_or_pane),o=options[pane],
s=state[pane],delay=s.isMoving?1E3:300;if(s.isClosed||s.isResizing)return;else if(o.slideTrigger_close==="click")close_NOW();else if(o.preventQuickSlideClose&&s.isMoving)return;else if(o.preventPrematureSlideClose&&evt&&$.layout.isMouseOverElem(evt,$Ps[pane]))return;else if(evt)timer.set(pane+"_closeSlider",close_NOW,max(o.slideDelay_close,delay));else close_NOW();function close_NOW(){if(s.isClosed)bindStopSlidingEvents(pane,false);else if(!s.isMoving)close(pane)}},slideToggle=function(evt_or_pane){var pane=
evtPane.call(this,evt_or_pane);toggle(pane,true)},lockPaneForFX=function(pane,doLock){var $P=$Ps[pane],s=state[pane],o=options[pane],z=options.zIndexes;if(doLock){$P.css({zIndex:z.pane_animate});if(pane=="south")$P.css({top:sC.insetTop+sC.innerHeight-$P.outerHeight()});else if(pane=="east")$P.css({left:sC.insetLeft+sC.innerWidth-$P.outerWidth()})}else{$P.css({zIndex:s.isSliding?z.pane_sliding:z.pane_normal});if(pane=="south")$P.css({top:"auto"});else if(pane=="east"&&!$P.css("left").match(/\-99999/))$P.css({left:"auto"});
if(browser.msie&&o.fxOpacityFix&&o.fxName_open!="slide"&&$P.css("filter")&&$P.css("opacity")==1)$P[0].style.removeAttribute("filter")}},bindStartSlidingEvent=function(pane,enable){var o=options[pane],$P=$Ps[pane],$R=$Rs[pane],evtName=o.slideTrigger_open.toLowerCase();if(!$R||enable&&!o.slidable)return;if(evtName.match(/mouseover/))evtName=o.slideTrigger_open="mouseenter";else if(!evtName.match(/click|dblclick|mouseenter/))evtName=o.slideTrigger_open="click";$R[enable?"bind":"unbind"](evtName+"."+
sID,slideOpen).css("cursor",enable?o.sliderCursor:"default").attr("title",enable?o.sliderTip:"")},bindStopSlidingEvents=function(pane,enable){var o=options[pane],s=state[pane],c=_c[pane],z=options.zIndexes,evtName=o.slideTrigger_close.toLowerCase(),action=enable?"bind":"unbind",$P=$Ps[pane],$R=$Rs[pane];s.isSliding=enable;timer.clear(pane+"_closeSlider");if(enable)bindStartSlidingEvent(pane,false);$P.css("zIndex",enable?z.pane_sliding:z.pane_normal);$R.css("zIndex",enable?z.pane_sliding+2:z.resizer_normal);
if(!evtName.match(/click|mouseleave/))evtName=o.slideTrigger_close="mouseleave";$R[action](evtName,slideClose);if(evtName==="mouseleave"){$P[action]("mouseleave."+sID,slideClose);$R[action]("mouseenter."+sID,cancelMouseOut);$P[action]("mouseenter."+sID,cancelMouseOut)}if(!enable)timer.clear(pane+"_closeSlider");else if(evtName==="click"&&!o.resizable){$R.css("cursor",enable?o.sliderCursor:"default");$R.attr("title",enable?o.togglerTip_open:"")}function cancelMouseOut(evt){timer.clear(pane+"_closeSlider");
evt.stopPropagation()}},makePaneFit=function(pane,isOpening,skipCallback,force){var o=options[pane],s=state[pane],c=_c[pane],$P=$Ps[pane],$R=$Rs[pane],isSidePane=c.dir==="vert",hasRoom=false;if(pane==="center"||isSidePane&&s.noVerticalRoom){hasRoom=s.maxHeight>=0;if(hasRoom&&s.noRoom){_showPane(pane);if($R)$R.show();s.isVisible=true;s.noRoom=false;if(isSidePane)s.noVerticalRoom=false;_fixIframe(pane)}else if(!hasRoom&&!s.noRoom){_hidePane(pane);if($R)$R.hide();s.isVisible=false;s.noRoom=true}}if(pane===
"center");else if(s.minSize<=s.maxSize){hasRoom=true;if(s.size>s.maxSize)sizePane(pane,s.maxSize,skipCallback,force,true);else if(s.size<s.minSize)sizePane(pane,s.minSize,skipCallback,force,true);else if($R&&s.isVisible&&$P.is(":visible")){var side=c.side.toLowerCase(),pos=s.size+sC["inset"+c.side];if($.layout.cssNum($R,side)!=pos)$R.css(side,pos)}if(s.noRoom)if(s.wasOpen&&o.closable)if(o.autoReopen)open(pane,false,true,true);else s.noRoom=false;else show(pane,s.wasOpen,true,true)}else if(!s.noRoom){s.noRoom=
true;s.wasOpen=!s.isClosed&&!s.isSliding;if(s.isClosed);else if(o.closable)close(pane,true,true);else hide(pane,true)}},manualSizePane=function(evt_or_pane,size,skipCallback,noAnimation){if(!isInitialized())return;var pane=evtPane.call(this,evt_or_pane),o=options[pane],s=state[pane],forceResize=o.livePaneResizing&&!s.isResizing;o.autoResize=false;sizePane(pane,size,skipCallback,forceResize,noAnimation)},sizePane=function(evt_or_pane,size,skipCallback,force,noAnimation){if(!isInitialized())return;
var pane=evtPane.call(this,evt_or_pane),o=options[pane],s=state[pane],$P=$Ps[pane],$R=$Rs[pane],side=_c[pane].side.toLowerCase(),dimName=_c[pane].sizeType.toLowerCase(),inset="inset"+_c[pane].side,skipResizeWhileDragging=s.isResizing&&!o.triggerEventsDuringLiveResize,doFX=noAnimation!==true&&o.animatePaneSizing,oldSize,newSize;$N.queue(function(queueNext){setSizeLimits(pane);oldSize=s.size;size=_parseSize(pane,size);size=max(size,_parseSize(pane,o.minSize));size=min(size,s.maxSize);if(size<s.minSize){queueNext();
makePaneFit(pane,false,skipCallback);return}if(!force&&size===oldSize)return queueNext();if(!skipCallback&&state.initialized&&s.isVisible)_runCallbacks("onresize_start",pane);newSize=cssSize(pane,size);if(doFX&&$P.is(":visible")){var fx=$.layout.effects.size[pane]||$.layout.effects.size.all,easing=o.fxSettings_size.easing||fx.easing,z=options.zIndexes,props={};props[dimName]=newSize+"px";s.isMoving=true;$P.css({zIndex:z.pane_animate}).show().animate(props,o.fxSpeed_size,easing,function(){$P.css({zIndex:s.isSliding?
z.pane_sliding:z.pane_normal});s.isMoving=false;sizePane_2();queueNext()})}else{$P.css(dimName,newSize);if($P.is(":visible"))sizePane_2();else{s.size=size;$.extend(s,elDims($P))}queueNext()}});function sizePane_2(){var actual=dimName==="width"?$P.outerWidth():$P.outerHeight(),tries=[{pane:pane,count:1,target:size,actual:actual,correct:size===actual,attempt:size,cssSize:newSize}],lastTry=tries[0],msg="Inaccurate size after resizing the "+pane+"-pane.";while(!lastTry.correct){thisTry={pane:pane,count:lastTry.count+
1,target:size};if(lastTry.actual>size)thisTry.attempt=max(0,lastTry.attempt-(lastTry.actual-size));else thisTry.attempt=max(0,lastTry.attempt+(size-lastTry.actual));thisTry.cssSize=cssSize(pane,thisTry.attempt);$P.css(dimName,thisTry.cssSize);thisTry.actual=dimName=="width"?$P.outerWidth():$P.outerHeight();thisTry.correct=size===thisTry.actual;if(options.showDebugMessages){if(tries.length===1){_log(msg,false);_log(lastTry,false)}_log(thisTry,false)}if(tries.length>3)break;tries.push(thisTry);lastTry=
tries[tries.length-1]}s.size=size;$.extend(s,elDims($P));if(s.isVisible&&$P.is(":visible")){if($R)$R.css(side,size+sC[inset]);sizeContent(pane)}if(!skipCallback&&!skipResizeWhileDragging&&state.initialized&&s.isVisible)_runCallbacks("onresize_end",pane);if(!skipCallback){if(!s.isSliding)sizeMidPanes(_c[pane].dir=="horz"?"":"center",skipResizeWhileDragging,force);sizeHandles()}var altPane=_c.oppositeEdge[pane];if(size<oldSize&&state[altPane].noRoom){setSizeLimits(altPane);makePaneFit(altPane,false,
skipCallback)}if(options.showDebugMessages&&tries.length>1)_log(msg+"\nSee the Error Console for details.",true)}},sizeMidPanes=function(panes,skipCallback,force){panes=(panes?panes:"east,west,center").split(",");$.each(panes,function(i,pane){if(!$Ps[pane])return;var o=options[pane],s=state[pane],$P=$Ps[pane],$R=$Rs[pane],isCenter=pane=="center",hasRoom=true,CSS={},newCenter=calcNewCenterPaneDims();$.extend(s,elDims($P));if(pane==="center"){if(!force&&s.isVisible&&newCenter.width===s.outerWidth&&
newCenter.height===s.outerHeight)return true;$.extend(s,cssMinDims(pane),{maxWidth:newCenter.width,maxHeight:newCenter.height});CSS=newCenter;CSS.width=cssW($P,CSS.width);CSS.height=cssH($P,CSS.height);hasRoom=CSS.width>=0&&CSS.height>=0;if(!state.initialized&&o.minWidth>s.outerWidth){var reqPx=o.minWidth-s.outerWidth,minE=options.east.minSize||0,minW=options.west.minSize||0,sizeE=state.east.size,sizeW=state.west.size,newE=sizeE,newW=sizeW;if(reqPx>0&&state.east.isVisible&&sizeE>minE){newE=max(sizeE-
minE,sizeE-reqPx);reqPx-=sizeE-newE}if(reqPx>0&&state.west.isVisible&&sizeW>minW){newW=max(sizeW-minW,sizeW-reqPx);reqPx-=sizeW-newW}if(reqPx===0){if(sizeE!=minE)sizePane("east",newE,true,force,true);if(sizeW!=minW)sizePane("west",newW,true,force,true);sizeMidPanes("center",skipCallback,force);return}}}else{if(s.isVisible&&!s.noVerticalRoom)$.extend(s,elDims($P),cssMinDims(pane));if(!force&&!s.noVerticalRoom&&newCenter.height===s.outerHeight)return true;CSS.top=newCenter.top;CSS.bottom=newCenter.bottom;
CSS.height=cssH($P,newCenter.height);s.maxHeight=CSS.height;hasRoom=s.maxHeight>=0;if(!hasRoom)s.noVerticalRoom=true}if(hasRoom){if(!skipCallback&&state.initialized)_runCallbacks("onresize_start",pane);$P.css(CSS);sizeHandles(pane);if(s.noRoom&&!s.isClosed&&!s.isHidden)makePaneFit(pane);if(s.isVisible){$.extend(s,elDims($P));if(state.initialized)sizeContent(pane)}}else if(!s.noRoom&&s.isVisible)makePaneFit(pane);if(!s.isVisible)return true;if(pane==="center"){var b=$.layout.browser;var fix=b.isIE6||
b.msie&&!$.support.boxModel;if($Ps.north&&(fix||state.north.tagName=="IFRAME"))$Ps.north.css("width",cssW($Ps.north,sC.innerWidth));if($Ps.south&&(fix||state.south.tagName=="IFRAME"))$Ps.south.css("width",cssW($Ps.south,sC.innerWidth))}if(!skipCallback&&state.initialized)_runCallbacks("onresize_end",pane)})},resizeAll=function(){if(!state.initialized){_initLayoutElements();return}var oldW=sC.innerWidth,oldH=sC.innerHeight;if(!$N.is(":visible:"))return;$.extend(state.container,elDims($N));if(!sC.outerHeight)return;
if(false===_runCallbacks("onresizeall_start"))return false;var shrunkH=sC.innerHeight<oldH,shrunkW=sC.innerWidth<oldW,$P,o,s,dir;$.each(["south","north","east","west"],function(i,pane){if(!$Ps[pane])return;s=state[pane];o=options[pane];dir=_c[pane].dir;if(o.autoResize&&s.size!=o.size)sizePane(pane,o.size,true,true,true);else{setSizeLimits(pane);makePaneFit(pane,false,true,true)}});sizeMidPanes("",true,true);sizeHandles();o=options;$.each(_c.allPanes,function(i,pane){$P=$Ps[pane];if(!$P)return;if(state[pane].isVisible)_runCallbacks("onresize_end",
pane)});_runCallbacks("onresizeall_end")},resizeChildLayout=function(evt_or_pane){var pane=evtPane.call(this,evt_or_pane);if(!options[pane].resizeChildLayout)return;var $P=$Ps[pane],$C=$Cs[pane],d="layout",P=Instance[pane],L=children[pane];if(P.child&&!L){var el=P.child.container;L=children[pane]=(el?el.data(d):0)||null}if(L&&L.destroyed)L=children[pane]=null;if(!L)L=children[pane]=$P.data(d)||($C?$C.data(d):0)||null;P.child=children[pane];if(L)L.resizeAll()},sizeContent=function(evt_or_panes,remeasure){if(!isInitialized())return;
var panes=evtPane.call(this,evt_or_panes);panes=panes?panes.split(","):_c.allPanes;$.each(panes,function(idx,pane){var $P=$Ps[pane],$C=$Cs[pane],o=options[pane],s=state[pane],m=s.content;if(!$P||!$C||!$P.is(":visible"))return true;if(!$C.length){initContent(pane,false);if(!$C)return}if(false===_runCallbacks("onsizecontent_start",pane))return;if(!s.isMoving&&!s.isResizing||o.liveContentResizing||remeasure||m.top==undefined){_measure();if(m.hiddenFooters>0&&$P.css("overflow")==="hidden"){$P.css("overflow",
"visible");_measure();$P.css("overflow","hidden")}}var newH=s.innerHeight-(m.spaceAbove-s.css.paddingTop)-(m.spaceBelow-s.css.paddingBottom);if(!$C.is(":visible")||m.height!=newH){setOuterHeight($C,newH,true);m.height=newH}if(state.initialized)_runCallbacks("onsizecontent_end",pane);function _below($E){return max(s.css.paddingBottom,parseInt($E.css("marginBottom"),10)||0)}function _measure(){var ignore=options[pane].contentIgnoreSelector,$Fs=$C.nextAll().not(ignore||":lt(0)"),$Fs_vis=$Fs.filter(":visible"),
$F=$Fs_vis.filter(":last");m={top:$C[0].offsetTop,height:$C.outerHeight(),numFooters:$Fs.length,hiddenFooters:$Fs.length-$Fs_vis.length,spaceBelow:0};m.spaceAbove=m.top;m.bottom=m.top+m.height;if($F.length)m.spaceBelow=$F[0].offsetTop+$F.outerHeight()-m.bottom+_below($F);else m.spaceBelow=_below($C)}})},sizeHandles=function(evt_or_panes){var panes=evtPane.call(this,evt_or_panes);panes=panes?panes.split(","):_c.borderPanes;$.each(panes,function(i,pane){var o=options[pane],s=state[pane],$P=$Ps[pane],
$R=$Rs[pane],$T=$Ts[pane],$TC;if(!$P||!$R)return;var dir=_c[pane].dir,_state=s.isClosed?"_closed":"_open",spacing=o["spacing"+_state],togAlign=o["togglerAlign"+_state],togLen=o["togglerLength"+_state],paneLen,left,offset,CSS={};if(spacing===0){$R.hide();return}else if(!s.noRoom&&!s.isHidden)$R.show();if(dir==="horz"){paneLen=sC.innerWidth;s.resizerLength=paneLen;left=$.layout.cssNum($P,"left");$R.css({width:cssW($R,paneLen),height:cssH($R,spacing),left:left>-9999?left:sC.insetLeft})}else{paneLen=
$P.outerHeight();s.resizerLength=paneLen;$R.css({height:cssH($R,paneLen),width:cssW($R,spacing),top:sC.insetTop+getPaneSize("north",true)})}removeHover(o,$R);if($T){if(togLen===0||s.isSliding&&o.hideTogglerOnSlide){$T.hide();return}else $T.show();if(!(togLen>0)||togLen==="100%"||togLen>paneLen){togLen=paneLen;offset=0}else if(isStr(togAlign))switch(togAlign){case "top":case "left":offset=0;break;case "bottom":case "right":offset=paneLen-togLen;break;case "middle":case "center":default:offset=round((paneLen-
togLen)/2)}else{var x=parseInt(togAlign,10);if(togAlign>=0)offset=x;else offset=paneLen-togLen+x}if(dir==="horz"){var width=cssW($T,togLen);$T.css({width:width,height:cssH($T,spacing),left:offset,top:0});$T.children(".content").each(function(){$TC=$(this);$TC.css("marginLeft",round((width-$TC.outerWidth())/2))})}else{var height=cssH($T,togLen);$T.css({height:height,width:cssW($T,spacing),top:offset,left:0});$T.children(".content").each(function(){$TC=$(this);$TC.css("marginTop",round((height-$TC.outerHeight())/
2))})}removeHover(0,$T)}if(!state.initialized&&(o.initHidden||s.noRoom)){$R.hide();if($T)$T.hide()}})},enableClosable=function(evt_or_pane){if(!isInitialized())return;var pane=evtPane.call(this,evt_or_pane),$T=$Ts[pane],o=options[pane];if(!$T)return;o.closable=true;$T.bind("click."+sID,function(evt){evt.stopPropagation();toggle(pane)}).css("visibility","visible").css("cursor","pointer").attr("title",state[pane].isClosed?o.togglerTip_closed:o.togglerTip_open).show()},disableClosable=function(evt_or_pane,
hide){if(!isInitialized())return;var pane=evtPane.call(this,evt_or_pane),$T=$Ts[pane];if(!$T)return;options[pane].closable=false;if(state[pane].isClosed)open(pane,false,true);$T.unbind("."+sID).css("visibility",hide?"hidden":"visible").css("cursor","default").attr("title","")},enableSlidable=function(evt_or_pane){if(!isInitialized())return;var pane=evtPane.call(this,evt_or_pane),$R=$Rs[pane];if(!$R||!$R.data("draggable"))return;options[pane].slidable=true;if(s.isClosed)bindStartSlidingEvent(pane,
true)},disableSlidable=function(evt_or_pane){if(!isInitialized())return;var pane=evtPane.call(this,evt_or_pane),$R=$Rs[pane];if(!$R)return;options[pane].slidable=false;if(state[pane].isSliding)close(pane,false,true);else{bindStartSlidingEvent(pane,false);$R.css("cursor","default").attr("title","");removeHover(null,$R[0])}},enableResizable=function(evt_or_pane){if(!isInitialized())return;var pane=evtPane.call(this,evt_or_pane),$R=$Rs[pane],o=options[pane];if(!$R||!$R.data("draggable"))return;o.resizable=
true;$R.draggable("enable");if(!state[pane].isClosed)$R.css("cursor",o.resizerCursor).attr("title",o.resizerTip)},disableResizable=function(evt_or_pane){if(!isInitialized())return;var pane=evtPane.call(this,evt_or_pane),$R=$Rs[pane];if(!$R||!$R.data("draggable"))return;options[pane].resizable=false;$R.draggable("disable").css("cursor","default").attr("title","");removeHover(null,$R[0])},swapPanes=function(evt_or_pane1,pane2){if(!isInitialized())return;var pane1=evtPane.call(this,evt_or_pane1);state[pane1].edge=
pane2;state[pane2].edge=pane1;if(false===_runCallbacks("onswap_start",pane1)||false===_runCallbacks("onswap_start",pane2)){state[pane1].edge=pane1;state[pane2].edge=pane2;return}var oPane1=copy(pane1),oPane2=copy(pane2),sizes={};sizes[pane1]=oPane1?oPane1.state.size:0;sizes[pane2]=oPane2?oPane2.state.size:0;$Ps[pane1]=false;$Ps[pane2]=false;state[pane1]={};state[pane2]={};if($Ts[pane1])$Ts[pane1].remove();if($Ts[pane2])$Ts[pane2].remove();if($Rs[pane1])$Rs[pane1].remove();if($Rs[pane2])$Rs[pane2].remove();
$Rs[pane1]=$Rs[pane2]=$Ts[pane1]=$Ts[pane2]=false;move(oPane1,pane2);move(oPane2,pane1);oPane1=oPane2=sizes=null;if($Ps[pane1])$Ps[pane1].css(_c.visible);if($Ps[pane2])$Ps[pane2].css(_c.visible);resizeAll();_runCallbacks("onswap_end",pane1);_runCallbacks("onswap_end",pane2);return;function copy(n){var $P=$Ps[n],$C=$Cs[n];return!$P?false:{pane:n,P:$P?$P[0]:false,C:$C?$C[0]:false,state:$.extend(true,{},state[n]),options:$.extend(true,{},options[n])}}function move(oPane,pane){if(!oPane)return;var P=
oPane.P,C=oPane.C,oldPane=oPane.pane,c=_c[pane],side=c.side.toLowerCase(),inset="inset"+c.side,s=$.extend({},state[pane]),o=options[pane],fx={resizerCursor:o.resizerCursor},re,size,pos;$.each("fxName,fxSpeed,fxSettings".split(","),function(i,k){fx[k+"_open"]=o[k+"_open"];fx[k+"_close"]=o[k+"_close"];fx[k+"_size"]=o[k+"_size"]});$Ps[pane]=$(P).data({layoutPane:Instance[pane],layoutEdge:pane}).css(_c.hidden).css(c.cssReq);$Cs[pane]=C?$(C):false;options[pane]=$.extend({},oPane.options,fx);state[pane]=
$.extend({},oPane.state);re=new RegExp(o.paneClass+"-"+oldPane,"g");P.className=P.className.replace(re,o.paneClass+"-"+pane);initHandles(pane);if(c.dir!=_c[oldPane].dir){size=sizes[pane]||0;setSizeLimits(pane);size=max(size,state[pane].minSize);manualSizePane(pane,size,true,true)}else $Rs[pane].css(side,sC[inset]+(state[pane].isVisible?getPaneSize(pane):0));if(oPane.state.isVisible&&!s.isVisible)setAsOpen(pane,true);else{setAsClosed(pane);bindStartSlidingEvent(pane,true)}oPane=null}},syncPinBtns=
function(pane,doPin){if($.layout.plugins.buttons)$.each(state[pane].pins,function(i,selector){$.layout.buttons.setPinState(Instance,$(selector),pane,doPin)})};function keyDown(evt){if(!evt)return true;var code=evt.keyCode;if(code<33)return true;var PANE={38:"north",40:"south",37:"west",39:"east"},ALT=evt.altKey,SHIFT=evt.shiftKey,CTRL=evt.ctrlKey,CURSOR=CTRL&&code>=37&&code<=40,o,k,m,pane;if(CURSOR&&options[PANE[code]].enableCursorHotkey)pane=PANE[code];else if(CTRL||SHIFT)$.each(_c.borderPanes,function(i,
p){o=options[p];k=o.customHotkey;m=o.customHotkeyModifier;if(SHIFT&&m=="SHIFT"||CTRL&&m=="CTRL"||CTRL&&SHIFT)if(k&&code===(isNaN(k)||k<=9?k.toUpperCase().charCodeAt(0):k)){pane=p;return false}});if(!pane||!$Ps[pane]||!options[pane].closable||state[pane].isHidden)return true;toggle(pane);evt.stopPropagation();evt.returnValue=false;return false}function allowOverflow(el){if(!isInitialized())return;if(this&&this.tagName)el=this;var $P;if(isStr(el))$P=$Ps[el];else if($(el).data("layoutRole"))$P=$(el);
else $(el).parents().each(function(){if($(this).data("layoutRole")){$P=$(this);return false}});if(!$P||!$P.length)return;var pane=$P.data("layoutEdge"),s=state[pane];if(s.cssSaved)resetOverflow(pane);if(s.isSliding||s.isResizing||s.isClosed){s.cssSaved=false;return}var newCSS={zIndex:options.zIndexes.resizer_normal+1},curCSS={},of=$P.css("overflow"),ofX=$P.css("overflowX"),ofY=$P.css("overflowY");if(of!="visible"){curCSS.overflow=of;newCSS.overflow="visible"}if(ofX&&!ofX.match(/visible|auto/)){curCSS.overflowX=
ofX;newCSS.overflowX="visible"}if(ofY&&!ofY.match(/visible|auto/)){curCSS.overflowY=ofX;newCSS.overflowY="visible"}s.cssSaved=curCSS;$P.css(newCSS);$.each(_c.allPanes,function(i,p){if(p!=pane)resetOverflow(p)})}function resetOverflow(el){if(!isInitialized())return;if(this&&this.tagName)el=this;var $P;if(isStr(el))$P=$Ps[el];else if($(el).data("layoutRole"))$P=$(el);else $(el).parents().each(function(){if($(this).data("layoutRole")){$P=$(this);return false}});if(!$P||!$P.length)return;var pane=$P.data("layoutEdge"),
s=state[pane],CSS=s.cssSaved||{};if(!s.isSliding&&!s.isResizing)$P.css("zIndex",options.zIndexes.pane_normal);$P.css(CSS);s.cssSaved=false}var $N=$(this).eq(0);if(!$N.length){if(options.showErrorMessages)_log(lang.errContainerMissing,true);return null}if($N.data("layoutContainer")&&$N.data("layout"))return $N.data("layout");var $Ps={},$Cs={},$Rs={},$Ts={},$Ms=$([]),sC=state.container,sID=state.id;var Instance={options:options,state:state,container:$N,panes:$Ps,contents:$Cs,resizers:$Rs,togglers:$Ts,
hide:hide,show:show,toggle:toggle,open:open,close:close,slideOpen:slideOpen,slideClose:slideClose,slideToggle:slideToggle,setSizeLimits:setSizeLimits,_sizePane:sizePane,sizePane:manualSizePane,sizeContent:sizeContent,swapPanes:swapPanes,initContent:initContent,addPane:addPane,removePane:removePane,createChildLayout:createChildLayout,enableClosable:enableClosable,disableClosable:disableClosable,enableSlidable:enableSlidable,disableSlidable:disableSlidable,enableResizable:enableResizable,disableResizable:disableResizable,
allowOverflow:allowOverflow,resetOverflow:resetOverflow,destroy:destroy,initPanes:isInitialized,resizeAll:resizeAll,runCallbacks:_runCallbacks,hasParentLayout:false,children:children,north:false,south:false,west:false,east:false,center:false};if(_create()==="cancel")return null;else return Instance};if(!$.ui)$.ui={};$.ui.cookie={acceptsCookies:!!navigator.cookieEnabled,read:function(name){var c=document.cookie,cs=c?c.split(";"):[],pair;for(var i=0,n=cs.length;i<n;i++){pair=$.trim(cs[i]).split("=");
if(pair[0]==name)return decodeURIComponent(pair[1])}return null},write:function(name,val,cookieOpts){var params="",date="",clear=false,o=cookieOpts||{},x=o.expires;if(x&&x.toUTCString)date=x;else if(x===null||typeof x==="number"){date=new Date;if(x>0)date.setDate(date.getDate()+x);else{date.setFullYear(1970);clear=true}}if(date)params+=";expires="+date.toUTCString();if(o.path)params+=";path="+o.path;if(o.domain)params+=";domain="+o.domain;if(o.secure)params+=";secure";document.cookie=name+"="+(clear?
"":encodeURIComponent(val))+params},clear:function(name){$.ui.cookie.write(name,"",{expires:-1})}};if(!$.cookie)$.cookie=function(k,v,o){var C=$.ui.cookie;if(v===null)C.clear(k);else if(v===undefined)return C.read(k);else C.write(k,v,o)};$.layout.plugins.stateManagement=true;$.layout.config.optionRootKeys.push("stateManagement");$.layout.defaults.stateManagement={enabled:false,autoSave:true,autoLoad:true,stateKeys:"north.size,south.size,east.size,west.size,"+"north.isClosed,south.isClosed,east.isClosed,west.isClosed,"+
"north.isHidden,south.isHidden,east.isHidden,west.isHidden",cookie:{name:"",domain:"",path:"",expires:"",secure:false}};$.layout.optionsMap.layout.push("stateManagement");$.layout.state={saveCookie:function(inst,keys,cookieOpts){var o=inst.options,oS=o.stateManagement,oC=$.extend(true,{},oS.cookie,cookieOpts||null),data=inst.state.stateData=inst.readState(keys||oS.stateKeys);$.ui.cookie.write(oC.name||o.name||"Layout",$.layout.state.encodeJSON(data),oC);return $.extend(true,{},data)},deleteCookie:function(inst){var o=
inst.options;$.ui.cookie.clear(o.stateManagement.cookie.name||o.name||"Layout")},readCookie:function(inst){var o=inst.options;var c=$.ui.cookie.read(o.stateManagement.cookie.name||o.name||"Layout");return c?$.layout.state.decodeJSON(c):{}},loadCookie:function(inst){var c=$.layout.state.readCookie(inst);if(c){inst.state.stateData=$.extend(true,{},c);inst.loadState(c)}return c},loadState:function(inst,stateData,animate){stateData=$.layout.transformData(stateData);if($.isEmptyObject(stateData))return;
$.extend(true,inst.options,stateData);if(inst.state.initialized){var pane,vis,o,s,h,c,noAnimate=animate===false;$.each($.layout.config.borderPanes,function(idx,pane){state=inst.state[pane];o=stateData[pane];if(typeof o!="object")return;s=o.size;c=o.initClosed;h=o.initHidden;vis=state.isVisible;if(!vis)inst.sizePane(pane,s,false,false);if(h===true)inst.hide(pane,noAnimate);else if(c===false)inst.open(pane,false,noAnimate);else if(c===true)inst.close(pane,false,noAnimate);else if(h===false)inst.show(pane,
false,noAnimate);if(vis)inst.sizePane(pane,s,false,noAnimate)})}},readState:function(inst,keys){var data={},alt={isClosed:"initClosed",isHidden:"initHidden"},state=inst.state,panes=$.layout.config.allPanes,pair,pane,key,val;if(!keys)keys=inst.options.stateManagement.stateKeys;if($.isArray(keys))keys=keys.join(",");keys=keys.replace(/__/g,".").split(",");for(var i=0,n=keys.length;i<n;i++){pair=keys[i].split(".");pane=pair[0];key=pair[1];if($.inArray(pane,panes)<0)continue;val=state[pane][key];if(val==
undefined)continue;if(key=="isClosed"&&state[pane]["isSliding"])val=true;(data[pane]||(data[pane]={}))[alt[key]?alt[key]:key]=val}return data},encodeJSON:function(JSON){return parse(JSON);function parse(h){var D=[],i=0,k,v,t;for(k in h){v=h[k];t=typeof v;if(t=="string")v='"'+v+'"';else if(t=="object")v=parse(v);D[i++]='"'+k+'":'+v}return"{"+D.join(",")+"}"}},decodeJSON:function(str){try{return $.parseJSON?$.parseJSON(str):window["eval"]("("+str+")")||{}}catch(e){return{}}},_create:function(inst){var _=
$.layout.state;$.extend(inst,{readCookie:function(){return _.readCookie(inst)},deleteCookie:function(){_.deleteCookie(inst)},saveCookie:function(keys,cookieOpts){return _.saveCookie(inst,keys,cookieOpts)},loadCookie:function(){return _.loadCookie(inst)},loadState:function(stateData,animate){_.loadState(inst,stateData,animate)},readState:function(keys){return _.readState(inst,keys)},encodeJSON:_.encodeJSON,decodeJSON:_.decodeJSON});inst.state.stateData={};var oS=inst.options.stateManagement;if(oS.enabled)if(oS.autoLoad)inst.loadCookie();
else inst.state.stateData=inst.readCookie()},_unload:function(inst){var oS=inst.options.stateManagement;if(oS.enabled)if(oS.autoSave)inst.saveCookie();else inst.state.stateData=inst.readState()}};$.layout.onCreate.push($.layout.state._create);$.layout.onUnload.push($.layout.state._unload);$.layout.plugins.buttons=true;$.layout.defaults.autoBindCustomButtons=false;$.layout.optionsMap.layout.push("autoBindCustomButtons");var lang=$.layout.language;$.layout.buttons={init:function(inst){var pre="ui-layout-button-",
layout=inst.options.name||"",name;$.each("toggle,open,close,pin,toggle-slide,open-slide".split(","),function(i,action){$.each($.layout.config.borderPanes,function(ii,pane){$("."+pre+action+"-"+pane).each(function(){name=$(this).data("layoutName")||$(this).attr("layoutName");if(name==undefined||name===layout)inst.bindButton(this,action,pane)})})})},get:function(inst,selector,pane,action){var $E=$(selector),o=inst.options,err=o.showErrorMessages;if(!$E.length){if(err)$.layout.msg(lang.errButton+lang.selector+
": "+selector,true)}else if($.inArray(pane,$.layout.config.borderPanes)<0){if(err)$.layout.msg(lang.errButton+lang.pane+": "+pane,true);$E=$("")}else{var btn=o[pane].buttonClass+"-"+action;$E.addClass(btn+" "+btn+"-"+pane).data("layoutName",o.name)}return $E},bind:function(inst,selector,action,pane){var _=$.layout.buttons;switch(action.toLowerCase()){case "toggle":_.addToggle(inst,selector,pane);break;case "open":_.addOpen(inst,selector,pane);break;case "close":_.addClose(inst,selector,pane);break;
case "pin":_.addPin(inst,selector,pane);break;case "toggle-slide":_.addToggle(inst,selector,pane,true);break;case "open-slide":_.addOpen(inst,selector,pane,true);break}return inst},addToggle:function(inst,selector,pane,slide){$.layout.buttons.get(inst,selector,pane,"toggle").click(function(evt){inst.toggle(pane,!!slide);evt.stopPropagation()});return inst},addOpen:function(inst,selector,pane,slide){$.layout.buttons.get(inst,selector,pane,"open").attr("title",lang.Open).click(function(evt){inst.open(pane,
!!slide);evt.stopPropagation()});return inst},addClose:function(inst,selector,pane){$.layout.buttons.get(inst,selector,pane,"close").attr("title",lang.Close).click(function(evt){inst.close(pane);evt.stopPropagation()});return inst},addPin:function(inst,selector,pane){var _=$.layout.buttons,$E=_.get(inst,selector,pane,"pin");if($E.length){var s=inst.state[pane];$E.click(function(evt){_.setPinState(inst,$(this),pane,s.isSliding||s.isClosed);if(s.isSliding||s.isClosed)inst.open(pane);else inst.close(pane);
evt.stopPropagation()});_.setPinState(inst,$E,pane,!s.isClosed&&!s.isSliding);s.pins.push(selector)}return inst},setPinState:function(inst,$Pin,pane,doPin){var updown=$Pin.attr("pin");if(updown&&doPin===(updown=="down"))return;var pin=inst.options[pane].buttonClass+"-pin",side=pin+"-"+pane,UP=pin+"-up "+side+"-up",DN=pin+"-down "+side+"-down";$Pin.attr("pin",doPin?"down":"up").attr("title",doPin?lang.Unpin:lang.Pin).removeClass(doPin?UP:DN).addClass(doPin?DN:UP)},syncPinBtns:function(inst,pane,doPin){$.each(state[pane].pins,
function(i,selector){$.layout.buttons.setPinState(inst,$(selector),pane,doPin)})},_load:function(inst){var _=$.layout.buttons;$.extend(inst,{bindButton:function(sel,action,pane){return _.bind(inst,sel,action,pane)},addToggleBtn:function(sel,pane,slide){return _.addToggle(inst,sel,pane,slide)},addOpenBtn:function(sel,pane,slide){return _.addOpen(inst,sel,pane,slide)},addCloseBtn:function(sel,pane){return _.addClose(inst,sel,pane)},addPinBtn:function(sel,pane){return _.addPin(inst,sel,pane)}});for(var i=
0;i<4;i++){var pane=$.layout.config.borderPanes[i];inst.state[pane].pins=[]}if(inst.options.autoBindCustomButtons)_.init(inst)},_unload:function(inst){}};$.layout.onLoad.push($.layout.buttons._load);$.layout.plugins.browserZoom=true;$.layout.defaults.browserZoomCheckInterval=1E3;$.layout.optionsMap.layout.push("browserZoomCheckInterval");$.layout.browserZoom={_init:function(inst){if($.layout.browserZoom.ratio()!==false)$.layout.browserZoom._setTimer(inst)},_setTimer:function(inst){if(inst.destroyed)return;
var o=inst.options,s=inst.state,ms=inst.hasParentLayout?5E3:Math.max(o.browserZoomCheckInterval,100);setTimeout(function(){if(inst.destroyed||!o.resizeWithWindow)return;var d=$.layout.browserZoom.ratio();if(d!==s.browserZoom){s.browserZoom=d;inst.resizeAll()}$.layout.browserZoom._setTimer(inst)},ms)},ratio:function(){var w=window,s=screen,d=document,dE=d.documentElement||d.body,b=$.layout.browser,v=b.version,r,sW,cW;if(b.msie&&v>8||!b.msie)return false;if(s.deviceXDPI)return calc(s.deviceXDPI,s.systemXDPI);
if(b.webkit&&(r=d.body.getBoundingClientRect))return calc(r.left-r.right,d.body.offsetWidth);if(b.webkit&&(sW=w.outerWidth))return calc(sW,w.innerWidth);if((sW=s.width)&&(cW=dE.clientWidth))return calc(sW,cW);return false;function calc(x,y){return(parseInt(x,10)/parseInt(y,10)*100).toFixed()}}};$.layout.onReady.push($.layout.browserZoom._init)})(jQuery);


define("jquery.layout", ["jquery"], function(){});



define('src/VisualEditor',
		[	'src/controller',
			'src/ViewController',
			'src/notificationBar',
			'src/uiConfig',
			'src/SyntaxHighlighter',
			'src/citationEditor',
			'src/Schema',
			'src/schemaOptions',
			'src/CslNode',
			'src/citationEngine',
			'src/options',
			'src/storage',
			'src/cslData',
			'src/cslStyles',
			'src/debug',
			'jquery.hoverIntent',
			'jquery.layout'
		],
		function (
			CSLEDIT_controller,
			CSLEDIT_ViewController,
			CSLEDIT_notificationBar,
			CSLEDIT_uiConfig,
			CSLEDIT_SyntaxHighlighter,
			CSLEDIT_citationEditor,
			CSLEDIT_Schema,
			CSLEDIT_schemaOptions,
			CSLEDIT_CslNode,
			CSLEDIT_citationEngine,
			CSLEDIT_options,
			CSLEDIT_storage,
			CSLEDIT_data,
			CSLEDIT_cslStyles,
			debug,
			jquery_hoverIntent,
			jquery_layout
		) {
	return function VisualEditor(editorElement, userOptions) {
		var editTimeout,
			styleURL,
			syntaxHighlighter,
			nodePathView;

		$(document).ready(function () {
			if (!$.browser.webkit && !$.browser.mozilla && !$.browser.chrome) {
				$('body').html("<h2>Please use the latest version of " +
					"Chrome or Firefox to view this page.</h2>").css({margin: 50});
				return;
			}

			CSLEDIT_options.setUserOptions(userOptions);

			editorElement = $(editorElement);

			$.ajax({
				url: CSLEDIT_options.getUrl("html/visualEditor.html"),
				success : function (data) {
					editorElement.html(data);
					window.CSLEDIT_schema = new CSLEDIT_Schema(CSLEDIT_schemaOptions);
					CSLEDIT_schema.callWhenReady(init);
				},
				error : function (jaXHR, textStatus, errorThrown) {
					alert("Couldn't fetch page: " + textStatus);
				},
				cache : false
			});
		});

		var createTreeView = function () {
			var nodeIndex = { index : 0 };
			var cslData = CSLEDIT_data.get(); 

			CSLEDIT_viewController.init(cslData,
			{
				formatCitations : formatExampleCitations,
				deleteNode : function () {
					CSLEDIT_controller.exec("deleteNode", [CSLEDIT_viewController.selectedNode()]);
				},
				moveNode : function (move) {
					var temp,
						fromId,
						toId,
						toParentNode,
						index;

					fromId = parseInt(move.o.attr("cslid"), 10);
					toId = parseInt(move.r.attr("cslid"), 10);
					toParentNode = CSLEDIT_data.getNodeAndParent(toId).parent;

					if (move.last_pos !== false) {
						CSLEDIT_controller.exec("moveNode", [fromId, toId, move.last_pos]);
					}
				},
				checkMove : function (fromId, toId, position) {
					var fromNode = CSLEDIT_data.getNode(fromId),
						toNodeInfo = CSLEDIT_data.getNodeAndParent(toId),
						parentNodeName,
						result,
						toCslId;

					if (position === "before" || position === "after") {
						if (toNodeInfo.parent === null) {
							return false;
						}
						// go up a level
						toNodeInfo = CSLEDIT_data.getNodeAndParent(toNodeInfo.parent.cslId);
					}

					// for moving to a macro instance, note that if the move goes ahead,
					// this translation is done in CSLEDIT_data.addNode, so it's fine to
					// give the macro instance id to the addNode controller command
					toCslId = CSLEDIT_data.macroDefinitionIdFromInstanceId(toNodeInfo.node.cslId);
					if (toCslId !== toNodeInfo.node.cslId) {
						toNodeInfo = CSLEDIT_data.getNodeAndParent(toCslId);
					}

					if (toNodeInfo.parent === null) {
						parentNodeName = "root";
					} else {
						parentNodeName = toNodeInfo.parent.name;
					}
					result = (fromNode.name in 
						CSLEDIT_schema.childElements(parentNodeName + "/" + toNodeInfo.node.name));
					return result;
				},
				viewInitialised : function () {
					var loaded = CSLEDIT_options.get("onLoaded");
					if (typeof(loaded) !== "undefined") {
						loaded();
					}
				}
			});
		};

		var formatExampleCitations = function () {
			CSLEDIT_citationEngine.runCiteprocAndDisplayOutput(
				editorElement.find("#statusMessage"), editorElement.find("#exampleOutput"),
				editorElement.find("#formattedCitations"), editorElement.find("#formattedBibliography"),
				syntaxHighlighter.setupSyntaxHighlighting);
		};

		var reloadPageWithNewStyle = function (newURL) {
			var reloadURL = window.location.href;
			reloadURL = reloadURL.replace(/#/, "");
			reloadURL = reloadURL.replace(/\?.*$/, "");
			window.location.href = reloadURL + "?styleURL=" + newURL;
		};

		var showAddNodeDialog = function () {
			var dialogDiv = $('<div id="addNodeDialog"></div>'),
				node = CSLEDIT_data.getNode(CSLEDIT_viewController.selectedNode()),
				translatedCslId,
				translatedNodeInfo,
				translatedParentName,
				possibleElements,
				element,
				table = $('<table></table>'),
				possibleElementsExist = false;

			if (node === null) {
				alert("Please select a node in to create within first");
				return;
			}

			dialogDiv.attr('title', 'Add node within ' + CSLEDIT_uiConfig.displayNameFromNode(node));

			// populate with possible child elements based on schema
			
			// in case the user is selecting a macro instance:
			translatedCslId = CSLEDIT_data.macroDefinitionIdFromInstanceId(node.cslId);
			translatedNodeInfo = CSLEDIT_data.getNodeAndParent(translatedCslId);
		
			if (translatedNodeInfo.parent === null) {
				translatedParentName = "root";
			} else {
				translatedParentName = translatedNodeInfo.parent.name;
			}

			possibleElements = CSLEDIT_viewController.selectedViewProperty("possibleChildren");
			if (possibleElements === null) {
				possibleElements = {};

				$.each(CSLEDIT_schema.childElements(translatedParentName + "/" + translatedNodeInfo.node.name),
					function (element, quantifier) {
						possibleElements[element] = quantifier;
					}
				);
			}

			// hard-coded constraint for 'choose' node
			// TODO: generalise this to more nodes, using the schema if not too difficult
			if (translatedNodeInfo.node.name === "choose") {
				// better order than schema:
				possibleElements = {
					"if" : "one",
					"else-if" : "zeroOrMore",
					"else" : "optional"
				};

				// only allowed one 'if' and one 'else' node
				$.each(translatedNodeInfo.node.children, function (i, childNode) {
					if (childNode.name === "if" && "if" in possibleElements) {
						delete possibleElements["if"];
					} else if (childNode.name === "else" && "else" in possibleElements) {
						delete possibleElements["else"];
					}
				});
			}

			$.each(possibleElements, function (element) {
				var img = '<td></td>',
					nodeIcon = CSLEDIT_uiConfig.nodeIcons[element],
					documentation = CSLEDIT_schema.documentation(
						translatedNodeInfo.node.name + "/" + element),
					row,
					displayName;

				if (typeof nodeIcon !== "undefined") {
					img = '<td><img src="' + CSLEDIT_options.getUrl(nodeIcon) + '"></img></td>';
				}

				displayName = 
					CSLEDIT_uiConfig.displayNameFromNode(new CSLEDIT_CslNode(element));

				debug.log("display name = " + displayName);

				row = $('<tr>' + img + '<td><button class="addNodeType" data-nodeName="' +
					element + '">' + 
					displayName + 
					'</button></td></tr>');

				if (typeof(documentation) !== "undefined") {
					row.append('<td>' + documentation + '</td>');
				}

				table.append(row);

				possibleElementsExist = true;
			});

			if (!possibleElementsExist) {
				alert("You can't create nodes within " + CSLEDIT_uiConfig.displayNameFromNode(node) + ".");
				return;
			}

			dialogDiv.append(table);

			dialogDiv.find('button.addNodeType').on('click', function (event) {
				var target = $(event.target),
					nodeName = target.attr('data-nodeName'),
					position,
					children = CSLEDIT_data.getNode(CSLEDIT_viewController.selectedNode()).children;

				dialogDiv.dialog('destroy');

				position = "last";
				// override position for certain nodes
				// TODO: generalise
				if (nodeName === 'if') {
					position = "first";
				} else if (nodeName === 'else-if' && children[children.length - 1].name === "else") {
					position = children.length - 1;
				} else if (nodeName === 'macro') {
					position = "last";
					// put it before the citation node:
					$.each(children, function (i, child) {
						if (child.name === "citation") {
							position = i;
							return false;
						}
					});
				}

				CSLEDIT_controller.exec("addNode", [
					CSLEDIT_viewController.selectedNode(), position, { name : nodeName, attributes : []}
				]);
			});
			dialogDiv.dialog({
				modal : true,
				width : "650px"
			});
		};

		var setupTreeEditorToolbar = function () {
			var toolbar = editorElement.find('#treeEditorToolbar'),
				addNodeButton = toolbar.find('a.add'),
				deleteNodeButton = toolbar.find('a.delete');

			debug.assertEqual(addNodeButton.length, 1);
			debug.assertEqual(deleteNodeButton.length, 1);

			addNodeButton.on('click', function (e) {
				showAddNodeDialog();
				e.preventDefault();
			});

			deleteNodeButton.on('click', function (e) {
				CSLEDIT_controller.exec("deleteNode", [CSLEDIT_viewController.selectedNode()]);
				e.preventDefault();
			});
		};

		var setupDropdownMenuHandler = function (selector) {
			var dropdown = $(selector),
				loadCsl;

			dropdown.filter('a.menuLoadcsl').html(CSLEDIT_options.get('loadCSLName'));
			dropdown.filter('a.menuSavecsl').html(CSLEDIT_options.get('saveCSLName'));

			editorElement.find('#menuNewStyle').click(function () {
				// fetch the URL
				$.ajax({
					url : CSLEDIT_options.getUrl("/content/newStyle.csl"),
					dataType : "text",
					success : function (cslCode) {
						debug.log("csl code received: " + cslCode);
						CSLEDIT_controller.exec('setCslCode', [cslCode]);
					},
					error : function () {
						throw new Error("Couldn't fetch new style");
					},
					async : false
				});
	//			CSLEDIT_controller.exec('setCslCode', [newStyle]);
			});

			editorElement.find('#menuLoadCsl').click(function () {
				var csl = CSLEDIT_options.get('loadCSLFunc')();
				if (csl !== null && typeof csl !== "undefined") {
					CSLEDIT_controller.exec('setCslCode', [csl]);
				}
			});
			
			editorElement.find('#menuLoadStyleFromUrl').click(function () {
				var styleURL = prompt("Please enter the URL of the style you want to load");

				if (typeof(styleURL) === "string" && styleURL !== "") {
					// fetch the URL
					$.ajax({
						url : '../getFromOtherWebsite.php?url=' + encodeURIComponent(styleURL),
						dataType : "text",
						success : function (newStyle) {
							CSLEDIT_controller.exec("setCslCode", [newStyle]);
						},
						error : function () {
							debug.log("ajax error: style not loaded");
						},
						async : false
					});
				}
			});
			
			editorElement.find('#menuSaveCsl').click(function () {
				CSLEDIT_options.get('saveCSLFunc')(CSLEDIT_data.getCslCode());
			});
			
			editorElement.find('#menuUndo').click(function () {
				if (CSLEDIT_controller.commandHistory.length === 0) {
					alert("No commands to undo");
				} else {
					CSLEDIT_controller.undo();
				}
			});
			
			editorElement.find('#menuRedo').click(function () {
				if (CSLEDIT_controller.undoCommandHistory.length === 0) {
					alert("No commands to redo");
				} else {
					CSLEDIT_controller.redo();
				}
			});
			
			editorElement.find('#menuEditCitation1').click(function () {
				CSLEDIT_citationEditor.editCitation(0);
			});
			
			editorElement.find('#menuEditCitation2').click(function () {
				CSLEDIT_citationEditor.editCitation(1);
			});

			editorElement.find('#menuEditCitation3').click(function () {
				CSLEDIT_citationEditor.editCitation(2);
			});
		};

		var init = function () {
			var reloadingPage = false;

			// set function which gets called if inconsistencies
			// are found between the localStorage data (shared between tabs) and this session
			// data
			CSLEDIT_storage.onDataInconsistency(function () {
				if (confirm("Your style has changed in a different tab.\n" +
						"Do you want to load the new version into this tab?")) {
					// reload page
					reloadingPage = true;
					window.location.reload();
				} else {
					// use existing data
					CSLEDIT_storage.recreateLocalStorage();
				}
			});

			// check consistency of data on window focus
			// to detect changes in different tabs
			debug.log("window length = " + $(window).length);
			$(window).focus(function () {
				if (!reloadingPage) {
					CSLEDIT_data.get();
				}
			});

			$(function () {
				editorElement.find("ul.dropdown li").hoverIntent(function () {
					$(this).addClass("hover");
					$('ul:first', this).css('visibility', 'visible');
				}, function () {
					$(this).removeClass("hover");
					$('ul:first', this).css('visibility', 'hidden');
				});
				
				editorElement.find("ul.dropdown li ul li:has(ul)").find("a:first").append(" &raquo; ");
			});

			CSLEDIT_data.initPageStyle(function () {
				var userOnChangeCallback = CSLEDIT_options.get("onChange"),
					citationEditor1,
					citationEditor2;
				
				syntaxHighlighter = new CSLEDIT_SyntaxHighlighter(editorElement);

				// TODO: remove this global
				window.CSLEDIT_viewController = new CSLEDIT_ViewController(
					editorElement.find("#treeEditor"),
					editorElement.find("#titlebar"),
					editorElement.find("#elementProperties"),
					editorElement.find("#nodePathView"),
					syntaxHighlighter);

				CSLEDIT_controller.setCslData(CSLEDIT_data);
				CSLEDIT_data.addViewController(CSLEDIT_viewController);

				if (typeof userOnChangeCallback === "function") {
					CSLEDIT_data.addViewController({
						styleChanged : function (command) {
							if (command === "formatCitations") {
								userOnChangeCallback();
							}
						}
					});
				}

				createTreeView();
			});

			setupTreeEditorToolbar();
			setupDropdownMenuHandler(".dropdown a");

			editorElement.find('#mainContainer').layout({
				closable : false,
				resizable : true,
				livePaneResizing : true,
				west__size : CSLEDIT_storage.getItem("CSLEDIT_geometry.leftPaneWidth") || 240,
				west__minSize : 200,
				onresize : function (paneName, paneElement, paneState) {
					if (paneState.edge === "west") {
						CSLEDIT_storage.setItem("CSLEDIT_geometry.leftPaneWidth", paneState.size);
					}
				}
			});

			editorElement.find("#rightContainer").layout({
				closable : false,
				resizable : true,
				livePaneResizing : true,
				north__size : CSLEDIT_storage.getItem("CSLEDIT_geometry.topPaneWidth") || 300,
				onresize : function (paneName, paneElement, paneState) {
					if (paneState.edge === "north") {
						CSLEDIT_storage.setItem("CSLEDIT_geometry.topPaneWidth", paneState.size);
					}
				}
			});

			CSLEDIT_notificationBar.init(editorElement.find('#notificationBar'));
		};

		// used to generate the ids in the Zotero style repository
		var getNormalisedStyleName = function () {
			return getStyleName().replace(/[\(\)]/g, "").replace(/[\\\/:"*?<>| ]+/g, "-").toLowerCase();
		};

		// returns true to continue, false to cancel
		var conformStyleToRepoConventions = function () {
			// checks that the style conforms to repository conventions and
			// prompts the user to change it if it doesn't
			
			var generatedStyleId,
				links,
				selfLinkNode,
				selfLink,
				styleName = getStyleName(),
				cancel = false;

			// check that the styleId and rel self link matches the schema conventions
			generatedStyleId = "http://www.zotero.org/styles/" + getNormalisedStyleName();
			links = CSLEDIT_data.getNodesFromPath("style/info/link");
			$.each(links, function (i, link) {
				link = new CSLEDIT_CslNode(link);

				if (link.getAttr("rel") === "self") {
					selfLinkNode = link;
					selfLink = link.getAttr("href");
				}
			});

			debug.log("generatedStyleId = " + generatedStyleId);
			$.each(CSLEDIT_cslStyles.styleTitleFromId, function (id, name) {
				if (id === generatedStyleId || name === styleName) {
					if (!confirm('The style title matches one that already exists.\n\n' +
							'You should change it to avoid problems using this style ' +
							'in your reference manager.\n\n' +
							'Do you want to save anyway?')) {
						cancel = true;
						return false;
					}
				}
			});

			if (cancel) {
				return false;
			}

			if (selfLink !== generatedStyleId || getStyleId() !== generatedStyleId) {
				if (confirm('Change style ID and "self" link to the following?\n\n' +
						generatedStyleId + "\n\n(the CSL styles repository convention)")) {
					setStyleId(generatedStyleId);
					if (typeof(selfLinkNode) !== "undefined") {
						selfLinkNode.setAttr("href", generatedStyleId);
						CSLEDIT_controller.exec("amendNode", [selfLinkNode.cslId, selfLinkNode]);
					} else {
						CSLEDIT_controller.exec("addNode", [CSLEDIT_data.getNodesFromPath("style/info")[0].cslId, "last",
							new CSLEDIT_CslNode("link", [
								{key: "rel", value: "self", enabled: true},
								{key: "href", value: generatedStyleId, enabled: true}
							])]);
					}
				}
			}
			return true;
		};

		var getStyleName = function () {
			var styleNameNode = CSLEDIT_data.getNodesFromPath('style/info/title')[0];
			return styleNameNode.textValue;
		};

		var getStyleId = function () {
			var styleIdNode = CSLEDIT_data.getNodesFromPath('style/info/id')[0];
			return styleIdNode.textValue;
		};
			
		var setStyleId = function (styleId) {
			var styleIdNode = CSLEDIT_data.getNodesFromPath('style/info/id')[0];
			styleIdNode.textValue = styleId;
			CSLEDIT_controller.exec('amendNode', [styleIdNode.cslId, styleIdNode]);
		};

		// public API
		return {
			setCslCode : function (cslCode) {
				CSLEDIT_controller.exec('setCslCode', [cslCode]);
			},
			getCslCode : function () {
				return CSLEDIT_data.getCslCode();
			},
			getStyleName : getStyleName,
			getStyleId : getStyleId,
			setStyleId : setStyleId,
			conformStyleToRepoConventions : conformStyleToRepoConventions,
			getNormalisedStyleName : getNormalisedStyleName
		};
	};
});
